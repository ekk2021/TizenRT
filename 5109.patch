From b377cb39c1865d6de82c3f651420fb005836565d Mon Sep 17 00:00:00 2001
From: keerthanalex <keerthanaradha23@gmail.com>
Date: Wed, 25 Aug 2021 08:13:09 +0800
Subject: [PATCH] os/board/rtl8721csm : add i2c for amebad

Changed the rtk API name for a conflict
Registered the i2c device in the original boot code
Added the i2c source code
---
 os/arch/arm/src/amebad/Make.defs              |    6 +-
 os/arch/arm/src/amebad/amebad_i2c.c           | 1164 +++++++++++
 os/arch/arm/src/amebad/amebad_i2c.h           |   36 +
 os/arch/arm/src/amebad/amebad_i2s.c           | 1815 +++++++++++++++++
 os/arch/arm/src/amebad/amebad_i2s.h           |   90 +
 os/arch/arm/src/amebad/amebad_spi.c           | 1198 +++++++++++
 os/arch/arm/src/amebad/amebad_spi.h           |  140 ++
 os/board/rtl8721csm/src/Make.defs             |    1 +
 .../src/component/common/mbed/hal/i2c_api.h   |    4 +-
 .../mbed/targets/hal/rtl8721d/i2c_api.c       |    4 +-
 os/board/rtl8721csm/src/rtl8721csm_boot.c     |   50 +
 os/board/rtl8721csm/src/rtl8721csm_i2schar.c  |   99 +
 12 files changed, 4602 insertions(+), 5 deletions(-)
 create mode 100644 os/arch/arm/src/amebad/amebad_i2c.c
 create mode 100644 os/arch/arm/src/amebad/amebad_i2c.h
 create mode 100644 os/arch/arm/src/amebad/amebad_i2s.c
 create mode 100644 os/arch/arm/src/amebad/amebad_i2s.h
 create mode 100644 os/arch/arm/src/amebad/amebad_spi.c
 create mode 100644 os/arch/arm/src/amebad/amebad_spi.h
 create mode 100644 os/board/rtl8721csm/src/rtl8721csm_i2schar.c

diff --git a/os/arch/arm/src/amebad/Make.defs b/os/arch/arm/src/amebad/Make.defs
index 0620679bee..47992bebb6 100644
--- a/os/arch/arm/src/amebad/Make.defs
+++ b/os/arch/arm/src/amebad/Make.defs
@@ -93,7 +93,7 @@ CMN_CSRCS += up_ramvec_initialize.c up_ramvec_attach.c
 endif
 
 ifeq ($(CONFIG_ARMV8M_TRUSTZONE),y)
-CMN_ASRCS += up_secure_context.S 
+CMN_ASRCS += up_secure_context.S
 endif
 
 ifeq ($(CONFIG_BUILD_PROTECTED),y)
@@ -168,6 +168,10 @@ CHIP_CSRCS += amebad_timer_lowerhalf.c
 CHIP_CSRCS += amebad_rtc_lowerhalf.c
 CHIP_CSRCS += amebad_rtc.c
 CHIP_CSRCS += amebad_watchdog_lowerhalf.c
+CHIP_CSRCS += amebad_i2c.c
+CHIP_CSRCS += amebad_i2s.c
+CHIP_CSRCS += amebad_spi.c
+
 ifeq ($(CONFIG_BOARDCTL_RESET),y)
 CHIP_CSRCS += amebad_systemreset.c
 endif
diff --git a/os/arch/arm/src/amebad/amebad_i2c.c b/os/arch/arm/src/amebad/amebad_i2c.c
new file mode 100644
index 0000000000..f4df59b392
--- /dev/null
+++ b/os/arch/arm/src/amebad/amebad_i2c.c
@@ -0,0 +1,1164 @@
+/****************************************************************************
+ *
+ * Copyright 2021 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+/************************************************************************************
+ * Included Files
+ ************************************************************************************/
+
+#include <tinyara/config.h>
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <semaphore.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <tinyara/arch.h>
+#include <tinyara/irq.h>
+#include <tinyara/clock.h>
+#include <tinyara/semaphore.h>
+#include <tinyara/i2c.h>
+#include <tinyara/kmalloc.h>
+
+#include "mbed/targets/hal/rtl8721d/PinNames.h"
+
+#include <arch/board/board.h>
+
+#include "up_arch.h"
+
+#include "amebad_i2c.h"
+
+/************************************************************************************
+ * Pre-processor Definitions
+ ************************************************************************************/
+
+/* Configuration ********************************************************************/
+/* CONFIG_I2C_POLLED may be set so that I2C interrupts will not be used.  Instead,
+ * CPU-intensive polling will be used.
+ */
+
+/* Interrupt wait timeout in seconds and milliseconds */
+
+#if !defined(CONFIG_AMEBAD_I2CTIMEOSEC) && !defined(CONFIG_AMEBAD_I2CTIMEOMS)
+#define CONFIG_AMEBAD_I2CTIMEOSEC 0
+#define CONFIG_AMEBAD_I2CTIMEOMS  500	/* Default is 500 milliseconds */
+#elif !defined(CONFIG_AMEBAD_I2CTIMEOSEC)
+#define CONFIG_AMEBAD_I2CTIMEOSEC 0	/* User provided milliseconds */
+#elif !defined(CONFIG_AMEBAD_I2CTIMEOMS)
+#define CONFIG_AMEBAD_I2CTIMEOMS  0	/* User provided seconds */
+#endif
+
+/* Interrupt wait time timeout in system timer ticks */
+
+#ifndef CONFIG_AMEBAD_I2CTIMEOTICKS
+#define CONFIG_AMEBAD_I2CTIMEOTICKS \
+	(SEC2TICK(CONFIG_AMEBAD_I2CTIMEOSEC) + MSEC2TICK(CONFIG_AMEBAD_I2CTIMEOMS))
+#endif
+
+#ifndef CONFIG_AMEBAD_I2C_DYNTIMEO_STARTSTOP
+#define CONFIG_AMEBAD_I2C_DYNTIMEO_STARTSTOP TICK2USEC(CONFIG_AMEBAD_I2CTIMEOTICKS)
+#endif
+
+/* Debug ****************************************************************************/
+
+/* I2C event trace logic.  NOTE:  trace uses the internal, non-standard, low-level
+ * debug interface syslog() but does not require that any other debug
+ * is enabled.
+ */
+
+#ifndef CONFIG_I2C_TRACE
+#define amebad_i2c_tracereset(p)
+#define amebad_i2c_tracenew(p, s)
+#define amebad_i2c_traceevent(p, e, a)
+#define amebad_i2c_tracedump(p)
+#endif
+
+#ifndef CONFIG_I2C_NTRACE
+#define CONFIG_I2C_NTRACE 32
+#endif
+
+#define AMEBAD_I2C_MASTER    1
+#define AMEBAD_I2C_SLAVE     2
+
+#define I2C_MASTER_DEVICE		1
+#define I2C_SLAVE_DEVICE		2
+
+#define MKI2C_OUTPUT(p) (((p) & GPIO_PADMUX_MASK) | \
+			 IOMUX_OPENDRAIN | IOMUX_DRIVE_33OHM | \
+			 IOMUX_SLEW_SLOW | (5 << GPIO_ALT_SHIFT) | \
+			 IOMUX_PULL_NONE | GPIO_OUTPUT_ONE)
+
+#define MKI2C_INPUT(p) (((p) & GPIO_PADMUX_MASK) | \
+			IOMUX_DRIVE_HIZ | IOMUX_SLEW_SLOW | \
+			IOMUX_CMOS_INPUT | (5 << GPIO_ALT_SHIFT) | \
+			IOMUX_PULL_NONE)
+
+/************************************************************************************
+ * Private Types
+ ************************************************************************************/
+
+/* Interrupt state */
+
+enum amebad_intstate_e {
+	INTSTATE_IDLE = 0,			/* No I2C activity */
+	INTSTATE_WAITING,			/* Waiting for completion of interrupt activity */
+	INTSTATE_DONE,				/* Interrupt activity complete */
+};
+
+/* Trace events */
+
+#ifdef CONFIG_I2C_TRACE
+enum amebad_trace_e {
+	I2CEVENT_NONE = 0,			/* No events have occurred with this status */
+	I2CEVENT_SENDADDR,			/* Start/Master bit set and address sent, param = msgc */
+	I2CEVENT_SENDBYTE,			/* Send byte, param = dcnt */
+	I2CEVENT_RCVBYTE,			/* Read more dta, param = dcnt */
+	I2CEVENT_NOSTART,			/* BTF on last byte with no restart, param = msgc */
+	I2CEVENT_STARTRESTART,		/* Last byte sent, re-starting, param = msgc */
+	I2CEVENT_STOP,				/* Last byte sten, send stop, param = 0 */
+	I2CEVENT_ERROR				/* Error occurred, param = 0 */
+};
+
+/* Trace data */
+
+struct amebad_trace_s {
+	uint32_t status;			/* I2C 32-bit SR2|SR1 status */
+	uint32_t count;				/* Interrupt count when status change */
+	enum amebad_intstate_e event;	/* Last event that occurred with this status */
+	uint32_t parm;				/* Parameter associated with the event */
+	clock_t time;				/* First of event or first status */
+};
+#endif
+
+/* I2C Device hardware configuration */
+
+struct amebad_i2c_config_s {
+	uint32_t base;				/* I2C base address */
+	//uint16_t busy_idle;			/* I2C Bus Idle Timeout */
+	//uint8_t filtscl;			/* Glitch Filter for SCL pin */
+	//uint8_t filtsda;			/* Glitch Filter for SDA pin */
+	uint32_t scl_pin;			/* GPIO configuration for SCL as SCL */
+	uint32_t sda_pin;			/* GPIO configuration for SDA as SDA */
+	uint8_t mode;				/* Master or Slave mode */
+#ifndef CONFIG_I2C_POLLED
+	uint32_t irq;				/* Event IRQ */
+#endif
+};
+
+struct i2c_m {
+	uint32_t i2c_idx;
+	I2C_TypeDef * I2Cx;
+};
+typedef struct i2c_m i2c_t;
+
+/* I2C Device Private Data */
+
+struct amebad_i2c_priv_s {
+	const struct i2c_ops_s *ops;	/* Standard I2C operations */
+	const struct amebad_i2c_config_s *config;	/* Port configuration */
+	int refs;					/* Referernce count */
+	sem_t sem_excl;				/* Mutual exclusion semaphore */
+#ifndef CONFIG_I2C_POLLED
+	sem_t sem_isr;				/* Interrupt wait semaphore */
+#endif
+	volatile uint8_t intstate;	/* Interrupt handshake (see enum amebad_intstate_e) */
+	int address;				/* Address used in this instantiation */
+
+	uint8_t msgc;				/* Message count */
+	struct i2c_msg_s *msgv;		/* Message list */
+	uint8_t *ptr;				/* Current message buffer */
+	uint32_t frequency;			/* Current I2C frequency */
+	int dcnt;					/* Current message length */
+	uint16_t flags;				/* Current message flags */
+
+	i2c_t *i2c_object;
+
+	/* I2C trace support */
+
+#ifdef CONFIG_I2C_TRACE
+	int tndx;					/* Trace array index */
+	clock_t start_time;			/* Time when the trace was started */
+
+	/* The actual trace data */
+
+	struct amebad_trace_s trace[CONFIG_I2C_NTRACE];
+#endif
+
+	uint32_t status;			/* End of transfer SR2|SR1 status */
+};
+
+/************************************************************************************
+ * Private Function Prototypes
+ ************************************************************************************/
+
+static inline void amebad_i2c_modifyreg(FAR struct amebad_i2c_priv_s *priv, uint16_t offset, uint32_t clearbits, uint32_t setbits);
+static inline void amebad_i2c_sem_wait(FAR struct amebad_i2c_priv_s *priv);
+
+#ifdef CONFIG_AMEBAD_I2C_DYNTIMEO
+static useconds_t amebad_i2c_tousecs(int msgc, FAR struct i2c_msg_s *msgs);
+#endif							/* CONFIG_AMEBAD_I2C_DYNTIMEO */
+
+static inline int amebad_i2c_sem_waitdone(FAR struct amebad_i2c_priv_s *priv);
+static inline void amebad_i2c_sem_waitstop(FAR struct amebad_i2c_priv_s *priv);
+static inline void amebad_i2c_sem_post(FAR struct amebad_i2c_priv_s *priv);
+static inline void amebad_i2c_sem_init(FAR struct amebad_i2c_priv_s *priv);
+static inline void amebad_i2c_sem_destroy(FAR struct amebad_i2c_priv_s *priv);
+
+#ifdef CONFIG_I2C_TRACE
+static void amebad_i2c_tracereset(FAR struct amebad_i2c_priv_s *priv);
+static void amebad_i2c_tracenew(FAR struct amebad_i2c_priv_s *priv, uint32_t status);
+static void amebad_i2c_traceevent(FAR struct amebad_i2c_priv_s *priv, enum amebad_trace_e event, uint32_t parm);
+static void amebad_i2c_tracedump(FAR struct amebad_i2c_priv_s *priv);
+#endif							/* CONFIG_I2C_TRACE */
+
+static void amebad_i2c_setclock(FAR struct amebad_i2c_priv_s *priv, uint32_t frequency);
+static inline void amebad_i2c_sendstart(FAR struct amebad_i2c_priv_s *priv, uint8_t address);
+static inline void amebad_i2c_sendstop(FAR struct amebad_i2c_priv_s *priv);
+static inline uint32_t amebad_i2c_getstatus(FAR struct amebad_i2c_priv_s *priv);
+
+static int amebad_i2c_isr_process(struct amebad_i2c_priv_s *priv);
+
+#ifndef CONFIG_I2C_POLLED
+static int amebad_i2c_isr(int irq, void *context, FAR void *arg);
+#endif							/* !CONFIG_I2C_POLLED */
+
+static int amebad_i2c_init(FAR struct amebad_i2c_priv_s *priv);
+static int amebad_i2c_deinit(FAR struct amebad_i2c_priv_s *priv);
+#ifdef CONFIG_I2C_TRANSFER
+static int amebad_i2c_transfer(FAR struct i2c_dev_s *dev, FAR struct i2c_msg_s *msgs, int count);
+#endif
+#ifdef CONFIG_I2C_RESET
+static int amebad_i2c_reset(FAR struct i2c_master_s *dev);
+#endif
+
+static int amebad_i2c_process(FAR struct i2c_dev_s *dev, FAR struct i2c_msg_s *msgs, int count);
+static uint32_t amebad_i2c_setfrequency(FAR struct i2c_dev_s *dev, uint32_t frequency);
+static int amebad_i2c_setaddress(FAR struct i2c_dev_s *dev, int addr, int nbits);
+static int amebad_i2c_write(FAR struct i2c_dev_s *dev, const uint8_t *buffer, int buflen);
+static int amebad_i2c_read(FAR struct i2c_dev_s *dev, uint8_t *buffer, int buflen);
+#ifdef CONFIG_I2C_WRITEREAD
+static int amebad_i2c_writeread(FAR struct i2c_dev_s *dev, const uint8_t *wbuffer, int wbuflen, uint8_t *buffer, int buflen);
+#endif
+
+/************************************************************************************
+ * Private Data
+ ************************************************************************************/
+
+/* Trace events strings */
+
+#ifdef CONFIG_I2C_TRACE
+static const char *g_trace_names[] = {
+	"NONE           ",
+	"SENDADDR       ",
+	"SENDBYTE       ",
+	"RCVBYTE        ",
+	"NOSTART        ",
+	"START/RESTART  ",
+	"STOP           ",
+	"ERROR          "
+};
+#endif
+
+/* I2C interface */
+
+static const struct i2c_ops_s amebad_i2c_ops = {
+	.setfrequency = amebad_i2c_setfrequency,
+	.setaddress = amebad_i2c_setaddress,
+	.write = amebad_i2c_write,
+	.read = amebad_i2c_read,
+#ifdef CONFIG_I2C_WRITEREAD
+	.writeread = amebad_i2c_writeread,
+#endif
+#ifdef CONFIG_I2C_TRANSFER
+	.transfer = amebad_i2c_transfer,
+#endif
+#ifdef CONFIG_I2C_SLAVE
+	.setownaddress = amebad_i2c_setaddress, //amebad_i2c_setownaddress,
+	.registercallback = amebad_i2c_registercallback
+#endif
+};
+
+/* I2C device structures */
+
+static const struct amebad_i2c_config_s amebad_i2c1_config = {
+	//.base = AMEBAD_I2C1_BASE,
+	//.busy_idle = CONFIG_I2C1_BUSYIDLE,
+	//.filtscl = CONFIG_I2C1_FILTSCL,
+	//.filtsda = CONFIG_I2C1_FILTSDA,
+	.scl_pin = PA_25,
+	.sda_pin = PA_26,
+#ifndef CONFIG_I2C_SLAVE
+	.mode = AMEBAD_I2C_MASTER,
+#else
+	.mode = AMEBAD_I2C_SLAVE,
+#endif
+#ifndef CONFIG_I2C_POLLED
+	.irq = AMEBAD_IRQ_I2C0,
+#endif
+};
+
+static struct amebad_i2c_priv_s amebad_i2c1_priv = {
+	.ops = &amebad_i2c_ops,
+	.config = &amebad_i2c1_config,
+	.refs = 0,
+	.intstate = INTSTATE_IDLE,
+	.msgc = 0,
+	.msgv = NULL,
+	.ptr = NULL,
+	.dcnt = 0,
+	.flags = 0,
+	.status = 0
+};
+
+/************************************************************************************
+ * Private Functions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Name: amebad_i2c_modifyreg
+ *
+ * Description:
+ *   Modify a 32-bit register value by offset
+ *
+ ************************************************************************************/
+
+static inline void amebad_i2c_modifyreg(FAR struct amebad_i2c_priv_s *priv, uint16_t offset, uint32_t clearbits, uint32_t setbits)
+{
+	//modifyreg32(priv->config->base + offset, clearbits, setbits);
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_sem_wait
+ *
+ * Description:
+ *   Take the exclusive access, waiting as necessary
+ *
+ ************************************************************************************/
+
+static inline void amebad_i2c_sem_wait(FAR struct amebad_i2c_priv_s *priv)
+{
+	int ret;
+
+	do {
+		/* Take the semaphore (perhaps waiting) */
+
+		ret = sem_wait(&priv->sem_excl);
+
+		/* The only case that an error should occur here is if the wait was
+		 * awakened by a signal.
+		 */
+
+		DEBUGASSERT(ret == OK || errno == EINTR);
+	} while (errno == EINTR);
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_tousecs
+ *
+ * Description:
+ *   Return a micro-second delay based on the number of bytes left to be processed.
+ *
+ ************************************************************************************/
+
+#ifdef CONFIG_AMEBAD_I2C_DYNTIMEO
+static useconds_t amebad_i2c_tousecs(int msgc, FAR struct i2c_msg_s *msgs)
+{
+	size_t bytecount = 0;
+	int i;
+
+	/* Count the number of bytes left to process */
+
+	for (i = 0; i < msgc; i++) {
+		bytecount += msgs[i].length;
+	}
+
+	/* Then return a number of microseconds based on a user provided scaling
+	 * factor.
+	 */
+
+	return (useconds_t)(CONFIG_AMEBAD_I2C_DYNTIMEO_USECPERBYTE * bytecount);
+}
+#endif
+
+/************************************************************************************
+ * Name: amebad_i2c_sem_waitdone
+ *
+ * Description:
+ *   Wait for a transfer to complete
+ *
+ ************************************************************************************/
+
+#ifndef CONFIG_I2C_POLLED
+static inline int amebad_i2c_sem_waitdone(FAR struct amebad_i2c_priv_s *priv)
+{
+	struct timespec abstime;
+	irqstate_t flags;
+	uint32_t regval;
+	int ret;
+
+	flags = irqsave();
+
+	/* Enable I2C interrupts */
+	up_enable_irq(priv->config->irq);
+
+	/* Signal the interrupt handler that we are waiting.  NOTE:  Interrupts
+	 * are currently disabled but will be temporarily re-enabled below when
+	 * sem_timedwait() sleeps.
+	 */
+
+	priv->intstate = INTSTATE_WAITING;
+	do {
+		/* Get the current time */
+
+		(void)clock_gettime(CLOCK_REALTIME, &abstime);
+
+		/* Calculate a time in the future */
+
+#if CONFIG_AMEBAD_I2CTIMEOSEC > 0
+		abstime.tv_sec += CONFIG_AMEBAD_I2CTIMEOSEC;
+#endif
+
+		/* Add a value proportional to the number of bytes in the transfer */
+
+#ifdef CONFIG_AMEBAD_I2C_DYNTIMEO
+		abstime.tv_nsec += 1000 * amebad_i2c_tousecs(priv->msgc, priv->msgv);
+		if (abstime.tv_nsec > 1000 * 1000 * 1000) {
+			abstime.tv_sec++;
+			abstime.tv_nsec -= 1000 * 1000 * 1000;
+		}
+#elif CONFIG_AMEBAD_I2CTIMEOMS > 0
+		abstime.tv_nsec += CONFIG_AMEBAD_I2CTIMEOMS * 1000 * 1000;
+		if (abstime.tv_nsec > 1000 * 1000 * 1000) {
+			abstime.tv_sec++;
+			abstime.tv_nsec -= 1000 * 1000 * 1000;
+		}
+#endif
+
+		/* Wait until either the transfer is complete or the timeout expires */
+
+		ret = sem_timedwait(&priv->sem_isr, &abstime);
+		if (ret != OK && errno != EINTR) {
+			/* Break out of the loop on irrecoverable errors.  This would
+			 * include timeouts and mystery errors reported by sem_timedwait.
+			 * NOTE that we try again if we are awakened by a signal (EINTR).
+			 */
+
+			break;
+		}
+	}
+
+	/* Loop until the interrupt level transfer is complete. */
+
+	while (priv->intstate != INTSTATE_DONE);
+
+	/* Set the interrupt state back to IDLE */
+
+	priv->intstate = INTSTATE_IDLE;
+
+	/* Disable I2C interrupts */
+
+	up_disable_irq(priv->config->irq);
+
+	irqrestore(flags);
+	return ret;
+}
+#else
+
+static inline int amebad_i2c_sem_waitdone(FAR struct amebad_i2c_priv_s *priv)
+{
+	uint32_t timeout;
+	clock_t start;
+	clock_t elapsed;
+	int ret;
+
+	/* Get the timeout value */
+
+#ifdef CONFIG_AMEBAD_I2C_DYNTIMEO
+	timeout = USEC2TICK(amebad_i2c_tousecs(priv->msgc, priv->msgv));
+#else
+	timeout = CONFIG_AMEBAD_I2CTIMEOTICKS;
+#endif
+
+	/* Signal the interrupt handler that we are waiting.  NOTE:  Interrupts
+	 * are currently disabled but will be temporarily re-enabled below when
+	 * sem_timedwait() sleeps.
+	 */
+
+	priv->intstate = INTSTATE_WAITING;
+	start = clock_systimer();
+
+	do {
+		/* Poll by simply calling the timer interrupt handler until it
+		 * reports that it is done.
+		 */
+
+		ret = amebad_i2c_isr_process(priv);
+
+		/* Calculate the elapsed time */
+
+		elapsed = clock_systimer() - start;
+	}
+
+	/* Loop until the transfer is complete. */
+
+	while (priv->intstate != INTSTATE_DONE && elapsed < timeout);
+
+	i2cinfo("intstate: %d elapsed: %d threshold: %d status: %08x\n", priv->intstate, elapsed, timeout, priv->status);
+
+	/* Set the interrupt state back to IDLE */
+
+	ret = priv->intstate == INTSTATE_DONE ? ret : -ETIMEDOUT;
+	priv->intstate = INTSTATE_IDLE;
+	return ret;
+}
+#endif
+
+/************************************************************************************
+ * Name: amebad_i2c_sem_waitstop
+ *
+ * Description:
+ *   Wait for a STOP to complete
+ *
+ ************************************************************************************/
+
+static inline void amebad_i2c_sem_waitstop(FAR struct amebad_i2c_priv_s *priv)
+{
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_sem_post
+ *
+ * Description:
+ *   Release the mutual exclusion semaphore
+ *
+ ************************************************************************************/
+
+static inline void amebad_i2c_sem_post(struct amebad_i2c_priv_s *priv)
+{
+	sem_post(&priv->sem_excl);
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_sem_init
+ *
+ * Description:
+ *   Initialize semaphores
+ *
+ ************************************************************************************/
+
+static inline void amebad_i2c_sem_init(FAR struct amebad_i2c_priv_s *priv)
+{
+	sem_init(&priv->sem_excl, 0, 1);
+
+#ifndef CONFIG_I2C_POLLED
+	/* This semaphore is used for signaling and, hence, should not have
+	 * priority inheritance enabled.
+	 */
+
+	sem_init(&priv->sem_isr, 0, 0);
+	sem_setprotocol(&priv->sem_isr, SEM_PRIO_NONE);
+#endif
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_sem_destroy
+ *
+ * Description:
+ *   Destroy semaphores.
+ *
+ ************************************************************************************/
+
+static inline void amebad_i2c_sem_destroy(FAR struct amebad_i2c_priv_s *priv)
+{
+	sem_destroy(&priv->sem_excl);
+#ifndef CONFIG_I2C_POLLED
+	sem_destroy(&priv->sem_isr);
+#endif
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_traceclear
+ *
+ * Description:
+ *   I2C trace instrumentation
+ *
+ ************************************************************************************/
+
+#ifdef CONFIG_I2C_TRACE
+static void amebad_i2c_traceclear(FAR struct amebad_i2c_priv_s *priv)
+{
+	struct amebad_trace_s *trace = &priv->trace[priv->tndx];
+
+	trace->status = 0;			/* I2C 32-bit SR2|SR1 status */
+	trace->count = 0;			/* Interrupt count when status change */
+	trace->event = I2CEVENT_NONE;	/* Last event that occurred with this status */
+	trace->parm = 0;			/* Parameter associated with the event */
+	trace->time = 0;			/* Time of first status or event */
+}
+
+static void amebad_i2c_tracereset(FAR struct amebad_i2c_priv_s *priv)
+{
+	/* Reset the trace info for a new data collection */
+
+	priv->tndx = 0;
+	priv->start_time = clock_systimer();
+	amebad_i2c_traceclear(priv);
+}
+
+static void amebad_i2c_tracenew(FAR struct amebad_i2c_priv_s *priv, uint32_t status)
+{
+	struct amebad_trace_s *trace = &priv->trace[priv->tndx];
+
+	/* Is the current entry uninitialized?  Has the status changed? */
+
+	if (trace->count == 0 || status != trace->status) {
+		/* Yes.. Was it the status changed?  */
+
+		if (trace->count != 0) {
+			/* Yes.. bump up the trace index (unless we are out of trace entries) */
+
+			if (priv->tndx >= (CONFIG_I2C_NTRACE - 1)) {
+				i2cerr("ERROR: Trace table overflow\n");
+				return;
+			}
+
+			priv->tndx++;
+			trace = &priv->trace[priv->tndx];
+		}
+
+		/* Initialize the new trace entry */
+
+		amebad_i2c_traceclear(priv);
+		trace->status = status;
+		trace->count = 1;
+		trace->time = clock_systimer();
+	} else {
+		/* Just increment the count of times that we have seen this status */
+
+		trace->count++;
+	}
+}
+
+static void amebad_i2c_traceevent(FAR struct amebad_i2c_priv_s *priv, enum amebad_trace_e event, uint32_t parm)
+{
+	struct amebad_trace_s *trace;
+
+	if (event != I2CEVENT_NONE) {
+		trace = &priv->trace[priv->tndx];
+
+		/* Initialize the new trace entry */
+
+		trace->event = event;
+		trace->parm = parm;
+
+		/* Bump up the trace index (unless we are out of trace entries) */
+
+		if (priv->tndx >= (CONFIG_I2C_NTRACE - 1)) {
+			i2cerr("ERROR: Trace table overflow\n");
+			return;
+		}
+
+		priv->tndx++;
+		amebad_i2c_traceclear(priv);
+	}
+}
+
+static void amebad_i2c_tracedump(FAR struct amebad_i2c_priv_s *priv)
+{
+	struct amebad_trace_s *trace;
+	int i;
+
+	syslog(LOG_DEBUG, "Elapsed time: %ld\n", (long)(clock_systimer() - priv->start_time));
+
+	for (i = 0; i <= priv->tndx; i++) {
+		trace = &priv->trace[i];
+		syslog(LOG_DEBUG, "%2d. STATUS: %08x COUNT: %3d EVENT: %s(%2d) PARM: %08x TIME: %d\n",
+		       i + 1, trace->status, trace->count, g_trace_names[trace->event], trace->event,
+		       trace->parm, trace->time - priv->start_time);
+	}
+}
+#endif							/* CONFIG_I2C_TRACE */
+
+/************************************************************************************
+ * Name: amebad_i2c_setclock
+ *
+ * Description:
+ *   Set the I2C clock
+ *
+ ************************************************************************************/
+
+static void amebad_i2c_setclock(FAR struct amebad_i2c_priv_s *priv, uint32_t frequency)
+{
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_sendstart
+ *
+ * Description:
+ *   Send the START conditions/force Master mode
+ *
+ ************************************************************************************/
+
+static inline void amebad_i2c_sendstart(FAR struct amebad_i2c_priv_s *priv, uint8_t address)
+{
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_sendstop
+ *
+ * Description:
+ *   Send the STOP conditions
+ *
+ ************************************************************************************/
+
+static inline void amebad_i2c_sendstop(FAR struct amebad_i2c_priv_s *priv)
+{
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_getstatus
+ *
+ * Description:
+ *   Get 32-bit status
+ *
+ ************************************************************************************/
+
+static inline uint32_t amebad_i2c_getstatus(FAR struct amebad_i2c_priv_s *priv)
+{
+	return 0;
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_isr_process
+ *
+ * Description:
+ *  Common Interrupt Service Routine
+ *
+ ************************************************************************************/
+
+static int amebad_i2c_isr_process(struct amebad_i2c_priv_s *priv)
+{
+	int ret = 0;
+
+	struct i2c_msg_s *w_msgv = priv->msgv;
+#ifdef CONFIG_I2C_WRITEREAD
+	struct i2c_msg_s *r_msgv = ++priv->msgv;
+	uint8_t read_restart;
+	uint8_t write_restart;
+
+	if ((w_msgv->flags & I2C_M_READ) == 0) {
+
+		i2cinfo("i2c writing");
+#ifdef CONFIG_I2C_SLAVE
+
+		i2c_slave_read(priv->i2c_object, &read_restart, 1);
+		i2c_slave_set_for_rd_req(priv->i2c_object, 1);
+		ret = i2c_slave_write(priv->i2c_object, w_msgv->buffer, w_msgv->length);
+#else
+		ret = rtk_i2c_write(priv->i2c_object, w_msgv->addr, &write_restart, 1, 0);
+		ret = rtk_i2c_write(priv->i2c_object, w_msgv->addr, w_msgv->buffer, w_msgv->length, 1);
+#endif
+        }
+	if ((r_msgv->flags & I2C_M_READ) != 0) {
+
+		i2cinfo("i2c reading");
+#ifdef CONFIG_I2C_SLAVE
+
+		ret = i2c_slave_read(priv->i2c_object, r_msgv->buffer, r_msgv->length);
+#else
+		rtk_i2c_write(priv->i2c_object, r_msgv->addr, &write_restart, 1, 0);
+		ret = rtk_i2c_read(priv->i2c_object, r_msgv->addr, r_msgv->buffer, r_msgv->length, 1);
+#endif
+	}
+
+#else /* CONFIG_I2C_WRITEREAD */
+
+	if ((w_msgv->flags & I2C_M_READ) == 0) {
+
+		i2cinfo("i2c writing");
+#ifdef CONFIG_I2C_SLAVE
+
+		i2c_slave_set_for_rd_req(priv->i2c_object, 1);
+		ret = i2c_slave_write(priv->i2c_object, w_msgv->buffer, w_msgv->length);
+#else
+		ret = rtk_i2c_write(priv->i2c_object, priv->msgv->addr, w_msgv->buffer, w_msgv->length, 1);
+#endif
+	}
+	else if ((w_msgv->flags & I2C_M_READ) != 0) {
+
+		i2cinfo("i2c reading");
+#ifdef CONFIG_I2C_SLAVE
+
+		ret = i2c_slave_read(priv->i2c_object, w_msgv->buffer, w_msgv->length);
+#else
+		ret = rtk_i2c_read(priv->i2c_object, priv->msgv->addr, w_msgv->buffer, w_msgv->length, 1);
+#endif
+	}
+
+#endif  /* #ifdef CONFIG_I2C_WRITEREAD */
+
+	priv->intstate = INTSTATE_DONE;
+
+	return ret;
+
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_isr
+ *
+ * Description:
+ *   Common I2C interrupt service routine
+ *
+ ************************************************************************************/
+
+#ifndef CONFIG_I2C_POLLED
+static int amebad_i2c_isr(int irq, void *context, FAR void *arg)
+{
+	struct amebad_i2c_priv_s *priv = (struct amebad_i2c_priv_s *)arg;
+
+	DEBUGASSERT(priv != NULL);
+	return amebad_i2c_isr_process(priv);
+}
+#endif
+
+/************************************************************************************
+ * Name: amebad_i2c_init
+ *
+ * Description:
+ *   Setup the I2C hardware, ready for operation with defaults
+ *
+ ************************************************************************************/
+
+static int amebad_i2c_init(FAR struct amebad_i2c_priv_s *priv)
+{
+	/* Power-up and configure GPIOs */
+	DEBUGASSERT(priv);
+	DEBUGASSERT(!priv->i2c_object);
+	priv->i2c_object = (i2c_t *)kmm_malloc(sizeof(i2c_t));
+	DEBUGASSERT(priv->i2c_object);
+	i2c_init(priv->i2c_object, priv->config->sda_pin, priv->config->scl_pin);
+
+#ifdef CONFIG_I2C_WRITEREAD
+	i2c_restart_enable(priv->i2c_object);
+#endif
+#ifdef CONFIG_I2C_SLAVE
+	i2c_slave_mode(priv->i2c_object, 1);
+#endif
+#ifndef CONFIG_I2C_POLLED
+	irq_attach(priv->config->irq, amebad_i2c_isr, priv);
+	up_enable_irq(priv->config->irq);
+#endif
+
+	return OK;
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_deinit
+ *
+ * Description:
+ *   Shutdown the I2C hardware
+ *
+ ************************************************************************************/
+
+static int amebad_i2c_deinit(FAR struct amebad_i2c_priv_s *priv)
+{
+
+	DEBUGASSERT(priv);
+	DEBUGASSERT(priv->i2c_object);
+
+#ifndef CONFIG_I2C_POLLED
+	up_disable_irq(priv->config->irq);
+	irq_detach(priv->config->irq);
+#endif
+
+	kmm_free(priv->i2c_object);
+	priv->i2c_object = NULL;
+
+	return OK;
+}
+
+/************************************************************************************
+ * Device Driver Operations
+ ************************************************************************************/
+/************************************************************************************
+ * Name: amebad_i2c_setfrequency
+ *
+ * Description:
+ *   Set the I2C frequency
+ *
+ ************************************************************************************/
+static uint32_t amebad_i2c_setfrequency(FAR struct i2c_dev_s *dev, uint32_t frequency)
+{
+	FAR struct amebad_i2c_priv_s *priv = (struct amebad_i2c_priv_s *)dev;
+
+	amebad_i2c_sem_wait(priv);
+
+	((struct amebad_i2c_priv_s *)dev)->frequency = frequency;
+	i2c_frequency(priv->i2c_object, frequency);
+
+	amebad_i2c_sem_post(priv);
+	return ((struct amebad_i2c_priv_s *)dev)->frequency;
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_setaddress
+ *
+ * Description:
+ *   Set the I2C slave address
+ *
+ ************************************************************************************/
+
+static int amebad_i2c_setaddress(FAR struct i2c_dev_s *dev, int addr, int nbits)
+{
+	FAR struct amebad_i2c_priv_s *priv = (struct amebad_i2c_priv_s *)dev;
+
+	amebad_i2c_sem_wait(priv);
+
+	((struct amebad_i2c_priv_s *)dev)->address = addr;
+	((struct amebad_i2c_priv_s *)dev)->flags = (nbits == 10) ? I2C_M_TEN : 0;
+
+#ifdef CONFIG_I2C_SLAVE
+	i2c_slave_address(priv->i2c_object, priv->i2c_object->i2c_idx, addr, 0xFF);
+#endif
+
+	amebad_i2c_sem_post(priv);
+	return OK;
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_process
+ *
+ * Description:
+ *   Process I2C data
+ *
+ ************************************************************************************/
+
+static int amebad_i2c_process(FAR struct i2c_dev_s *dev, FAR struct i2c_msg_s *msgs, int count)
+{
+	FAR struct amebad_i2c_priv_s *priv = (struct amebad_i2c_priv_s *)dev;
+
+	priv->msgv = msgs;
+	priv->msgc = count;
+
+	int ret = 0;
+	ret = amebad_i2c_sem_waitdone(priv);
+
+	amebad_i2c_sem_post(priv);
+	return ret;
+
+}
+
+
+/************************************************************************************
+ * Name: amebad_i2c_write
+ *
+ * Description:
+ *   Write I2C data
+ *
+ ************************************************************************************/
+
+static int amebad_i2c_write(FAR struct i2c_dev_s *dev, const uint8_t *buffer, int buflen)
+{
+	FAR struct amebad_i2c_priv_s *priv = (struct amebad_i2c_priv_s *)dev;
+
+	amebad_i2c_sem_wait(priv);	/* ensure that address or flags don't change meanwhile */
+
+	struct i2c_msg_s msgv = {
+		.addr = priv->address,
+		.flags = priv->flags,
+		.buffer = (uint8_t *)buffer,
+		.length = buflen
+	};
+
+	return amebad_i2c_process(dev, &msgv, 1);
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_read
+ *
+ * Description:
+ *   Read I2C data
+ *
+ ************************************************************************************/
+
+static int amebad_i2c_read(FAR struct i2c_dev_s *dev, uint8_t *buffer, int buflen)
+{
+        FAR struct amebad_i2c_priv_s *priv = (struct amebad_i2c_priv_s *)dev;
+
+        amebad_i2c_sem_wait(priv);     /* ensure that address or flags don't change meanwhile */
+
+        struct i2c_msg_s msgv = {
+                .addr = priv->address,
+                .flags = priv->flags | I2C_M_READ,
+                .buffer = (uint8_t *)buffer,
+                .length = buflen
+        };
+
+        return amebad_i2c_process(dev, &msgv, 1);
+}
+
+/************************************************************************************
+ * Name: amebad_i2c_writeread
+ *
+ * Description:
+ *  Read then write I2C data
+ *
+ ************************************************************************************/
+
+#ifdef CONFIG_I2C_WRITEREAD
+static int amebad_i2c_writeread(FAR struct i2c_dev_s *dev, const uint8_t *wbuffer, int wbuflen, uint8_t *buffer, int buflen)
+{
+	FAR struct amebad_i2c_priv_s *priv = (struct amebad_i2c_priv_s *)dev;
+
+	amebad_i2c_sem_wait(priv);	/* Ensure that address or flags don't change meanwhile */
+
+        struct i2c_msg_s msgv[2] = {
+		{
+			.addr = priv->address,
+			.flags = priv->flags,
+			.buffer = (uint8_t *)wbuffer,
+			.length = wbuflen
+		},
+		{
+			.addr = priv->address,
+			.flags = priv->flags | ((buflen > 0) ? I2C_M_READ : I2C_M_NORESTART),
+			.buffer = (uint8_t *)buffer,
+			.length = (buflen > 0) ? buflen : -buflen
+		}
+        };
+
+        return amebad_i2c_process(dev, msgv, 2);
+}
+#endif
+
+#ifdef CONFIG_I2C_TRANSFER
+/************************************************************************************
+ * Name: amebad_i2c_transfer
+ *
+ * Description:
+ *   Generic I2C transfer function
+ *
+ ************************************************************************************/
+
+static int amebad_i2c_transfer(FAR struct i2c_dev_s *dev, FAR struct i2c_msg_s *msgs, int count)
+{
+	FAR struct amebad_i2c_priv_s *priv = (struct amebad_i2c_priv_s *)dev;
+
+	amebad_i2c_sem_wait(priv);
+
+	return amebad_i2c_process(dev, msgs, count);
+}
+#endif
+
+/************************************************************************************
+ * Public Functions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Name: up_i2cinitialize
+ *
+ * Description:
+ *   Initialize one I2C bus
+ *
+ ************************************************************************************/
+
+FAR struct i2c_dev_s *up_i2cinitialize(int port)
+{
+	struct amebad_i2c_priv_s *priv = NULL;
+	irqstate_t flags;
+
+	/* Get I2C private structure */
+
+	priv = (struct amebad_i2c_priv_s *)&amebad_i2c1_priv;
+	/* Initialize private data for the first time, increment reference count,
+	 * power-up hardware and configure GPIOs.
+	 */
+
+	flags = irqsave();
+
+	if ((volatile int)priv->refs++ == 0) {
+		amebad_i2c_sem_init(priv);
+		amebad_i2c_init(priv);
+	}
+
+	irqrestore(flags);
+
+	return (struct i2c_dev_s *)priv;
+}
+
+/************************************************************************************
+ * Name: up_i2cuninitialize
+ *
+ * Description:
+ *   Uninitialize an I2C bus
+ *
+ ************************************************************************************/
+
+int up_i2cuninitialize(FAR struct i2c_dev_s *dev)
+{
+	FAR struct amebad_i2c_priv_s *priv = (struct amebad_i2c_priv_s *)dev;
+	irqstate_t flags;
+
+	DEBUGASSERT(dev);
+
+	/* Decrement reference count and check for underflow */
+
+	if (priv->refs == 0) {
+		return ERROR;
+	}
+
+	flags = irqsave();
+
+	if (--priv->refs > 0) {
+		irqrestore(flags);
+		return OK;
+	}
+
+	irqrestore(flags);
+
+	/* Disable power and other HW resource (GPIO's) */
+
+	amebad_i2c_deinit(priv);
+
+	/* Release unused resources */
+
+	amebad_i2c_sem_destroy(priv);
+	return OK;
+}
+
+/************************************************************************************
+ * Name: up_i2creset
+ *
+ * Description:
+ *   Reset an I2C bus
+ *
+ ************************************************************************************/
+
+#ifdef CONFIG_I2C_RESET
+int up_i2creset(FAR struct i2c_dev_s *dev)
+{
+	FAR struct amebad_i2c_priv_s *priv = (FAR struct amebad_i2c_priv_s *)dev;
+
+	i2c_reset(priv->i2c_object);
+
+	return 0;
+}
+#endif							/* CONFIG_I2C_RESET */
diff --git a/os/arch/arm/src/amebad/amebad_i2c.h b/os/arch/arm/src/amebad/amebad_i2c.h
new file mode 100644
index 0000000000..a36f2d8e3a
--- /dev/null
+++ b/os/arch/arm/src/amebad/amebad_i2c.h
@@ -0,0 +1,36 @@
+/****************************************************************************
+ *
+ * Copyright 2021 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifndef __ARCH_ARM_SRC_AMEBAD_I2C_H
+#define __ARCH_ARM_SRC_AMEBAD_I2C_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <tinyara/i2c.h>
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Public Function Prototypes
+ ****************************************************************************/
+
+#endif							/* __ARCH_ARM_SRC_AMEBAD_I2C_H */
diff --git a/os/arch/arm/src/amebad/amebad_i2s.c b/os/arch/arm/src/amebad/amebad_i2s.c
new file mode 100644
index 0000000000..264f09d817
--- /dev/null
+++ b/os/arch/arm/src/amebad/amebad_i2s.c
@@ -0,0 +1,1815 @@
+/****************************************************************************
+ *
+ * Copyright 2021 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <tinyara/config.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <semaphore.h>
+#include <errno.h>
+#include <assert.h>
+#include <queue.h>
+#include <debug.h>
+
+#include <tinyara/irq.h>
+#include <tinyara/arch.h>
+#include <tinyara/kmalloc.h>
+#include <tinyara/wdog.h>
+#include <tinyara/wqueue.h>
+#include <tinyara/audio/audio.h>
+#include <tinyara/audio/i2s.h>
+
+#include "irq/irq.h"
+
+#include <arch/board/board.h>
+#include "amebad_i2s.h"
+
+#include "mbed/targets/hal/rtl8721d/PinNames.h"
+#include "mbed/hal_ext/i2s_api.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+//#ifndef CONFIG_SCHED_WORKQUEUE
+//#error Work queue support is required (CONFIG_SCHED_WORKQUEUE)
+//#endif
+
+#ifdef CONFIG_AUDIO
+//#ifndef CONFIG_AUDIO
+//#error CONFIG_AUDIO required by this driver
+//#endif
+
+#ifndef CONFIG_AMEBAD_I2S_MAXINFLIGHT
+#define CONFIG_AMEBAD_I2S_MAXINFLIGHT 32
+#endif
+
+/* Assume no RX/TX support until we learn better */
+#undef I2S_HAVE_RX
+#undef I2S_HAVE_TX
+
+#if defined(CONFIG_AMEBAD_I2S)
+
+/* Check for I2S RX support */
+#if defined(CONFIG_AMEBAD_I2S_RX)
+#define I2S_HAVE_RX     1
+#endif
+
+/* Check for I2S TX support */
+#if defined(CONFIG_AMEBAD_I2S_TX)
+#define I2S_HAVE_TX     1
+#endif
+
+#ifndef CONFIG_AMEBAD_I2S_DATALEN
+#define CONFIG_AMEBAD_I2S_DATALEN        (I2S_BITS_PER_SAMPLE_16BIT)
+#endif
+
+#ifndef CONFIG_AMEBAD_I2S_SAMPLERATE
+#define CONFIG_AMEBAD_I2S_SAMPLERATE     (SR_44p1KHZ)
+#endif
+
+#endif
+
+#ifdef CONFIG_DEBUG
+#define CONFIG_DEBUG_FEATURES
+#endif
+
+#define DEBUG_I2S_DRIVER    0
+
+#undef i2serr
+#undef i2sinfo
+#if defined(DEBUG_I2S_DRIVER) && (0 < DEBUG_I2S_DRIVER)
+#define i2sinfo(format, ...)   printf(format, ##__VA_ARGS__)
+#define i2serr(format, ...)   printf(format, ##__VA_ARGS__)
+#else
+#define i2sinfo(format, ...)
+#endif
+#define i2serr(format, ...)   printf(format, ##__VA_ARGS__)
+
+#if defined(I2S_HAVE_RX) || defined(I2S_HAVE_TX)
+
+#ifndef MIN
+#define MIN(a,b) a < b ? a : b
+#endif
+
+#define OVER_SAMPLE_RATE (384U)
+
+#define I2S_DMA_PAGE_SIZE	768   // 2 ~ 4096
+#define I2S_DMA_PAGE_NUM    4   // Vaild number is 2~4
+
+/* I2S buffer container */
+
+struct amebad_buffer_s {
+	struct amebad_buffer_s *flink;	/* Supports a singly linked list */
+	i2s_callback_t callback;	/* Function to call when the transfer completes */
+	uint32_t timeout;		/* The timeout value to use with DMA transfers */
+	void *arg;			/* The argument to be returned with the callback */
+	struct ap_buffer_s *apb;	/* The audio buffer */
+	int result;			/* The result of the transfer */
+};
+
+/* This structure describes the state of one receiver or transmitter transport */
+
+struct amebad_transport_s {
+	WDOG_ID dog;				/* Watchdog that handles DMA timeouts */
+	sq_queue_t pend;			/* A queue of pending transfers */
+	sq_queue_t act;				/* A queue of active transfers */
+	sq_queue_t done;			/* A queue of completed transfers */
+	struct work_s work;			/* Supports worker thread operations */
+	int error_state;			/* Channel error state, 0 - OK*/
+};
+
+/* I2S configuration parameters for i2s_param_config function */
+typedef struct {
+
+	int sample_rate;			/*!< I2S sample rate */
+	i2s_bits_per_sample_t bits_per_sample;	/*!< I2S bits per sample */
+
+	uint8_t channel_num;
+	uint8_t direction;
+
+} i2s_config_t;
+
+/* The state of the one I2S peripheral */
+
+struct amebad_i2s_s {
+	struct i2s_dev_s dev;           /* Externally visible I2S interface, must the first element!! */
+
+	i2s_t i2s_object;
+	uint32_t i2s_sclk_pin;
+	uint32_t i2s_ws_pin;
+	uint32_t i2s_sd_tx_pin;
+	uint32_t i2s_sd_rx_pin;
+	uint32_t i2s_mck_pin;
+
+	uint8_t* i2s_tx_buf;
+	uint8_t* i2s_rx_buf;
+
+	i2s_irq_handler rx_isr_handler;
+	i2s_irq_handler tx_isr_handler;
+
+	uint8_t i2s_num;             /* I2S controller register base address */
+
+	i2s_err_cb_t err_cb;            /* registered error callback function */
+	void *err_cb_arg;               /* argiment to return with err cb call */
+
+	sem_t exclsem;                  /* Assures mutually exclusive acess to I2S */
+
+	uint8_t rxenab:1;               /* True: RX transfers enabled */
+	uint8_t txenab:1;               /* True: TX transfers enabled */
+
+	int sample_rate;                /*!< I2S sample rate */
+	int channel_num;                /*!< Number of channels */
+	int bits_per_sample;            /*!< Bits per sample */
+
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	struct amebad_transport_s rx;		/* RX transport state */
+#endif
+
+	sem_t bufsem_tx;			/* Buffer wait semaphore */
+	struct amebad_buffer_s *freelist_tx;	/* A list a free buffer containers */
+	struct amebad_buffer_s containers_tx[I2S_DMA_PAGE_NUM];
+
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	struct amebad_transport_s tx;		/* TX primary transport state */
+#endif
+
+	sem_t bufsem_rx;			/* Buffer wait semaphore */
+	struct amebad_buffer_s *freelist_rx;	/* A list a free buffer containers */
+	struct amebad_buffer_s containers_rx[I2S_DMA_PAGE_NUM];
+
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+/* Register helpers */
+#define CONFIG_AMEBAD_I2S_DUMPBUFFERS   0
+
+#if defined(CONFIG_AMEBAD_I2S_DUMPBUFFERS) && (0 < CONFIG_AMEBAD_I2S_DUMPBUFFERS)
+#define       i2s_init_buffer(b, s)   memset(b, 0x55, s);
+#define       i2s_dump_buffer(m, b, s) lib_dumpbuffer(m, b, s)
+#else
+#define       i2s_init_buffer(b, s)
+#define       i2s_dump_buffer(m, b, s)
+#endif
+
+/* Semaphore helpers */
+static void i2s_exclsem_take(struct amebad_i2s_s *priv);
+#define i2s_exclsem_give(priv) sem_post(&priv->exclsem)
+
+/* Buffer container helpers */
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+static void i2s_rxdma_callback(struct amebad_i2s_s* priv, int result);
+static void i2s_rxdma_timeout(int argc, uint32_t arg);
+static int i2s_rxdma_prep(struct amebad_i2s_s *priv, struct amebad_buffer_s *bfcontainer);
+static int i2s_rx_start(struct amebad_i2s_s *priv);
+static void i2s_rx_worker(void *arg);
+static void i2s_rx_schedule(struct amebad_i2s_s *priv, int result);
+
+static void i2s_bufsem_rx_take(struct amebad_i2s_s *priv);
+#define i2s_bufsem_rx_give(priv) sem_post(&priv->bufsem_rx)
+
+static struct amebad_buffer_s *i2s_buf_rx_allocate(struct amebad_i2s_s *priv);
+static void i2s_buf_rx_free(struct amebad_i2s_s *priv, struct amebad_buffer_s *bfcontainer);
+static void i2s_buf_rx_initialize(struct amebad_i2s_s *priv);
+
+#endif
+
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+static void i2s_txdma_callback(struct amebad_i2s_s* priv, int result);
+static void i2s_txdma_timeout(int argc, uint32_t arg);
+static int i2s_txdma_prep(struct amebad_i2s_s *priv, struct amebad_buffer_s *bfcontainer);
+static int i2s_tx_start(struct amebad_i2s_s *priv);
+static void i2s_tx_worker(void *arg);
+static void i2s_tx_schedule(struct amebad_i2s_s *priv, int result);
+
+static void i2s_bufsem_tx_take(struct amebad_i2s_s *priv);
+#define i2s_bufsem_tx_give(priv) sem_post(&priv->bufsem_tx)
+
+static struct amebad_buffer_s *i2s_buf_tx_allocate(struct amebad_i2s_s *priv);
+static void i2s_buf_tx_free(struct amebad_i2s_s *priv, struct amebad_buffer_s *bfcontainer);
+static void i2s_buf_tx_initialize(struct amebad_i2s_s *priv);
+
+#endif
+
+/* I2S methods (and close friends) */
+
+static uint32_t i2s_rxdatawidth(struct i2s_dev_s *dev, int bits);
+
+static uint32_t i2s_samplerate(struct i2s_dev_s *dev, uint32_t rate);
+
+static uint32_t i2s_txdatawidth(struct i2s_dev_s *dev, int bits);
+
+static int i2s_stop_transfer(struct i2s_dev_s *dev, i2s_ch_dir_t dir);
+
+static int i2s_stop(struct i2s_dev_s *dev, i2s_ch_dir_t dir);
+static int i2s_pause(struct i2s_dev_s *dev, i2s_ch_dir_t dir);
+static int i2s_resume(struct i2s_dev_s *dev, i2s_ch_dir_t dir);
+
+static int i2s_receive(struct i2s_dev_s *dev, struct ap_buffer_s *apb, i2s_callback_t callback, void *arg, uint32_t timeout);
+static int i2s_send(struct i2s_dev_s *dev, struct ap_buffer_s *apb, i2s_callback_t callback, void *arg, uint32_t timeout);
+
+static int i2s_err_cb_register(struct i2s_dev_s *dev, i2s_err_cb_t cb, void *arg);
+
+/****************************************************************************
+* External functions
+****************************************************************************/
+
+static const i2s_config_t i2s_default_config = {
+
+	.sample_rate = CONFIG_AMEBAD_I2S_SAMPLERATE,
+	.bits_per_sample = CONFIG_AMEBAD_I2S_DATALEN,
+
+	.channel_num = CH_MONO,
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	.direction = I2S_DIR_TX,
+#endif
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	.direction = I2S_DIR_RX,
+#endif
+};
+
+/* I2S device operations */
+static const struct i2s_ops_s g_i2sops = {
+	/* Receiver methods */
+
+	.i2s_rxsamplerate = i2s_samplerate,
+	.i2s_rxdatawidth = i2s_rxdatawidth,
+	.i2s_receive = i2s_receive,
+
+	/* Transmitter methods */
+
+	.i2s_txsamplerate = i2s_samplerate,
+	.i2s_txdatawidth = i2s_txdatawidth,
+	.i2s_send = i2s_send,
+
+	.i2s_stop = i2s_stop,
+	.i2s_pause = i2s_pause,
+	.i2s_resume = i2s_resume,
+	.i2s_err_cb_register = i2s_err_cb_register,
+};
+
+static struct amebad_i2s_s *g_i2sdevice[I2S_NUM_MAX] = {NULL};
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+
+/****************************************************************************
+ * Name: i2s_txdma_callback
+ *
+ * Description:
+ *   This callback function is invoked at the completion of the I2S TX DMA.
+ *
+ * Input Parameters:
+ *   priv - amebad private i2s data
+ *   result - The result of the DMA transfer
+ *
+ * Returned Value:
+ *   None
+ *
+ ****************************************************************************/
+
+static void i2s_txdma_callback(struct amebad_i2s_s* priv, int result)
+{
+	DEBUGASSERT(priv != NULL);
+
+	/* Cancel the watchdog timeout */
+
+	(void)wd_cancel(priv->tx.dog);
+
+
+	/* Then schedule completion of the transfer to occur on the worker thread */
+
+	i2s_tx_schedule(priv, result);
+}
+
+static void i2s_txdma_timeout(int argc, uint32_t arg)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)arg;
+	DEBUGASSERT(priv != NULL);
+
+	/* Then schedule completion of the transfer to occur on the worker thread.
+	 * Set the result with -ETIMEDOUT.
+	 */
+	i2s_tx_schedule(priv, -ETIMEDOUT);
+}
+
+static int i2s_txdma_prep(struct amebad_i2s_s *priv, struct amebad_buffer_s *bfcontainer)
+{
+	struct ap_buffer_s *apb;
+
+	apb = bfcontainer->apb;
+
+	priv->i2s_tx_buf = (void *)&(apb->samp[apb->curbyte]);
+	i2s_set_dma_buffer(&priv->i2s_object, (char*)priv->i2s_tx_buf, NULL, I2S_DMA_PAGE_NUM, I2S_DMA_PAGE_SIZE);
+
+	return 0;
+}
+
+static int i2s_tx_start(struct amebad_i2s_s *priv)
+{
+	struct amebad_buffer_s *bfcontainer = NULL;
+	int ret;
+	irqstate_t flags;
+	int* ptx_buf;
+	int pg_idx;
+
+	struct ap_buffer_s *apb;
+	apb = bfcontainer->apb;
+
+	/* Check if the DMA is IDLE */
+	if (!sq_empty(&priv->tx.act)) {
+		i2sinfo("[TX] actived!\n");
+		return OK;
+	}
+
+	/* If there are no pending transfer, then bail returning success */
+	if (sq_empty(&priv->tx.pend)) {
+		i2sinfo("[TX] empty!\n");
+		return OK;
+	}
+
+	flags = irqsave();
+
+	/* Remove the pending TX transfer at the head of the TX pending queue. */
+	bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->tx.pend);
+	if (NULL != bfcontainer && NULL != bfcontainer->apb) {
+
+		/* Add the container to the list of active DMAs */
+		sq_addlast((sq_entry_t *)bfcontainer, &priv->tx.act);
+
+		i2s_set_direction(&priv->i2s_object, I2S_DIR_TX);
+
+		/* send I2S_DMA_PAGE_NUM page, after that the txdma callback will be called in the tx irq handler */
+		for (pg_idx = 0; pg_idx < I2S_DMA_PAGE_NUM; ++pg_idx) {
+
+			ptx_buf = i2s_get_tx_page(&priv->i2s_object);
+			i2s_send_page(&priv->i2s_object, (uint32_t*)ptx_buf);
+			apb->curbyte += (I2S_DMA_PAGE_SIZE/sizeof(short));
+			if(apb->curbyte >= apb->nmaxbytes*(priv->i2s_object.channel_num == CH_MONO?1:2))
+				apb->curbyte = 0;
+		}
+	}
+
+	irqrestore(flags);
+
+	/* Start a watchdog to catch DMA timeouts */
+	if (bfcontainer->timeout > 0) {
+		ret = wd_start(priv->tx.dog, bfcontainer->timeout, (wdentry_t)i2s_txdma_timeout, 1, (uint32_t)priv);
+
+		/* Check if we have successfully started the watchdog timer.  Note
+		 * that we do nothing in the case of failure to start the timer.  We
+		 * are already committed to the DMA anyway.  Let's just hope that the
+		 * DMA does not hang.
+		 */
+		if (ret < 0) {
+			i2serr("ERROR: wd_start failed: %d\n", errno);
+		}
+	}
+
+	return OK;
+}
+
+static void i2s_tx_worker(void *arg)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)arg;
+	struct amebad_buffer_s *bfcontainer;
+	irqstate_t flags;
+
+	DEBUGASSERT(priv);
+
+	/* When the transfer was started, the active buffer containers were removed
+	 * from the tx.pend queue and saved in the tx.act queue.  We get here when the
+	 * DMA is finished... either successfully, with a DMA error, or with a DMA
+	 * timeout.
+	 *
+	 * In any case, the buffer containers in tx.act will be moved to the end
+	 * of the tx.done queue and tx.act will be emptied before this worker is
+	 * started.
+	 */
+
+	i2sinfo("tx.act.head=%p tx.done.head=%p\n", priv->tx.act.head, priv->tx.done.head);
+
+
+	/* Process each buffer in the tx.done queue */
+	while (sq_peek(&priv->tx.done) != NULL) {
+		/* Remove the buffer container from the tx.done queue.  NOTE that
+		 * interrupts must be enabled to do this because the tx.done queue is
+		 * also modified from the interrupt level.
+		 */
+
+		flags = irqsave();
+		bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->tx.done);
+		irqrestore(flags);
+
+		/* Perform the TX transfer done callback */
+
+		DEBUGASSERT(bfcontainer && bfcontainer->callback);
+		bfcontainer->callback(&priv->dev, bfcontainer->apb, bfcontainer->arg, bfcontainer->result);
+
+		/* Release our reference on the audio buffer.  This may very likely
+		 * cause the audio buffer to be freed.
+		 */
+
+		apb_free(bfcontainer->apb);
+
+		/* And release the buffer container */
+
+		i2s_buf_tx_free(priv, bfcontainer);
+	}
+
+}
+
+static void i2s_tx_schedule(struct amebad_i2s_s *priv, int result)
+{
+	struct amebad_buffer_s *bfcontainer;
+	int ret;
+
+	/* Upon entry, the transfer(s) that just completed are the ones in the
+	 * priv->tx.act queue.  NOTE: In certain conditions, this function may
+	 * be called an additional time, hence, we can't assert this to be true.
+	 * For example, in the case of a timeout, this function will be called by
+	 * both indirectly via the amebad_dmastop() logic and directly via the
+	 * i2s_txdma_timeout() logic.
+	 */
+
+	/* Move all entries from the tx.act queue to the tx.done queue */
+
+	if (!sq_empty(&priv->tx.act)) {
+		/* Remove the next buffer container from the tx.act list */
+
+		bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->tx.act);
+
+		/* Report the result of the transfer */
+
+		bfcontainer->result = result;
+
+		/* Add the completed buffer container to the tail of the tx.done queue */
+
+		sq_addlast((sq_entry_t *) bfcontainer, &priv->tx.done);
+	}
+
+
+	if (!sq_empty(&priv->tx.pend)) {
+		/* Remove the next buffer container from the tx.pend list */
+		bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->tx.pend);
+
+		/* Add the completed buffer container to the tail of the tx.act queue */
+		sq_addlast((sq_entry_t *) bfcontainer, &priv->tx.act);
+
+	}
+
+	/* If the worker has completed running, then reschedule the working thread.
+	 * REVISIT:  There may be a race condition here.  So we do nothing if the
+	 * worker is not available.
+	 */
+
+	if (work_available(&priv->tx.work)) {
+		/* Schedule the TX DMA done processing to occur on the worker thread. */
+
+		ret = work_queue(HPWORK, &priv->tx.work, i2s_tx_worker, priv, 0);
+		if (ret != 0) {
+			i2serr("ERROR: Failed to queue TX primary work: %d\n", ret);
+		}
+	}
+}
+#endif
+
+/****************************************************************************
+ * Name: i2s_txdatawidth
+ *
+ * Description:
+ *   Set the I2S TX data width.  The TX bitrate is determined by
+ *   sample_rate * data_width.
+ *
+ * Input Parameters:
+ *   dev   - Device-specific state data
+ *   width - The I2S data with in bits.
+ *
+ * Returned Value:
+ *   Returns the resulting bitrate
+ *
+ ****************************************************************************/
+
+static uint32_t i2s_txdatawidth(struct i2s_dev_s *dev, int bits)
+{
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+
+	/* Support 16, 24, 32 bits */
+	DEBUGASSERT(priv && (bits == I2S_BITS_PER_SAMPLE_16BIT /
+				|| bits == I2S_BITS_PER_SAMPLE_32BIT /
+				|| bits == I2S_BITS_PER_SAMPLE_24BIT));
+
+	priv->bits_per_sample = bits;
+
+	/* amebad 16, 24, 32, bits setting */
+	if (bits == I2S_BITS_PER_SAMPLE_16BIT) priv->i2s_object.word_length = WL_16b;
+	else if (bits == I2S_BITS_PER_SAMPLE_24BIT) priv->i2s_object.word_length = WL_24b;
+	else if (bits == I2S_BITS_PER_SAMPLE_32BIT) priv->i2s_object.word_length = WL_32b;
+
+	return priv->bits_per_sample * priv->sample_rate;
+#endif
+
+	return 0;
+}
+
+/****************************************************************************
+* Name: i2s_send
+*
+* Description:
+*   Send a block of data on I2S.
+*
+* Input Parameters:
+*   dev      - Device-specific state data
+*   apb      - A pointer to the audio buffer from which to send data
+*   callback - A user provided callback function that will be called at
+*              the completion of the transfer.  The callback will be
+*              performed in the context of the worker thread.
+*   arg      - An opaque argument that will be provided to the callback
+*              when the transfer complete
+*   timeout  - The timeout value to use.  The transfer will be canceled
+*              and an ETIMEDOUT error will be reported if this timeout
+*              elapsed without completion of the DMA transfer.  Units
+*              are system clock ticks.  Zero means no timeout.
+*
+* Returned Value:
+*   OK on success; a negated errno value on failure.  NOTE:  This function
+*   only enqueues the transfer and returns immediately.  Success here only
+*   means that the transfer was enqueued correctly.
+*
+*   When the transfer is complete, a 'result' value will be provided as
+*   an argument to the callback function that will indicate if the transfer
+*   failed.
+*
+****************************************************************************/
+
+static int i2s_send(struct i2s_dev_s *dev, struct ap_buffer_s *apb, i2s_callback_t callback, void *arg, uint32_t timeout)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+
+	DEBUGASSERT(priv && apb);
+
+	i2sinfo("[I2S TX] apb=%p nbytes=%d arg=%p samp=%p timeout=%d\n", apb, apb->nbytes - apb->curbyte, apb->samp, arg, timeout);
+
+	i2s_dump_buffer("Sending", &apb->samp[apb->curbyte], apb->nbytes - apb->curbyte);
+
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	struct amebad_buffer_s *bfcontainer;
+	irqstate_t flags;
+	int ret;
+
+	/* Has the TX channel been enabled? */
+	if (!priv->txenab) {
+		i2serr("ERROR: I2S has no transmitter\n");
+		return -EAGAIN;
+	}
+
+	/* Allocate a buffer container in advance */
+
+	bfcontainer = i2s_buf_tx_allocate(priv);
+
+	i2s_exclsem_take(priv);
+	i2sinfo("TX Exclusive Enter\n");
+
+	apb_reference(apb);
+
+	/* Initialize the buffer container structure */
+
+	bfcontainer->callback = (void *)callback;
+	bfcontainer->timeout = timeout;
+	bfcontainer->arg = arg;
+	bfcontainer->apb = apb;
+	bfcontainer->result = -EBUSY;
+
+	/* Prepare DMA microcode */
+	i2s_txdma_prep(priv, bfcontainer);
+
+	flags = irqsave();
+	sq_addlast((sq_entry_t *) bfcontainer, &priv->tx.pend);
+	irqrestore(flags);
+
+	ret = i2s_tx_start(priv);
+
+	i2s_exclsem_give(priv);
+	i2sinfo("TX Exclusive Exit\n");
+
+	return OK;
+
+#else
+	i2serr("ERROR: I2S has no transmitter\n");
+	UNUSED(priv);
+	return -ENOSYS;
+#endif
+}
+
+/*!
+ * @brief Tx interrupt handler.
+ *
+ * @param base pointer.
+ * @param handle Pointer to the sai_handle_t structure.
+ */
+
+void i2s_transfer_tx_handleirq(void *data, char *pbuf)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)data;
+
+	int result = OK;
+	i2s_txdma_callback(priv, result);
+
+}
+
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+
+/****************************************************************************
+ * Name: i2s_rxdma_callback
+ *
+ * Description:
+ *   This callback function is invoked at the completion of the I2S RX DMA.
+ *
+ * Input Parameters:
+ *   priv - amebad i2s private data
+ *   result - The result of the DMA transfer
+ *
+ * Returned Value:
+ *   None
+ *
+ ****************************************************************************/
+
+static void i2s_rxdma_callback(struct amebad_i2s_s* priv, int result)
+{
+	DEBUGASSERT(priv != NULL);
+
+	/* Cancel the watchdog timeout */
+
+	(void)wd_cancel(priv->rx.dog);
+
+
+	/* Then schedule completion of the transfer to occur on the worker thread */
+
+	i2s_rx_schedule(priv, result);
+}
+
+static void i2s_rxdma_timeout(int argc, uint32_t arg)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)arg;
+	DEBUGASSERT(priv != NULL);
+
+	/* Timeout: set the result to -ETIMEDOUT. */
+	i2s_rx_schedule(priv, -ETIMEDOUT);
+}
+
+static int i2s_rxdma_prep(struct amebad_i2s_s *priv, struct amebad_buffer_s *bfcontainer)
+{
+	struct ap_buffer_s *apb;
+
+	apb = bfcontainer->apb;
+
+	/* No data received yet */
+	apb->nbytes = 0;
+	apb->curbyte = 0;
+
+	priv->i2s_rx_buf = apb->samp;
+	i2s_set_dma_buffer(&priv->i2s_object, NULL, (char*)priv->i2s_rx_buf, I2S_DMA_PAGE_NUM, I2S_DMA_PAGE_SIZE);
+
+	return 0;
+}
+
+static int i2s_rx_start(struct amebad_i2s_s *priv)
+{
+	struct amebad_buffer_s *bfcontainer;
+	int ret;
+	irqstate_t flags;
+
+	/* Check if the DMA is IDLE */
+	if (!sq_empty(&priv->rx.act)) {
+		i2sinfo("[RX start] RX active!\n");
+		return OK;
+	}
+
+	/* If there are no pending transfer, then bail returning success */
+	if (sq_empty(&priv->rx.pend)) {
+		i2sinfo("[RX start] RX pend empty!\n");
+		return OK;
+	}
+
+	flags = irqsave();
+	/* Remove the pending RX transfer at the head of the RX pending queue. */
+	bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->rx.pend);
+
+	if (bfcontainer != NULL && NULL != bfcontainer->apb) {
+
+		/* Add the container to the list of active DMAs */
+		sq_addlast((sq_entry_t *)bfcontainer, &priv->rx.act);
+
+		i2s_set_direction(&priv->i2s_object, I2S_DIR_RX);
+		i2s_recv_page(&priv->i2s_object);
+
+	}
+	irqrestore(flags);
+
+	/* Start a watchdog to catch DMA timeouts */
+	if (bfcontainer->timeout > 0) {
+		ret = wd_start(priv->rx.dog, bfcontainer->timeout, (wdentry_t)i2s_rxdma_timeout, 1, (uint32_t)priv);
+
+		/* Check if we have successfully started the watchdog timer.  Note
+		 * that we do nothing in the case of failure to start the timer.  We
+		 * are already committed to the DMA anyway.  Let's just hope that the
+		 * DMA does not hang.
+		 */
+		if (ret < 0) {
+			i2serr("ERROR: wd_start failed: %d\n", errno);
+		}
+	}
+
+	return OK;
+}
+
+static void i2s_rx_worker(void *arg)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)arg;
+	struct ap_buffer_s *apb;
+	struct amebad_buffer_s *bfcontainer;
+	irqstate_t flags;
+
+	DEBUGASSERT(priv);
+
+	/* When the transfer was started, the active buffer containers were removed
+	 * from the rx.pend queue and saved in the rx.act queue.  We get here when the
+	 * DMA is finished... either successfully, with a DMA error, or with a DMA
+	 * timeout.
+	 *
+	 * In any case, the buffer containers in rx.act will be moved to the end
+	 * of the rx.done queue and rx.act queue will be emptied before this worker
+	 * is started.
+	 */
+
+	i2sinfo("rx.act.head=%p rx.done.head=%p\n", priv->rx.act.head, priv->rx.done.head);
+
+
+	/* Process each buffer in the rx.done queue */
+	while (sq_peek(&priv->rx.done) != NULL) {
+		/* Remove the buffer container from the rx.done queue.  NOTE that
+		 * interrupts must be disabled to do this because the rx.done queue is
+		 * also modified from the interrupt level.
+		 */
+
+		flags = irqsave();
+		bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->rx.done);
+		irqrestore(flags);
+
+		/* Perform the RX transfer done callback */
+
+		DEBUGASSERT(bfcontainer && bfcontainer->apb && bfcontainer->callback);
+		apb = bfcontainer->apb;
+
+		/* If the DMA was successful, then update the number of valid bytes in
+		 * the audio buffer.
+		 */
+
+		if (bfcontainer->result == OK) {
+			apb->nbytes = apb->nmaxbytes;
+		}
+
+		i2s_dump_buffer("Received", apb->samp, apb->nbytes);
+
+		/* Perform the RX transfer done callback */
+		bfcontainer->callback(&priv->dev, apb, bfcontainer->arg, bfcontainer->result);
+
+		/* Release our reference on the audio buffer.  This may very likely
+		 * cause the audio buffer to be freed.
+		 */
+		apb_free(apb);
+
+		/* And release the buffer container */
+		i2s_buf_rx_free(priv, bfcontainer);
+	}
+
+}
+
+static void i2s_rx_schedule(struct amebad_i2s_s *priv, int result)
+{
+	struct amebad_buffer_s *bfcontainer;
+	int ret;
+
+	/* Upon entry, the transfer(s) that just completed are the ones in the
+	 * priv->rx.act queue.  NOTE: In certain conditions, this function may
+	 * be called an additional time, hence, we can't assert this to be true.
+	 * For example, in the case of a timeout, this function will be called by
+	 * both indirectly via the amebad_dmastop() logic and directly via the
+	 * i2s_rxdma_timeout() logic.
+	 */
+
+	/* Move first entry from the rx.act queue to the rx.done queue */
+
+	if (!sq_empty(&priv->rx.act)) {
+		/* Remove the next buffer container from the rx.act list */
+
+		bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->rx.act);
+
+		/* Report the result of the transfer */
+
+		bfcontainer->result = result;
+
+		/* Add the completed buffer container to the tail of the rx.done queue */
+
+		sq_addlast((sq_entry_t *) bfcontainer, &priv->rx.done);
+	}
+
+	if (!sq_empty(&priv->rx.pend)) {
+		/* Remove the next buffer container from the tx.pend list */
+		bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->rx.pend);
+
+		/* Add the completed buffer container to the tail of the tx.act queue */
+		sq_addlast((sq_entry_t *) bfcontainer, &priv->rx.act);
+
+	}
+
+
+
+	/* If the worker has completed running, then reschedule the working thread.
+	 * REVISIT:  There may be a race condition here.  So we do nothing is the
+	 * worker is not available.
+	 */
+	if (work_available(&priv->rx.work)) {
+		/* Schedule the TX DMA done processing to occur on the worker thread. */
+
+		ret = work_queue(HPWORK, &priv->rx.work, i2s_rx_worker, priv, 0);
+		if (ret != 0) {
+			i2serr("ERROR: Failed to queue RX work: %d\n", ret);
+		}
+	}
+}
+#endif
+
+/****************************************************************************
+ * Name: i2s_rxdatawidth
+ *
+ * Description:
+ *   Set the I2S RX data width.  The RX bitrate is determined by
+ *   sample_rate * data_width.
+ *
+ * Input Parameters:
+ *   dev   - Device-specific state data
+ *   width - The I2S data with in bits.
+ *
+ * Returned Value:
+ *   Returns the resulting bitrate
+ *
+ ****************************************************************************/
+
+static uint32_t i2s_rxdatawidth(struct i2s_dev_s *dev, int bits)
+{
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+
+	/* Support 16, 24, 32 bits */
+	DEBUGASSERT(priv && (bits == I2S_BITS_PER_SAMPLE_16BIT /
+				|| bits == I2S_BITS_PER_SAMPLE_32BIT /
+				|| bits == I2S_BITS_PER_SAMPLE_24BIT));
+
+	priv->bits_per_sample = bits;
+
+	/* amebad 16, 24, 32, bits setting */
+	if (bits == I2S_BITS_PER_SAMPLE_16BIT) priv->i2s_object.word_length = WL_16b;
+	else if (bits == I2S_BITS_PER_SAMPLE_24BIT) priv->i2s_object.word_length = WL_24b;
+	else if (bits == I2S_BITS_PER_SAMPLE_32BIT) priv->i2s_object.word_length = WL_32b;
+
+	return priv->bits_per_sample * priv->sample_rate;
+#endif
+
+	return 0;
+}
+
+/****************************************************************************
+ * Name: i2s_receive
+ *
+ * Description:
+ *   Receive a block of data from I2S.
+ *
+ * Input Parameters:
+ *   dev      - Device-specific state data
+ *   apb      - A pointer to the audio buffer in which to recieve data
+ *   callback - A user provided callback function that will be called at
+ *              the completion of the transfer.  The callback will be
+ *              performed in the context of the worker thread.
+ *   arg      - An opaque argument that will be provided to the callback
+ *              when the transfer complete
+ *   timeout  - The timeout value to use.  The transfer will be canceled
+ *              and an ETIMEDOUT error will be reported if this timeout
+ *              elapsed without completion of the DMA transfer.  Units
+ *              are system clock ticks.  Zero means no timeout.
+ *
+ * Returned Value:
+ *   OK on success; a negated errno value on failure.  NOTE:  This function
+ *   only enqueues the transfer and returns immediately.  Success here only
+ *   means that the transfer was enqueued correctly.
+ *
+ *   When the transfer is complete, a 'result' value will be provided as
+ *   an argument to the callback function that will indicate if the transfer
+ *   failed.
+ *
+ ****************************************************************************/
+
+static int i2s_receive(struct i2s_dev_s *dev, struct ap_buffer_s *apb, i2s_callback_t callback, void *arg, uint32_t timeout)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+
+	i2sinfo("[I2S RX] apb=%p nmaxbytes=%d samp=%p arg=%p timeout=%d\n", apb, apb->nmaxbytes, apb->samp, arg, timeout);
+
+	/* apb samp is the buffer user use to receive, nmaxbyte should be less than I2S_DMA_PAGE_NUM*I2S_DMA_PAGE_SIZE */
+	i2s_init_buffer(apb->samp, apb->nmaxbytes);
+
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	struct amebad_buffer_s *bfcontainer;
+	irqstate_t flags;
+	int ret;
+
+	/* Has the RX channel been enabled? */
+	if (!priv->rxenab) {
+		i2serr("ERROR: I2S has no receiver\n");
+		return -EAGAIN;
+	}
+
+	bfcontainer = i2s_buf_rx_allocate(priv);
+	DEBUGASSERT(bfcontainer);
+
+	i2s_exclsem_take(priv);
+	i2sinfo("RX Exclusive Enter\n");
+
+	/* Add a reference to the audio buffer */
+
+	apb_reference(apb);
+
+	/* Initialize the buffer container structure */
+
+	bfcontainer->callback = (void *)callback;
+	bfcontainer->timeout = timeout;
+	bfcontainer->arg = arg;
+	bfcontainer->apb = apb;
+	bfcontainer->result = -EBUSY;
+
+	/* Prepare DMA microcode */
+	i2s_rxdma_prep(priv, bfcontainer);
+
+	flags = irqsave();
+	sq_addlast((sq_entry_t *) bfcontainer, &priv->rx.pend);
+	irqrestore(flags);
+
+	/* Start transfer */
+	ret = i2s_rx_start(priv);
+
+	i2s_exclsem_give(priv);
+	i2sinfo("RX Exclusive Exit\n");
+
+	return OK;
+
+#else
+	i2serr("ERROR: I2S has no receiver\n");
+	UNUSED(priv);
+	return -ENOSYS;
+#endif
+
+}
+
+
+/*!
+ * @brief Tx interrupt handler.
+ *
+ * @param base pointer.
+ * @param handle Pointer to the sai_handle_t structure.
+ */
+void i2s_transfer_rx_handleirq(void *data, char *pbuf)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)data;
+	i2s_t *obj = &priv->i2s_object;
+
+	/* submit a new page for receive */
+	i2s_recv_page(obj);
+
+	int result = OK;
+
+	i2s_rxdma_callback(priv, result);
+}
+
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+/****************************************************************************
+ * Name: i2s_bufsem_rx_take
+ *
+ * Description:
+ *   Take the buffer semaphore handling any exceptional conditions
+ *
+ * Input Parameters:
+ *   priv - A reference to the I2S peripheral state
+ *
+ * Returned Value:
+ *  None
+ *
+ ****************************************************************************/
+
+static void i2s_bufsem_rx_take(struct amebad_i2s_s *priv)
+{
+	int ret;
+
+	/* Wait until we successfully get the semaphore.  EINTR is the only
+	 * expected 'failure' (meaning that the wait for the semaphore was
+	 * interrupted by a signal.
+	 */
+	do {
+		ret = sem_wait(&priv->bufsem_rx);
+		DEBUGASSERT(ret == 0 || errno == EINTR);
+	} while (ret < 0);
+}
+
+/****************************************************************************
+ * Name: i2s_buf_rx_allocate
+ *
+ * Description:
+ *   Allocate a buffer container by removing the one at the head of the
+ *   free list
+ *
+ * Input Parameters:
+ *   priv - i2s state instance
+ *
+ * Returned Value:
+ *   A non-NULL pointer to the allocate buffer container on success; NULL if
+ *   there are no available buffer containers.
+ *
+ * Assumptions:
+ *   The caller does NOT have exclusive access to the I2S state structure.
+ *   That would result in a deadlock!
+ *
+ ****************************************************************************/
+
+static struct amebad_buffer_s *i2s_buf_rx_allocate(struct amebad_i2s_s *priv)
+{
+	struct amebad_buffer_s *bfcontainer;
+	irqstate_t flags;
+
+	/* Set aside a buffer container.  By doing this, we guarantee that we will
+	 * have at least one free buffer container.
+	 */
+	i2s_bufsem_rx_take(priv);
+
+	/* Get the buffer from the head of the free list */
+	flags = irqsave();
+	bfcontainer = priv->freelist_rx;
+	ASSERT(bfcontainer);
+
+	/* Unlink the buffer from the freelist */
+	priv->freelist_rx = bfcontainer->flink;
+	irqrestore(flags);
+
+	return bfcontainer;
+}
+
+/****************************************************************************
+* Name: i2s_buf_rx_free
+*
+* Description:
+*   Free buffer container by adding it to the head of the free list
+*
+* Input Parameters:
+*   priv - I2S state instance
+*   bfcontainer - The buffer container to be freed
+*
+* Returned Value:
+*   None
+*
+* Assumptions:
+*   The caller has exclusive access to the I2S state structure
+*
+****************************************************************************/
+
+static void i2s_buf_rx_free(struct amebad_i2s_s *priv, struct amebad_buffer_s *bfcontainer)
+{
+	irqstate_t flags;
+
+	/* Put the buffer container back on the free list */
+	flags = irqsave();
+	bfcontainer->flink = priv->freelist_rx;
+	priv->freelist_rx = bfcontainer;
+	irqrestore(flags);
+
+	/* Wake up any threads waiting for a buffer container */
+	i2s_bufsem_rx_give(priv);
+}
+
+/****************************************************************************
+* Name: i2s_buf_rx_initialize
+*
+* Description:
+*   Initialize the buffer container allocator by adding all of the
+*   pre-allocated buffer containers to the free list
+*
+* Input Parameters:
+*   priv - I2S state instance
+*
+* Returned Value:
+*   None
+*
+* Assumptions:
+*   Called early in I2S initialization so that there are no issues with
+*   concurrency.
+*
+****************************************************************************/
+
+static void i2s_buf_rx_initialize(struct amebad_i2s_s *priv)
+{
+	int i;
+
+	priv->freelist_rx = NULL;
+	sem_init(&priv->bufsem_rx, 0, 1);
+
+	for (i = 0; i < I2S_DMA_PAGE_NUM; i++) {
+		i2s_buf_rx_free(priv, &priv->containers_rx[i]);
+	}
+}
+#endif
+
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+/****************************************************************************
+* Name: i2s_bufsem_tx_take
+*
+* Description:
+*   Take the buffer semaphore handling any exceptional conditions
+*
+* Input Parameters:
+*   priv - A reference to the I2S peripheral state
+*
+* Returned Value:
+*  None
+*
+****************************************************************************/
+
+static void i2s_bufsem_tx_take(struct amebad_i2s_s *priv)
+{
+	int ret;
+
+	/* Wait until we successfully get the semaphore.  EINTR is the only
+	 * expected 'failure' (meaning that the wait for the semaphore was
+	 * interrupted by a signal.
+	 */
+	do {
+		ret = sem_wait(&priv->bufsem_tx);
+		DEBUGASSERT(ret == 0 || errno == EINTR);
+	} while (ret < 0);
+}
+
+/****************************************************************************
+* Name: i2s_buf_tx_allocate
+*
+* Description:
+*   Allocate a buffer container by removing the one at the head of the
+*   free list
+*
+* Input Parameters:
+*   priv - i2s state instance
+*
+* Returned Value:
+*   A non-NULL pointer to the allocate buffer container on success; NULL if
+*   there are no available buffer containers.
+*
+* Assumptions:
+*   The caller does NOT have exclusive access to the I2S state structure.
+*   That would result in a deadlock!
+*
+****************************************************************************/
+
+static struct amebad_buffer_s *i2s_buf_tx_allocate(struct amebad_i2s_s *priv)
+{
+	struct amebad_buffer_s *bfcontainer;
+	irqstate_t flags;
+
+	/* Set aside a buffer container.  By doing this, we guarantee that we will
+	 * have at least one free buffer container.
+	 */
+	i2s_bufsem_tx_take(priv);
+
+	/* Get the buffer from the head of the free list */
+	flags = irqsave();
+	bfcontainer = priv->freelist_tx;
+	ASSERT(bfcontainer);
+
+	/* Unlink the buffer from the freelist */
+	priv->freelist_tx = bfcontainer->flink;
+	irqrestore(flags);
+
+	return bfcontainer;
+}
+
+/****************************************************************************
+* Name: i2s_buf_tx_free
+*
+* Description:
+*   Free buffer container by adding it to the head of the free list
+*
+* Input Parameters:
+*   priv - I2S state instance
+*   bfcontainer - The buffer container to be freed
+*
+* Returned Value:
+*   None
+*
+* Assumptions:
+*   The caller has exclusive access to the I2S state structure
+*
+****************************************************************************/
+
+static void i2s_buf_tx_free(struct amebad_i2s_s *priv, struct amebad_buffer_s *bfcontainer)
+{
+	irqstate_t flags;
+
+	/* Put the buffer container back on the free list */
+	flags = irqsave();
+	bfcontainer->flink = priv->freelist_tx;
+	priv->freelist_tx = bfcontainer;
+	irqrestore(flags);
+
+	/* Wake up any threads waiting for a buffer container */
+	i2s_bufsem_tx_give(priv);
+}
+
+/****************************************************************************
+ * Name: i2s_buf_tx_initialize
+ *
+ * Description:
+ *   Initialize the buffer container allocator by adding all of the
+ *   pre-allocated buffer containers to the free list
+ *
+ * Input Parameters:
+ *   priv - I2S state instance
+ *
+ * Returned Value:
+ *   None
+ *
+ * Assumptions:
+ *   Called early in I2S initialization so that there are no issues with
+ *   concurrency.
+ *
+ ****************************************************************************/
+
+static void i2s_buf_tx_initialize(struct amebad_i2s_s *priv)
+{
+	int i;
+
+	priv->freelist_tx = NULL;
+	sem_init(&priv->bufsem_tx, 0, 1);
+
+	for (i = 0; i < I2S_DMA_PAGE_NUM; i++) {
+		i2s_buf_tx_free(priv, &priv->containers_tx[i]);
+	}
+}
+#endif
+
+
+/*! @} */
+
+/****************************************************************************
+ * Name: i2s_exclsem_take
+ *
+ * Description:
+ *   Take the exclusive access semaphore handling any exceptional conditions
+ *
+ * Input Parameters:
+ *   priv - A reference to the I2S peripheral state
+ *
+ * Returned Value:
+ *  None
+ *
+ ****************************************************************************/
+
+static void i2s_exclsem_take(struct amebad_i2s_s *priv)
+{
+	int ret;
+
+	/* Wait until we successfully get the semaphore.  EINTR is the only
+	 * expected 'failure' (meaning that the wait for the semaphore was
+	 * interrupted by a signal.
+	 */
+	do {
+		ret = sem_wait(&priv->exclsem);
+		DEBUGASSERT(ret == 0 || errno == EINTR);
+	} while (ret < 0);
+}
+
+/****************************************************************************
+* Name: i2s_pause
+*
+* Description:
+*   Pause data transfer on I2S.
+*
+* Input Parameters:
+*   dev      - Device-specific state data
+*   dir      - the data flow direction of I2S
+*
+* Returned Value:
+*   OK on success;
+*
+****************************************************************************/
+static int i2s_pause(struct i2s_dev_s *dev, i2s_ch_dir_t dir)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+	DEBUGASSERT(priv);
+
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	if (dir == I2S_TX && priv->txenab) {
+		i2s_disable(&priv->i2s_object);
+	}
+#endif
+
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	if (dir == I2S_RX && priv->rxenab) {
+		i2s_disable(&priv->i2s_object);
+	}
+#endif
+
+	return OK;
+}
+
+/****************************************************************************
+* Name: i2s_resume
+*
+* Description:
+*   Resume data transfer on I2S if it is paused.
+*
+* Input Parameters:
+*   dev      - Device-specific state data
+*   dir      - the data flow direction of I2S
+*
+* Returned Value:
+*   OK on success;
+*
+****************************************************************************/
+static int i2s_resume(struct i2s_dev_s *dev, i2s_ch_dir_t dir)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+	DEBUGASSERT(priv);
+
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	if (dir == I2S_TX && priv->txenab) {
+		i2s_enable(&priv->i2s_object);
+	}
+#endif
+
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	if (dir == I2S_RX && priv->rxenab) {
+		i2s_enable(&priv->i2s_object);
+	}
+#endif
+
+	return OK;
+}
+
+/****************************************************************************
+* Name: i2s_stop
+*
+* Description:
+*   stop i2s transferring
+*
+* Input Parameters:
+*   dev     - device handler
+*   dir     - transferring direction
+*
+* Returned Value:
+*  OK
+*
+****************************************************************************/
+static int i2s_stop_transfer(struct i2s_dev_s *dev, i2s_ch_dir_t dir)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+	DEBUGASSERT(priv);
+
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	if (dir == I2S_TX) {
+		i2s_disable(&priv->i2s_object);
+	}
+#endif
+
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	if (dir == I2S_RX) {
+		i2s_disable(&priv->i2s_object);
+	}
+#endif
+
+	return OK;
+}
+
+static int i2s_stop(struct i2s_dev_s *dev, i2s_ch_dir_t dir)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+	irqstate_t flags;
+	struct amebad_buffer_s *bfcontainer;
+	DEBUGASSERT(priv);
+
+	i2s_exclsem_take(priv);
+
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	if (dir == I2S_TX) {
+		i2s_disable(&priv->i2s_object);
+		while (sq_peek(&priv->tx.pend) != NULL) {
+			flags = irqsave();
+			bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->tx.pend);
+			irqrestore(flags);
+			apb_free(bfcontainer->apb);
+			i2s_buf_tx_free(priv, bfcontainer);
+		}
+
+		while (sq_peek(&priv->tx.act) != NULL) {
+			flags = irqsave();
+			bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->tx.act);
+			irqrestore(flags);
+			apb_free(bfcontainer->apb);
+			i2s_buf_tx_free(priv, bfcontainer);
+		}
+
+		while (sq_peek(&priv->tx.done) != NULL) {
+			flags = irqsave();
+			bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->tx.done);
+			irqrestore(flags);
+			i2s_buf_tx_free(priv, bfcontainer);
+		}
+	}
+#endif
+
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	if (dir == I2S_RX) {
+		i2s_disable(&priv->i2s_object);
+		while (sq_peek(&priv->rx.pend) != NULL) {
+			flags = irqsave();
+			bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->rx.pend);
+			irqrestore(flags);
+			apb_free(bfcontainer->apb);
+			i2s_buf_rx_free(priv, bfcontainer);
+		}
+
+		while (sq_peek(&priv->rx.act) != NULL) {
+			flags = irqsave();
+			bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->rx.act);
+			irqrestore(flags);
+			apb_free(bfcontainer->apb);
+			i2s_buf_rx_free(priv, bfcontainer);
+		}
+
+		while (sq_peek(&priv->rx.done) != NULL) {
+			flags = irqsave();
+			bfcontainer = (struct amebad_buffer_s *)sq_remfirst(&priv->rx.done);
+			irqrestore(flags);
+			i2s_buf_rx_free(priv, bfcontainer);
+		}
+	}
+#endif
+
+	i2s_exclsem_give(priv);
+
+	return OK;
+}
+
+/****************************************************************************
+* Name: i2s_err_cb_register
+*
+* Description:
+*   Register the error callback
+*
+* Input Parameters:
+*   dev      - Device-specific state data
+*   cb       - the function pointer to callback
+*   arg      - argument to be transferred to the callback function
+*
+* Returned Value:
+*  OK
+*
+****************************************************************************/
+static int i2s_err_cb_register(struct i2s_dev_s *dev, i2s_err_cb_t cb, void *arg)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+	DEBUGASSERT(priv);
+
+	priv->err_cb = cb;
+	priv->err_cb_arg = arg;
+
+	return OK;
+}
+
+/****************************************************************************
+ * Name: amebad_i2s_isr_initialize
+ *
+ * Description:
+ *   allocate isr for i2s modules
+ *
+ * Input Parameters:
+ *   priv - Partially initialized I2S device structure.  These functions
+ *          will complete the I2S specific portions of the initialization
+ *
+ * Returned Value:
+ *   configure status
+ *
+ *
+ ****************************************************************************/
+int amebad_i2s_isr_initialize(struct amebad_i2s_s *priv)
+{
+
+	/* Attach the GPIO peripheral to the allocated CPU interrupt */
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	i2s_tx_irq_handler(&priv->i2s_object, (i2s_irq_handler)priv->tx_isr_handler, (uint32_t)priv);
+#endif
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	i2s_rx_irq_handler(&priv->i2s_object, (i2s_irq_handler)priv->rx_isr_handler, (uint32_t)priv);
+#endif
+
+	return 0;
+}
+
+/****************************************************************************
+* Name: i2s_samplerate
+*
+* Description:
+*   Set the I2S sample rate.
+*
+* Input Parameters:
+*   dev  - Device-specific state data
+*   rate - The I2S sample rate in samples (not bits) per second
+*
+* Returned Value:
+*   Returns the resulting bitrate
+*
+****************************************************************************/
+
+static uint32_t i2s_samplerate(struct i2s_dev_s *dev, uint32_t rate)
+{
+	struct amebad_i2s_s *priv = (struct amebad_i2s_s *)dev;
+	DEBUGASSERT(priv && rate > 0);
+
+	priv->i2s_object.sampling_rate = rate;
+	priv->sample_rate = rate;
+
+	return priv->i2s_object.sampling_rate;
+}
+
+/****************************************************************************
+* Name: amebad_i2s_initpins
+*
+* Description:
+*   Set the I2S pins.
+*
+* Input Parameters:
+*   dev  - Device-specific state data
+*   	 - sclk Serial Clock
+*   	 - ws Word Select
+*   	 - sd_rx, sd_tx Serial Data rx tx
+*   	 - mck Master Clock
+*
+****************************************************************************/
+
+static void amebad_i2s_initpins(struct amebad_i2s_s *priv)
+{
+	priv->i2s_sclk_pin = PA_2;
+	priv->i2s_ws_pin = PA_4;
+	priv->i2s_sd_tx_pin = PB_26;
+	priv->i2s_sd_rx_pin = PA_0;
+	priv->i2s_mck_pin = PA_12;
+}
+
+/****************************************************************************
+* Name: i2s_getdefaultconfig
+*
+* Description:
+*   Get default configuration for I2S bus.
+*
+* Input Parameters:
+*   priv  - Device-specific private data
+*
+****************************************************************************/
+
+static void i2s_getdefaultconfig(struct amebad_i2s_s *priv)
+{
+	priv->channel_num = (&i2s_default_config)->channel_num;
+	priv->i2s_object.channel_num = (&i2s_default_config)->channel_num;
+
+	priv->sample_rate = (&i2s_default_config)->sample_rate;
+	priv->i2s_object.sampling_rate = (&i2s_default_config)->sample_rate;
+
+	priv->i2s_object.direction = (&i2s_default_config)->direction;
+
+	priv->bits_per_sample = (&i2s_default_config)->bits_per_sample;
+	if (priv->bits_per_sample == I2S_BITS_PER_SAMPLE_16BIT) priv->i2s_object.word_length = WL_16b;
+	else if (priv->bits_per_sample == I2S_BITS_PER_SAMPLE_24BIT) priv->i2s_object.word_length = WL_24b;
+	else if (priv->bits_per_sample == I2S_BITS_PER_SAMPLE_32BIT) priv->i2s_object.word_length = WL_32b;
+
+}
+
+/****************************************************************************
+* Name: i2s_allocate_wd
+*
+* Description:
+*   Get default configuration for I2S bus.
+*
+* Input Parameters:
+*   priv  - Device-specific private data
+*
+****************************************************************************/
+
+static int i2s_allocate_wd(struct amebad_i2s_s *priv)
+{
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	if (priv->rxenab) {
+		priv->rx.dog = wd_create();
+		if (!priv->rx.dog) {
+			i2serr("ERROR: Failed to create the RX DMA watchdog\n");
+			goto errout;
+		}
+	}
+#endif
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	if (priv->txenab) {
+		priv->tx.dog = wd_create();
+		if (!priv->tx.dog) {
+			i2serr("ERROR: Failed to create the TX DMA watchdog\n");
+			goto errout;
+		}
+	}
+#endif
+	return OK;
+
+errout:
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	if (priv->rx.dog){
+		wd_delete(priv->rx.dog);
+		priv->rx.dog = NULL;
+	}
+#endif
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	if (priv->tx.dog){
+		wd_delete(priv->tx.dog);
+		priv->tx.dog = NULL;
+	}
+#endif
+	return -ENOMEM;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name:
+ *
+ * Description:
+ *   Initialize the selected i2s port
+ *
+ * Input Parameter:
+ *   none
+ *
+ * Returned Value:
+ *   Valid i2s device structure reference on succcess; a NULL on failure
+ *
+ ****************************************************************************/
+struct i2s_dev_s *amebad_i2s_initialize(uint16_t port)
+{
+	if (port >= I2S_NUM_MAX) {
+		i2serr("ERROR: Port number outside the allowed port number range\n");
+		return NULL;
+	}
+
+	if (g_i2sdevice[port] != NULL) {
+		return &g_i2sdevice[port]->dev;
+	}
+
+	struct amebad_i2s_s *priv;
+	int ret;
+
+	/* Allocate a new state structure for this chip select.  NOTE that there
+	 * is no protection if the same chip select is used in two different
+	 * chip select structures.
+	 */
+	priv = (struct amebad_i2s_s *)kmm_zalloc(sizeof(struct amebad_i2s_s));
+	if (!priv) {
+		i2serr("ERROR: Failed to allocate a chip select structure\n");
+		return NULL;
+	}
+
+	/* Get default configuration */
+	i2s_getdefaultconfig(priv);
+
+	/* Config values initialization */
+	amebad_i2s_initpins(priv);
+
+	/* Initialize buffering */
+#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
+	i2s_buf_rx_initialize(priv);
+	priv->rxenab = 1;
+#endif
+#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
+	i2s_buf_tx_initialize(priv);
+	priv->txenab = 1;
+#endif
+
+	/* I2s object initialization */
+	i2s_init(&priv->i2s_object, priv->i2s_sclk_pin, priv->i2s_ws_pin, priv->i2s_sd_tx_pin, priv->i2s_sd_rx_pin, priv->i2s_mck_pin);
+
+	/* Initialize buffering */
+	//i2s_set_dma_buffer(&priv->i2s_object, priv->i2s_tx_buf, priv->i2s_rx_buf, I2S_DMA_PAGE_NUM, I2S_DMA_PAGE_SIZE);
+
+	/* configures IRQ */
+	priv->rx_isr_handler = (i2s_irq_handler)&i2s_transfer_rx_handleirq;
+	priv->tx_isr_handler = (i2s_irq_handler)&i2s_transfer_tx_handleirq;
+	ret = amebad_i2s_isr_initialize(priv);
+	if (ret != OK) {
+		i2serr("I2S initialize: isr fails\n");
+		goto errout_with_alloc;
+	}
+
+	/* Initialize the I2S priv device structure  */
+	sem_init(&priv->exclsem, 0, 1);
+	priv->dev.ops = &g_i2sops;
+
+	ret = i2s_allocate_wd(priv);
+	if (ret != OK) {
+		goto errout_with_alloc;
+	}
+
+	/* Basic settings */
+	priv->i2s_num = priv->i2s_object.i2s_idx;
+
+	g_i2sdevice[port] = priv;
+
+	i2s_disable(&priv->i2s_object);
+
+	/* Success exit */
+	return &priv->dev;
+
+	/* Failure exits */
+errout_with_alloc:
+	sem_destroy(&priv->exclsem);
+	kmm_free(priv);
+	return NULL;
+}
+#endif							/* I2S_HAVE_RX || I2S_HAVE_TX */
+#endif							/* CONFIG_AUDIO */
diff --git a/os/arch/arm/src/amebad/amebad_i2s.h b/os/arch/arm/src/amebad/amebad_i2s.h
new file mode 100644
index 0000000000..4ad4d1573d
--- /dev/null
+++ b/os/arch/arm/src/amebad/amebad_i2s.h
@@ -0,0 +1,90 @@
+/****************************************************************************
+ *
+ * Copyright 2021 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifndef __AMEBAD_I2S_H
+#define __AMEBAD_I2S_H
+
+/************************************************************************************
+ * Included Files
+ ************************************************************************************/
+
+#include <tinyara/config.h>
+#include <tinyara/audio/i2s.h>
+
+#include <arch/chip/irq.h>
+
+#ifndef __ASSEMBLY__
+
+#undef EXTERN
+#if defined(__cplusplus)
+#define EXTERN extern "C"
+extern "C" {
+#else
+#define EXTERN extern
+#endif
+
+/************************************************************************************
+ * Pre-processor Definitions
+ ************************************************************************************/
+/* SAI module features */
+
+/************************************************************************************
+ * Public Data
+ ************************************************************************************/
+/**
+* @brief I2S Peripheral, 0 & 1.
+*
+*/
+typedef enum {
+	I2S_NUM_0 = 0x0,			/*!< I2S 0 */
+	//I2S_NUM_1 = 0x1,			/*!< I2S 1 */
+	I2S_NUM_MAX,
+} i2s_port_t;
+/**
+* @brief I2S bit width per sample.
+*
+*/
+typedef enum {
+	I2S_BITS_PER_SAMPLE_8BIT  = 8,  /*!< I2S bits per sample: 8-bits */
+	I2S_BITS_PER_SAMPLE_16BIT = 16, /*!< I2S bits per sample: 16-bits */
+	I2S_BITS_PER_SAMPLE_24BIT = 24, /*!< I2S bits per sample: 24-bits */
+	I2S_BITS_PER_SAMPLE_32BIT = 32, /*!< I2S bits per sample: 32-bits */
+} i2s_bits_per_sample_t;
+/****************************************************************************
+ * Name: amebad_i2s_initialize
+ *
+ * Description:
+ *   Initialize the selected I2S port.
+ *
+ * Input Parameter:
+ *   Port number (for hardware that has mutiple I2S interfaces)
+ *
+ * Returned Value:
+ *   Valid I2S device structure reference on succcess; a NULL on failure
+ *
+ ****************************************************************************/
+
+FAR struct i2s_dev_s *amebad_i2s_initialize(uint16_t port);
+
+#undef EXTERN
+#if defined(__cplusplus)
+}
+#endif
+
+#endif							/* __ASSEMBLY__ */
+#endif							/* __AMEBAD_I2S_H */
diff --git a/os/arch/arm/src/amebad/amebad_spi.c b/os/arch/arm/src/amebad/amebad_spi.c
new file mode 100644
index 0000000000..3850d6465c
--- /dev/null
+++ b/os/arch/arm/src/amebad/amebad_spi.c
@@ -0,0 +1,1198 @@
+/****************************************************************************
+ *
+ * Copyright 2021 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+/************************************************************************************
+ * Included Files
+ ************************************************************************************/
+
+#include <tinyara/config.h>
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <semaphore.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <tinyara/irq.h>
+#include <tinyara/arch.h>
+#include <tinyara/semaphore.h>
+#include <tinyara/spi/spi.h>
+
+#include <arch/board/board.h>
+
+#include "up_internal.h"
+#include "up_arch.h"
+
+#include "chip.h"
+
+#include "amebad_spi.h"
+#include "mbed/targets/hal/rtl8721d/PinNames.h"
+#include "mbed/hal/spi_api.h"
+
+/************************************************************************************
+ * Pre-processor Definitions
+ ************************************************************************************/
+
+/* Configuration ********************************************************************/
+
+/* SPI interrupts */
+
+#ifdef CONFIG_AMEBAD_SPI_INTERRUPTS
+#error "Interrupt driven SPI not yet supported"
+#endif
+
+#if defined(CONFIG_AMEBAD_SPI_DMA)
+#error "DMA mode is not yet supported"
+#endif
+
+/* Can't have both interrupt driven SPI and SPI DMA */
+
+#if defined(CONFIG_AMEBAD_SPI_INTERRUPTS) && defined(CONFIG_AMEBAD_SPI_DMA)
+#error "Cannot enable both interrupt mode and DMA mode for SPI"
+#endif
+
+#undef spierr
+#undef spiinfo
+#if defined(DEBUG_IMX_I2C)
+#define spiinfo(format, ...)   printf(format, ##__VA_ARGS__)
+#define spierr(format, ...)    printf(format, ##__VA_ARGS__)
+#else
+#define spiinfo(format, ...)
+//#define spierr(format, ...)
+#endif
+#define spierr(format, ...)   printf(format, ##__VA_ARGS__)
+
+#define AMEBAD_SPI_MASTER	0
+#define AMEBAD_SPI_SLAVE	1
+
+/************************************************************************************
+ * Private Types
+ ************************************************************************************/
+
+struct amebad_spidev_s {
+	struct spi_dev_s spidev;    /* Externally visible part of the SPI interface */
+//	uint32_t spibase;           /* SPIn base address */
+//#ifdef CONFIG_AMEBAD_SPI_INTERRUPTS
+//	uint8_t spiirq;             /* SPI IRQ number */
+//#endif
+	sem_t exclsem;              /* Held while chip is selected for mutual exclusion */
+	uint32_t frequency;         /* Requested clock frequency */
+	uint32_t actual;            /* Actual clock frequency */
+
+	spi_t spi_object;
+	uint32_t spi_idx;
+	PinName spi_mosi;
+	PinName spi_miso;
+	PinName spi_sclk;
+	PinName spi_cs;
+	int8_t nbits;               /* Width of word in bits */
+	uint8_t mode;               /* Mode 0,1,2,3 */
+	int role;
+};
+
+enum amebad_delay_e {
+	SPI_PCS_TO_SCK = 1,       /* PCS-to-SCK delay. */
+	SPI_LAST_SCK_TO_PCS,      /* Last SCK edge to PCS delay. */
+	SPI_BETWEEN_TRANSFER      /* Delay between transfers. */
+};
+
+/************************************************************************************
+ * Private Function Prototypes
+ ************************************************************************************/
+
+/* Helpers */
+
+static inline uint32_t amebad_spi_getreg32(FAR struct amebad_spidev_s *priv,
+					uint8_t offset);
+static inline void amebad_spi_putreg32(FAR struct amebad_spidev_s *priv,
+					uint8_t offset, uint32_t value);
+static inline uint16_t amebad_spi_readword(FAR struct amebad_spidev_s *priv);
+static inline void amebad_spi_writeword(FAR struct amebad_spidev_s *priv,
+					uint16_t byte);
+static inline bool amebad_spi_9to16bitmode(FAR struct amebad_spidev_s *priv);
+static inline void amebad_spi_master_set_delays(FAR struct amebad_spidev_s
+					*priv, uint32_t delay_ns,
+					enum amebad_delay_e type);
+static inline void amebad_spi_master_set_delay_scaler(FAR struct
+					amebad_spidev_s *priv,
+					uint32_t scaler,
+					enum amebad_delay_e type);
+
+/* SPI methods */
+
+static int amebad_spi_lock(FAR struct spi_dev_s *dev, bool lock);
+static uint32_t amebad_spi_setfrequency(FAR struct spi_dev_s *dev,
+					uint32_t frequency);
+static void amebad_spi_setmode(FAR struct spi_dev_s *dev,
+				enum spi_mode_e mode);
+static void amebad_spi_setbits(FAR struct spi_dev_s *dev, int nbits);
+#ifdef CONFIG_SPI_HWFEATURES
+static int amebad_spi_hwfeatures(FAR struct spi_dev_s *dev,
+				amebad_spi_hwfeatures_t features);
+#endif
+static uint16_t amebad_spi_send(FAR struct spi_dev_s *dev, uint16_t wd);
+static void amebad_spi_exchange(FAR struct spi_dev_s *dev,
+				FAR const void *txbuffer, FAR void *rxbuffer,
+				size_t nwords);
+#ifndef CONFIG_SPI_EXCHANGE
+static void amebad_spi_sndblock(FAR struct spi_dev_s *dev,
+				FAR const void *txbuffer, size_t nwords);
+static void amebad_spi_recvblock(FAR struct spi_dev_s *dev, FAR void *rxbuffer,
+				size_t nwords);
+#endif
+
+/* Initialization */
+
+static void amebad_spi_bus_initialize(FAR struct amebad_spidev_s *priv);
+
+/************************************************************************************
+ * Private Data
+ ************************************************************************************/
+
+static const struct spi_ops_s g_spi0ops = {
+	.lock         = amebad_spi_lock,
+	.select       = amebad_spi0select,
+	.setfrequency = amebad_spi_setfrequency,
+	.setmode      = amebad_spi_setmode,
+	.setbits      = amebad_spi_setbits,
+#ifdef CONFIG_SPI_HWFEATURES
+	.hwfeatures   = amebad_spi_hwfeatures,
+#endif
+	.status       = amebad_spi0status,
+#ifdef CONFIG_SPI_CMDDATA
+	.cmddata      = amebad_spi0cmddata,
+#endif
+	.send         = amebad_spi_send,
+#ifdef CONFIG_SPI_EXCHANGE
+	.exchange     = amebad_spi_exchange,
+#else
+	.sndblock     = amebad_spi_sndblock,
+	.recvblock    = amebad_spi_recvblock,
+#endif
+#ifdef CONFIG_SPI_CALLBACK
+	.registercallback = amebad_spi0register,  /* Provided externally */
+#else
+	.registercallback = 0,                     /* Not implemented */
+#endif
+};
+
+static struct amebad_spidev_s g_spi0dev = {
+	.spidev       = {
+		&g_spi0ops
+	},
+	/*
+	.spibase      = AMEBAD_SPI1_BASE,
+#ifdef CONFIG_AMEBAD_SPI_INTERRUPTS
+	.spiirq       = AMEBAD_IRQ_SPI1,
+#endif
+#ifdef CONFIG_AMEBAD_SPI_DMA
+	.rxch         = DMAMAP_SPI1_RX,
+	.txch         = DMAMAP_SPI1_TX,
+#endif
+*/
+
+	.spi_object = {0},
+
+	.spi_idx = MBED_SPI0,
+	.spi_mosi = PA_16,
+	.spi_miso = PA_17,
+	.spi_sclk = PA_18,
+	.spi_cs = PA_19,
+	.nbits = 8,
+	.mode = SPIDEV_MODE0,
+	.role = AMEBAD_SPI_SLAVE,
+};
+
+static const struct spi_ops_s g_spi1ops = {
+	.lock         = amebad_spi_lock,
+	.select       = amebad_spi1select,
+	.setfrequency = amebad_spi_setfrequency,
+	.setmode      = amebad_spi_setmode,
+	.setbits      = amebad_spi_setbits,
+#ifdef CONFIG_SPI_HWFEATURES
+	.hwfeatures   = amebad_spi_hwfeatures,
+#endif
+	.status       = amebad_spi1status,
+#ifdef CONFIG_SPI_CMDDATA
+	.cmddata      = amebad_spi1cmddata,
+#endif
+	.send         = amebad_spi_send,
+#ifdef CONFIG_SPI_EXCHANGE
+	.exchange     = amebad_spi_exchange,
+#else
+	.sndblock     = amebad_spi_sndblock,
+	.recvblock    = amebad_spi_recvblock,
+#endif
+#ifdef CONFIG_SPI_CALLBACK
+	.registercallback = amebad_spi1register,  /* Provided externally */
+#else
+	.registercallback = 0,                     /* Not implemented */
+#endif
+};
+
+static struct amebad_spidev_s g_spi1dev = {
+	.spidev       = {
+		&g_spi1ops
+	},
+	/*
+	.spibase      = AMEBAD_SPI1_BASE,
+#ifdef CONFIG_AMEBAD_SPI_INTERRUPTS
+	.spiirq       = AMEBAD_IRQ_SPI1,
+#endif
+#ifdef CONFIG_AMEBAD_SPI_DMA
+	.rxch         = DMAMAP_SPI1_RX,
+	.txch         = DMAMAP_SPI1_TX,
+#endif
+*/
+
+	.spi_object = {0},
+
+	.spi_idx = MBED_SPI1,
+	.spi_mosi = PB_4,
+	.spi_miso = PB_5,
+	.spi_sclk = PB_6,
+	.spi_cs = PB_7,
+	.nbits = 8,
+	.mode = SPIDEV_MODE0,
+	.role = AMEBAD_SPI_MASTER
+};
+/************************************************************************************
+ * Private Functions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Name: amebad_spi_getreg8
+ *
+ * Description:
+ *   Get the contents of the SPI register at offset
+ *
+ * Input Parameters:
+ *   priv   - private SPI device structure
+ *   offset - offset to the register of interest
+ *
+ * Returned Value:
+ *   The contents of the 8-bit register
+ *
+ ************************************************************************************/
+
+static inline uint8_t amebad_spi_getreg8(FAR struct amebad_spidev_s *priv,
+					uint8_t offset)
+{
+	return 0;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_putreg8
+ *
+ * Description:
+ *   Write a 8-bit value to the SPI register at offset
+ *
+ * Input Parameters:
+ *   priv   - private SPI device structure
+ *   offset - offset to the register of interest
+ *   value  - the 8-bit value to be written
+ *
+ ************************************************************************************/
+
+static inline void amebad_spi_putreg8(FAR struct amebad_spidev_s *priv,
+				uint8_t offset, uint8_t value)
+{
+	return;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_getreg
+ *
+ * Description:
+ *   Get the contents of the SPI register at offset
+ *
+ * Input Parameters:
+ *   priv   - private SPI device structure
+ *   offset - offset to the register of interest
+ *
+ * Returned Value:
+ *   The contents of the 32-bit register
+ *
+ ************************************************************************************/
+
+static inline uint32_t amebad_spi_getreg32(FAR struct amebad_spidev_s *priv,
+					uint8_t offset)
+{
+	return 0;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_putreg
+ *
+ * Description:
+ *   Write a 16-bit value to the SPI register at offset
+ *
+ * Input Parameters:
+ *   priv   - private SPI device structure
+ *   offset - offset to the register of interest
+ *   value  - the 32-bit value to be written
+ *
+ * Returned Value:
+ *   The contents of the 32-bit register
+ *
+ ************************************************************************************/
+
+static inline void amebad_spi_putreg32(FAR struct amebad_spidev_s *priv,
+					uint8_t offset, uint32_t value)
+{
+	return;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_readword
+ *
+ * Description:
+ *   Read one word from SPI
+ *
+ * Input Parameters:
+ *   priv - Device-specific state data
+ *
+ * Returned Value:
+ *   word as read
+ *
+ ************************************************************************************/
+
+static inline uint16_t amebad_spi_readword(FAR struct amebad_spidev_s *priv)
+{
+	return 0;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_writeword
+ *
+ * Description:
+ *   Write one word to SPI
+ *
+ * Input Parameters:
+ *   priv - Device-specific state data
+ *   word - word to send
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static inline void amebad_spi_writeword(FAR struct amebad_spidev_s *priv, uint16_t word)
+{
+	return;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_readbyte
+ *
+ * Description:
+ *   Read one byte from SPI
+ *
+ * Input Parameters:
+ *   priv - Device-specific state data
+ *
+ * Returned Value:
+ *   Byte as read
+ *
+ ************************************************************************************/
+
+static inline uint8_t amebad_spi_readbyte(FAR struct amebad_spidev_s *priv)
+{
+	return 0;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_writebyte
+ *
+ * Description:
+ *   Write one 8-bit frame to the SPI FIFO
+ *
+ * Input Parameters:
+ *   priv - Device-specific state data
+ *   byte - Byte to send
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static inline void amebad_spi_writebyte(FAR struct amebad_spidev_s *priv, uint8_t byte)
+{
+	return;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_9to16bitmode
+ *
+ * Description:
+ *   Check if the SPI is operating in more then 8 bit mode
+ *
+ * Input Parameters:
+ *   priv     - Device-specific state data
+ *
+ * Returned Value:
+ *   true: >8 bit mode-bit mode, false: <= 8-bit mode
+ *
+ ************************************************************************************/
+
+static inline bool amebad_spi_9to16bitmode(FAR struct amebad_spidev_s *priv)
+{
+	if (priv->nbits < 9) return false;
+	else return true;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_modifyreg
+ *
+ * Description:
+ *   Clear and set bits in register
+ *
+ * Input Parameters:
+ *   priv    - Device-specific state data
+ *   offset  - Register offset
+ *   clrbits - The bits to clear
+ *   setbits - The bits to set
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static void amebad_spi_modifyreg32(FAR struct amebad_spidev_s *priv,
+				uint8_t offset, uint32_t clrbits,
+				uint32_t setbits)
+{
+}
+
+/************************************************************************************
+ * Name: amebad_spi_master_set_delays
+ *
+ * Description:
+ *   SET SPI Delay times
+ *
+ * Input Parameters:
+ *   priv   - Device-specific state data
+ *   scaler - scaler value
+ *   type   - delay time type
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static inline void amebad_spi_master_set_delay_scaler(FAR struct amebad_spidev_s *priv,
+						uint32_t scaler,
+						enum amebad_delay_e type)
+{
+	/*
+	switch (type) {
+	case SPI_PCS_TO_SCK:
+		amebad_spi_modifyreg32(priv, AMEBAD_SPI_CCR_OFFSET,
+					SPI_CCR_PCSSCK_MASK, 0);
+		amebad_spi_modifyreg32(priv, AMEBAD_SPI_CCR_OFFSET, 0,
+					SPI_CCR_PCSSCK(scaler));
+	break;
+
+	case SPI_LAST_SCK_TO_PCS:
+		amebad_spi_modifyreg32(priv, AMEBAD_SPI_CCR_OFFSET,
+					SPI_CCR_SCKPCS_MASK, 0);
+		amebad_spi_modifyreg32(priv, AMEBAD_SPI_CCR_OFFSET, 0,
+					SPI_CCR_SCKPCS(scaler));
+	break;
+
+	case SPI_BETWEEN_TRANSFER:
+		amebad_spi_modifyreg32(priv, AMEBAD_SPI_CCR_OFFSET, SPI_CCR_DBT_MASK,
+					0);
+		amebad_spi_modifyreg32(priv, AMEBAD_SPI_CCR_OFFSET, 0,
+					SPI_CCR_DBT(scaler));
+	break;
+	}
+	*/
+}
+
+/************************************************************************************
+ * Name: amebad_spi_master_set_delays
+ *
+ * Description:
+ *   SET SPI Delay times
+ *
+ * Input Parameters:
+ *   priv     - Device-specific state data
+ *   delay_ns - delay time in nano seconds
+ *   type     - delay time type
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+static inline void amebad_spi_master_set_delays(FAR struct amebad_spidev_s *priv,
+						uint32_t delay_ns,
+						enum amebad_delay_e type)
+{
+}
+
+/************************************************************************************
+ * Name: amebad_spi_lock
+ *
+ * Description:
+ *   On SPI busses where there are multiple devices, it will be necessary to
+ *   lock SPI to have exclusive access to the busses for a sequence of
+ *   transfers.  The bus should be locked before the chip is selected. After
+ *   locking the SPI bus, the caller should then also call the setfrequency,
+ *   setbits, and setmode methods to make sure that the SPI is properly
+ *   configured for the device.  If the SPI buss is being shared, then it
+ *   may have been left in an incompatible state.
+ *
+ * Input Parameters:
+ *   dev  - Device-specific state data
+ *   lock - true: Lock spi bus, false: unlock SPI bus
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static int amebad_spi_lock(FAR struct spi_dev_s *dev, bool lock)
+{
+	FAR struct amebad_spidev_s *priv = (FAR struct amebad_spidev_s *)dev;
+	int ret;
+
+	if (lock) {
+		/* Take the semaphore (perhaps waiting) */
+
+		do {
+			ret = sem_wait(&priv->exclsem);
+
+			/* The only case that an error should occur here is if the wait was
+			 * awakened by a signal.
+			 */
+
+			DEBUGASSERT(ret == OK || errno == EINTR);
+		} while (errno == EINTR);
+	} else {
+		(void)sem_post(&priv->exclsem);
+		ret = OK;
+	}
+
+	return ret;
+}
+
+/************************************************************************************
+ * Name: amebad_spi0select
+ *
+ * Description:
+ *   Enable/disable the SPI slave select. The implementation of this method
+ *   must include handshaking:  If a device is selected, it must hold off
+ *   all other attempts to select the device until the device is deselecte.
+ *
+ * Input Parameters:
+ *   dev -       Device-specific state data
+ *   devid -    Device Id
+ *   selected - whether it is selected or not
+ *
+ * Returned Value: None
+ *
+ *
+ ************************************************************************************/
+void amebad_spi0select(FAR struct spi_dev_s *dev, enum spi_dev_e devid, bool selected)
+{
+	return;
+}
+
+/************************************************************************************
+ * Name: amebad_spi0status
+ *
+ * Description:
+ *   Get the spi status
+ *
+ * Input Parameters:
+ *   dev -       Device-specific state data
+ *   devid  - Device ID
+ *
+ * Returned Value:
+ *   Returns the SPI status
+ *
+ ************************************************************************************/
+uint8_t amebad_spi0status(FAR struct spi_dev_s *dev, enum spi_dev_e devid)
+{
+	return 0;
+}
+
+/************************************************************************************
+ * Name: amebad_spi0cmddata
+ *
+ * Description:
+ *   Send cmd to device according to devid.
+ *
+ * Input Parameters:
+ *   dev -       Device-specific state data
+ *   devid -   Device ID
+ *   cmd - the command that need to be sent
+ *
+ * Returned Value:
+ *   TBD
+ *
+ ************************************************************************************/
+int amebad_spi0cmddata(FAR struct spi_dev_s *dev, uint32_t devid, bool cmd)
+{
+	return 0;
+}
+
+/************************************************************************************
+ * Name: amebad_spi1select
+ *
+ * Description:
+ *   Enable/disable the SPI slave select. The implementation of this method
+ *   must include handshaking:  If a device is selected, it must hold off
+ *   all other attempts to select the device until the device is deselecte.
+ *
+ * Input Parameters:
+ *   dev -       Device-specific state data
+ *   devid -    Device Id
+ *   selected - whether it is selected or not
+ *
+ * Returned Value: None
+ *
+ *
+ ************************************************************************************/
+void amebad_spi1select(FAR struct spi_dev_s *dev, enum spi_dev_e devid, bool selected)
+{
+	return;
+}
+
+/************************************************************************************
+ * Name: amebad_spi1status
+ *
+ * Description:
+ *   Get the spi status
+ *
+ * Input Parameters:
+ *   dev -       Device-specific state data
+ *   devid  - Device ID
+ *
+ * Returned Value:
+ *   Returns the SPI status
+ *
+ ************************************************************************************/
+uint8_t amebad_spi1status(FAR struct spi_dev_s *dev, enum spi_dev_e devid)
+{
+	return 0;
+}
+
+/************************************************************************************
+ * Name: amebad_spi1cmddata
+ *
+ * Description:
+ *   Send cmd to device according to devid.
+ *
+ * Input Parameters:
+ *   dev -       Device-specific state data
+ *   devid -   Device ID
+ *   cmd - the command that need to be sent
+ *
+ * Returned Value:
+ *   TBD
+ *
+ ************************************************************************************/
+int amebad_spi1cmddata(FAR struct spi_dev_s *dev, uint32_t devid, bool cmd)
+{
+	return 0;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_setfrequency
+ *
+ * Description:
+ *   Set the SPI frequency.
+ *
+ * Input Parameters:
+ *   dev -       Device-specific state data
+ *   frequency - The SPI frequency requested
+ *
+ * Returned Value:
+ *   Returns the actual frequency selected
+ *
+ ************************************************************************************/
+
+static uint32_t amebad_spi_setfrequency(FAR struct spi_dev_s *dev,
+					uint32_t frequency)
+{
+	FAR struct amebad_spidev_s *priv = (FAR struct amebad_spidev_s *)dev;
+
+	/* Has the SPI bus frequency changed? */
+
+	if (frequency != priv->frequency) {
+		/* Disable SPI if it is enabled */
+
+		priv->frequency = frequency;
+
+		if (priv->role == AMEBAD_SPI_MASTER)
+			spi_frequency(&priv->spi_object, priv->frequency);
+	}
+
+	return priv->frequency;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_setmode
+ *
+ * Description:
+ *   Set the SPI mode.  see enum spi_mode_e mode for mode definitions
+ *
+ * Input Parameters:
+ *   dev  - Device-specific state data
+ *   mode - The SPI mode requested
+ *
+ * Returned Value:
+ *   Returns the actual frequency selected
+ *
+ ************************************************************************************/
+
+static void amebad_spi_setmode(FAR struct spi_dev_s *dev, enum spi_mode_e mode)
+{
+	FAR struct amebad_spidev_s *priv = (FAR struct amebad_spidev_s *)dev;
+
+	spiinfo("mode=%d\n", mode);
+
+	/* Has the mode changed? */
+
+	if (mode != priv->mode) {
+		/* Disable SPI if it is enabled */
+
+		priv->mode = mode;
+		spi_format(&priv->spi_object, priv->nbits, priv->mode, priv->role);
+
+	}
+}
+
+/************************************************************************************
+ * Name: amebad_spi_setbits
+ *
+ * Description:
+ *   Set the number of bits per word.
+ *
+ * Input Parameters:
+ *   dev   - Device-specific state data
+ *   nbits - The number of bits requested
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static void amebad_spi_setbits(FAR struct spi_dev_s *dev, int nbits)
+{
+	FAR struct amebad_spidev_s *priv = (FAR struct amebad_spidev_s *)dev;
+
+	spiinfo("nbits=%d\n", nbits);
+
+	/* Has the number of bits changed? */
+
+	if (nbits != priv->nbits) {
+
+		if (nbits < 4 || nbits > 16) {
+			return;
+		}
+
+		/* Save the selection so the subsequence re-configurations will be faster */
+
+		priv->nbits = nbits;
+		spi_format(&priv->spi_object, priv->nbits, priv->mode, priv->role);
+
+	}
+}
+
+/****************************************************************************
+ * Name: amebad_spi_hwfeatures
+ *
+ * Description:
+ *   Set hardware-specific feature flags.
+ *
+ * Input Parameters:
+ *   dev      - Device-specific state data
+ *   features - H/W feature flags
+ *
+ * Returned Value:
+ *   Zero (OK) if the selected H/W features are enabled; A negated errno
+ *   value if any H/W feature is not supportable.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_SPI_HWFEATURES
+static int amebad_spi_hwfeatures(FAR struct spi_dev_s *dev,
+				amebad_spi_hwfeatures_t features)
+{
+#ifdef CONFIG_SPI_BITORDER
+	FAR struct amebad_spidev_s *priv = (FAR struct amebad_spidev_s *)dev;
+
+	spiinfo("features=%08x\n", features);
+
+	/* Other H/W features are not supported */
+#endif
+	return -ENOSYS;
+}
+#endif
+
+/************************************************************************************
+ * Name: amebad_spi_send
+ *
+ * Description:
+ *   Exchange one word on SPI
+ *
+ * Input Parameters:
+ *   dev - Device-specific state data
+ *   wd  - The word to send.  the size of the data is determined by the
+ *         number of bits selected for the SPI interface.
+ *
+ * Returned Value:
+ *   response
+ *
+ ************************************************************************************/
+
+static uint16_t amebad_spi_send(FAR struct spi_dev_s *dev, uint16_t wd)
+{
+	FAR struct amebad_spidev_s *priv = (FAR struct amebad_spidev_s *)dev;
+
+	uint16_t ret;
+	DEBUGASSERT(priv);
+
+	if (priv->role == AMEBAD_SPI_MASTER) {
+
+		ret = spi_master_write(&priv->spi_object, wd);
+	} else if (priv->role == AMEBAD_SPI_SLAVE) {
+
+		spi_slave_write(&priv->spi_object, wd);
+		ret = wd;
+	}
+
+	/* Check and clear any error flags (Reading from the SR clears the error
+	 * flags).
+	 */
+
+	spiinfo("Sent: %04x Return: %04x\n", wd, ret);
+
+	return ret;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_exchange (no DMA).  aka amebad_spi_exchange_nodma
+ *
+ * Description:
+ *   Exchange a block of data on SPI without using DMA
+ *
+ * Input Parameters:
+ *   dev      - Device-specific state data
+ *   txbuffer - A pointer to the buffer of data to be sent
+ *   rxbuffer - A pointer to a buffer in which to receive data
+ *   nwords   - the length of data to be exchaned in units of words.
+ *              The wordsize is determined by the number of bits-per-word
+ *              selected for the SPI interface.  If nbits <= 8, the data is
+ *              packed into uint8_t's; if nbits >8, the data is packed into uint16_t's
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+#if !defined(CONFIG_AMEBAD_SPI_DMA) || defined(CONFIG_AMEBAD_DMACAPABLE)
+#if !defined(CONFIG_AMEBAD_SPI_DMA)
+static void amebad_spi_exchange(FAR struct spi_dev_s *dev,
+				FAR const void *txbuffer, FAR void *rxbuffer,
+				size_t nwords)
+#else
+static void amebad_spi_exchange_nodma(FAR struct spi_dev_s *dev,
+				FAR const void *txbuffer,
+				FAR void *rxbuffer, size_t nwords)
+#endif
+{
+	FAR struct amebad_spidev_s *priv = (FAR struct amebad_spidev_s *)dev;
+	DEBUGASSERT(priv);
+
+	spiinfo("txbuffer=%p rxbuffer=%p nwords=%d\n", txbuffer, rxbuffer, nwords);
+
+	/* 8- or 16-bit mode? */
+
+	if (amebad_spi_9to16bitmode(priv)) {
+		/* 16-bit mode */
+
+		const uint16_t *src = (const uint16_t *)txbuffer;
+		uint16_t *dest = (uint16_t *)rxbuffer;
+		uint16_t word;
+
+		while (nwords-- > 0) {
+			/* Get the next word to write.  Is there a source buffer? */
+
+			if (src) {
+				word = *src++;
+			} else {
+				word = 0xffff;
+			}
+
+			/* Exchange one word */
+
+			word = amebad_spi_send(dev, word);
+
+			/* Is there a buffer to receive the return value? */
+
+			if (dest) {
+				*dest++ = word;
+			}
+		}
+	} else {
+		/* 8-bit mode */
+
+		const uint8_t *src = (const uint8_t *)txbuffer;
+		uint8_t *dest = (uint8_t *)rxbuffer;
+		uint8_t word;
+
+		while (nwords-- > 0) {
+			/* Get the next word to write.  Is there a source buffer? */
+
+			if (src) {
+				word = *src++;
+			} else {
+				word = 0xff;
+			}
+
+			/* Exchange one word */
+
+			word = (uint8_t)amebad_spi_send(dev, (uint16_t) word);
+
+			/* Is there a buffer to receive the return value? */
+
+			if (dest) {
+				*dest++ = word;
+			}
+		}
+	}
+}
+#endif /* !CONFIG_AMEBAD_SPI_DMA || CONFIG_AMEBAD_DMACAPABLE */
+
+/****************************************************************************
+ * Name: amebad_spi_sndblock
+ *
+ * Description:
+ *   Send a block of data on SPI
+ *
+ * Input Parameters:
+ *   dev      - Device-specific state data
+ *   txbuffer - A pointer to the buffer of data to be sent
+ *   nwords   - the length of data to send from the buffer in number of words.
+ *              The wordsize is determined by the number of bits-per-word
+ *              selected for the SPI interface.  If nbits <= 8, the data is
+ *              packed into uint8_t's; if nbits >8, the data is packed into uint16_t's
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+#ifndef CONFIG_SPI_EXCHANGE
+static void amebad_spi_sndblock(FAR struct spi_dev_s *dev,
+				FAR const void *txbuffer, size_t nwords)
+{
+	spiinfo("txbuffer=%p nwords=%d\n", txbuffer, nwords);
+	return amebad_spi_exchange(dev, txbuffer, NULL, nwords);
+}
+#endif
+
+/************************************************************************************
+ * Name: amebad_spi_recvblock
+ *
+ * Description:
+ *   Receive a block of data from SPI
+ *
+ * Input Parameters:
+ *   dev      - Device-specific state data
+ *   rxbuffer - A pointer to the buffer in which to recieve data
+ *   nwords   - the length of data that can be received in the buffer in number
+ *              of words.  The wordsize is determined by the number of bits-per-word
+ *              selected for the SPI interface.  If nbits <= 8, the data is
+ *              packed into uint8_t's; if nbits >8, the data is packed into uint16_t's
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+#ifndef CONFIG_SPI_EXCHANGE
+static void amebad_spi_recvblock(FAR struct spi_dev_s *dev, FAR void *rxbuffer,
+				size_t nwords)
+{
+	spiinfo("rxbuffer=%p nwords=%d\n", rxbuffer, nwords);
+	return amebad_spi_exchange(dev, NULL, rxbuffer, nwords);
+}
+#endif
+
+/************************************************************************************
+ * Name: amebad_spi_clock_enable
+ *
+ * Description:
+ *   Ungate SPI clock
+ *
+ ************************************************************************************/
+
+void amebad_spi_clock_enable(uint32_t base)
+{
+	return;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_clock_disable
+ *
+ * Description:
+ *   Gate SPI clock
+ *
+ ************************************************************************************/
+
+void amebad_spi_clock_disable(uint32_t base)
+{
+	return;
+}
+
+/************************************************************************************
+ * Name: amebad_spi_bus_initialize
+ *
+ * Description:
+ *   Initialize the selected SPI bus in its default state (Master, 8-bit, mode 0, etc.)
+ *
+ * Input Parameters:
+ *   priv   - private SPI device structure
+ *
+ * Returned Value:
+ *   None
+ *
+ ************************************************************************************/
+
+static void amebad_spi_bus_initialize(struct amebad_spidev_s *priv)
+{
+
+	DEBUGASSERT(priv);
+	DEBUGASSERT(&priv->spi_object);
+
+	priv->spi_object.spi_idx = priv->spi_idx;
+	spi_init(&priv->spi_object, priv->spi_mosi, priv->spi_miso, priv->spi_sclk, priv->spi_cs);
+
+	spi_format(&priv->spi_object, priv->nbits, priv->mode, priv->role);
+
+}
+
+/************************************************************************************
+ * Public Functions
+ ************************************************************************************/
+
+/************************************************************************************
+ * Name: amebad_spibus_initialize
+ *
+ * Description:
+ *   Initialize the selected SPI bus
+ *
+ * Input Parameters:
+ *   Port number (for hardware that has mutiple SPI interfaces)
+ *
+ * Returned Value:
+ *   Valid SPI device structure reference on success; a NULL on failure
+ *
+ ************************************************************************************/
+
+FAR struct spi_dev_s *amebad_spibus_initialize(int bus)
+{
+	FAR struct amebad_spidev_s *priv = NULL;
+
+	irqstate_t flags = irqsave();
+
+	if (bus == 1) {
+		/* Select SPI1 */
+
+		priv = &g_spi0dev;
+
+		/* Only configure if the bus is not already configured */
+
+		amebad_spi_bus_initialize(priv);
+
+	} else if (bus == 2) {
+		/* Select SPI2 */
+
+		priv = &g_spi1dev;
+
+		/* Only configure if the bus is not already configured */
+
+		amebad_spi_bus_initialize(priv);
+
+	} else {
+		spierr("ERROR: Unsupported SPI bus: %d\n", bus);
+		irqrestore(flags);
+		return NULL;
+	}
+
+	irqrestore(flags);
+
+	return (FAR struct spi_dev_s *)priv;
+}
+
+/************************************************************************************
+ * Name: up_spiinitialize
+ *
+ * Description:
+ *   Initialize the selected SPI bus
+ *
+ * Input Parameters:
+ *   Port number (for hardware that has mutiple SPI interfaces)
+ *
+ * Returned Value:
+ *   Valid SPI device structure reference on success; a NULL on failure
+ *
+ ************************************************************************************/
+
+FAR struct spi_dev_s *up_spiinitialize(int port)
+{
+	FAR struct amebad_spidev_s *priv = NULL;
+
+	irqstate_t flags = irqsave();
+
+	if (port == 0) {
+		/* Select SPI1 */
+
+		priv = &g_spi0dev;
+
+		/* Only configure if the bus is not already configured */
+
+		amebad_spi_bus_initialize(priv);
+	}
+	else if (port == 1) {
+		/* Select SPI1 */
+
+		priv = &g_spi1dev;
+
+		/* Only configure if the bus is not already configured */
+
+		amebad_spi_bus_initialize(priv);
+	} else
+	{
+		spierr("ERROR: Unsupported SPI bus: %d\n", port);
+		irqrestore(flags);
+		return NULL;
+	}
+
+	irqrestore(flags);
+
+	return (FAR struct spi_dev_s *)priv;
+}
diff --git a/os/arch/arm/src/amebad/amebad_spi.h b/os/arch/arm/src/amebad/amebad_spi.h
new file mode 100644
index 0000000000..9c41deb2bd
--- /dev/null
+++ b/os/arch/arm/src/amebad/amebad_spi.h
@@ -0,0 +1,140 @@
+/****************************************************************************
+ *
+ * Copyright 2021 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+#ifndef __ARCH_ARM_SRC_AMEBAD_SPI_H
+#define __ARCH_ARM_SRC_AMEBAD_SPI_H
+
+/************************************************************************************
+ * Included Files
+ ************************************************************************************/
+
+#include <tinyara/config.h>
+
+#include <stdbool.h>
+
+#include <tinyara/spi/spi.h>
+
+/********************************************************************************************
+ * Pre-processor Definitions
+ ********************************************************************************************/
+
+/************************************************************************************
+ * Public Functions
+ ************************************************************************************/
+
+#ifndef __ASSEMBLY__
+
+#undef EXTERN
+#if defined(__cplusplus)
+#define EXTERN extern "C"
+extern "C" {
+#else
+#define EXTERN extern
+#endif
+
+struct spi_dev_s; /* Forward reference */
+
+/************************************************************************************
+ * Name: amebad_spibus_initialize
+ *
+ * Description:
+ *   Initialize the selected SPI bus
+ *
+ * Input Parameters:
+ *   bus number (for hardware that has mutiple SPI interfaces)
+ *
+ * Returned Value:
+ *   Valid SPI device structure reference on succcess; a NULL on failure
+ *
+ ************************************************************************************/
+
+FAR struct spi_dev_s *amebad_spibus_initialize(int bus);
+
+/************************************************************************************
+ * Name:  amebad_spi1/2/...select and amebad_spi1/2/...status
+ *
+ * Description:
+ *   The external functions, amebad_spi1/2/...select, amebad_spi1/2/...status, and
+ *   amebad_spi1/2/...cmddata must be provided by board-specific logic.  These are
+ *   implementations of the select, status, and cmddata methods of the SPI interface
+ *   defined by struct spi_ops_s (see include/nuttx/spi/spi.h). All other methods
+ *   (including amebad_spibus_initialize()) are provided by common AMEBAD logic.  To use this
+ *   common SPI logic on your board:
+ *
+ *   1. Provide logic in amebad_boardinitialize() to configure SPI chip select
+ *      pins.
+ *   2. Provide amebad_spi1/2/...select() and amebad_spi1/2/...status() functions in your
+ *      board-specific logic.  These functions will perform chip selection and
+ *      status operations using GPIOs in the way your board is configured.
+ *   3. If CONFIG_SPI_CMDDATA is defined in your NuttX configuration file, then
+ *      provide amebad_spi1/2/...cmddata() functions in your board-specific logic.
+ *      These functions will perform cmd/data selection operations using GPIOs in the
+ *      way your board is configured.
+ *   4. Add a calls to amebad_spibus_initialize() in your low level application
+ *      initialization logic
+ *   5. The handle returned by amebad_spibus_initialize() may then be used to bind the
+ *      SPI driver to higher level logic (e.g., calling
+ *      mmcsd_spislotinitialize(), for example, will bind the SPI driver to
+ *      the SPI MMC/SD driver).
+ *
+ ************************************************************************************/
+
+void amebad_spi0select(FAR struct spi_dev_s *dev, enum spi_dev_e devid, bool selected);
+uint8_t amebad_spi0status(FAR struct spi_dev_s *dev, enum spi_dev_e devid);
+int amebad_spi0cmddata(FAR struct spi_dev_s *dev, uint32_t devid, bool cmd);
+
+void amebad_spi1select(FAR struct spi_dev_s *dev, enum spi_dev_e devid, bool selected);
+uint8_t amebad_spi1status(FAR struct spi_dev_s *dev, enum spi_dev_e devid);
+int amebad_spi1cmddata(FAR struct spi_dev_s *dev, uint32_t devid, bool cmd);
+
+/************************************************************************************
+ * Name: amebad_spi1/2/...register
+ *
+ * Description:
+ *   If the board supports a card detect callback to inform the SPI-based MMC/SD
+ *   driver when an SD card is inserted or removed, then CONFIG_SPI_CALLBACK should
+ *   be defined and the following function(s) must be implemented.  These functions
+ *   implements the registercallback method of the SPI interface (see
+ *   include/nuttx/spi/spi.h for details)
+ *
+ * Input Parameters:
+ *   dev -      Device-specific state data
+ *   callback - The function to call on the media change
+ *   arg -      A caller provided value to return with the callback
+ *
+ * Returned Value:
+ *   0 on success; negated errno on failure.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_SPI_CALLBACK
+int amebad_spi0register(FAR struct spi_dev_s *dev, spi_mediachange_t callback,
+			FAR void *arg);
+int amebad_spi1register(FAR struct spi_dev_s *dev, spi_mediachange_t callback,
+			FAR void *arg);
+
+#endif
+
+#undef EXTERN
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif /* __ARCH_ARM_SRC_AMEBAD_SPI_H */
+
diff --git a/os/board/rtl8721csm/src/Make.defs b/os/board/rtl8721csm/src/Make.defs
index a9f824baaa..f8328e635d 100644
--- a/os/board/rtl8721csm/src/Make.defs
+++ b/os/board/rtl8721csm/src/Make.defs
@@ -50,3 +50,4 @@
 ############################################################################
 
 CSRCS += rtl8721csm_boot.c
+CSRCS += rtl8721csm_i2schar.c
diff --git a/os/board/rtl8721csm/src/component/common/mbed/hal/i2c_api.h b/os/board/rtl8721csm/src/component/common/mbed/hal/i2c_api.h
index 14f2ebd3ea..72e750db40 100644
--- a/os/board/rtl8721csm/src/component/common/mbed/hal/i2c_api.h
+++ b/os/board/rtl8721csm/src/component/common/mbed/hal/i2c_api.h
@@ -137,7 +137,7 @@ void i2c_slave_address(i2c_t *obj, int idx, uint32_t address, uint32_t mask);
   * @param  stop: specifies whether a STOP is issued after all the bytes are received.
   * @retval : the length of data received. 
   */
-int i2c_read(i2c_t *obj, int address, char *data, int length, int stop);
+int rtk_i2c_read(i2c_t *obj, int address, char *data, int length, int stop);
 
 /**
   * @brief  I2C master write in poll mode.
@@ -148,7 +148,7 @@ int i2c_read(i2c_t *obj, int address, char *data, int length, int stop);
   * @param  stop: specifies whether a STOP is issued after all the bytes are sent.
   * @retval : the length of data send. 
   */
-int i2c_write(i2c_t *obj, int address, const char *data, int length, int stop);
+int rtk_i2c_write(i2c_t *obj, int address, const char *data, int length, int stop);
 
 /**
   * @brief  I2C slave read in poll mode.
diff --git a/os/board/rtl8721csm/src/component/common/mbed/targets/hal/rtl8721d/i2c_api.c b/os/board/rtl8721csm/src/component/common/mbed/targets/hal/rtl8721d/i2c_api.c
index ace117320f..0c9dc10c8f 100644
--- a/os/board/rtl8721csm/src/component/common/mbed/targets/hal/rtl8721d/i2c_api.c
+++ b/os/board/rtl8721csm/src/component/common/mbed/targets/hal/rtl8721d/i2c_api.c
@@ -460,7 +460,7 @@ int i2c_write_timeout(i2c_t *obj, int address, char *data, int length, int stop,
   * @param  stop: specifies whether a STOP is issued after all the bytes are received.
   * @retval the length of data received. 
   */
-int i2c_read(i2c_t *obj, int address, char *data, int length, int stop) 
+int rtk_i2c_read(i2c_t *obj, int address, char *data, int length, int stop)
 {
 	/* To avoid gcc warnings */
 	( void ) stop;
@@ -510,7 +510,7 @@ int i2c_read(i2c_t *obj, int address, char *data, int length, int stop)
   * @param  stop: specifies whether a STOP is issued after all the bytes are sent.
   * @retval the length of data send. 
   */
-int i2c_write(i2c_t *obj, int address, const char *data, int length, int stop) 
+int rtk_i2c_write(i2c_t *obj, int address, const char *data, int length, int stop)
 {
 	if (i2c_target_addr[obj->i2c_idx] != address) {
 		/* Deinit I2C first */
diff --git a/os/board/rtl8721csm/src/rtl8721csm_boot.c b/os/board/rtl8721csm/src/rtl8721csm_boot.c
index 80f5848f3e..69ca55afef 100644
--- a/os/board/rtl8721csm/src/rtl8721csm_boot.c
+++ b/os/board/rtl8721csm/src/rtl8721csm_boot.c
@@ -73,6 +73,8 @@
 #include <arch/board/board.h>
 #include "gpio_api.h"
 #include "timer_api.h"
+#include "amebad_i2c.h"
+#include "amebad_spi.h"
 #ifdef CONFIG_FLASH_PARTITION
 #include "common.h"
 #endif
@@ -84,6 +86,9 @@ extern FAR struct gpio_lowerhalf_s *amebad_gpio_lowerhalf(u32 pinname, u32 pinmo
 #ifdef CONFIG_PRODCONFIG
 extern u32 EFUSERead8(u32 CtrlSetting, u32 Addr, u8 *Data, u8 L25OutVoltage);
 #endif
+#if defined(CONFIG_AUDIO_I2SCHAR) && defined(CONFIG_AMEBAD_I2S)
+extern int i2schar_devinit(void);
+#endif
 
 /************************************************************************************
  * Private Functions
@@ -112,6 +117,48 @@ int up_check_proddownload(void)
 }
 #endif
 
+void board_i2s_initialize(void)
+{
+#if defined(CONFIG_AUDIO_I2SCHAR) && defined(CONFIG_AMEBAD_I2S)
+	i2schar_devinit();
+#endif
+}
+
+void board_spi_initialize(void)
+{
+#ifdef CONFIG_SPI
+	struct spi_dev_s *spi;
+	spi = up_spiinitialize(1);
+
+#ifdef CONFIG_SPI_USERIO
+	if (spi_uioregister(1, spi) < 0) {
+		lldbg("Failed to register SPI1\n");
+	}
+#endif
+#endif
+}
+
+void board_i2c_initialize(void)
+{
+#ifdef CONFIG_I2C
+	FAR struct i2c_dev_s *i2c;
+	int bus = 0;
+	int ret;
+	char path[16];
+
+	snprintf(path, sizeof(path), "/dev/i2c-%d", bus);
+	i2c = up_i2cinitialize(bus);
+#ifdef CONFIG_I2C_USERIO
+	if (i2c) {
+		ret = i2c_uioregister(path, i2c);
+		if (ret < 0) {
+			up_i2cuninitialize(i2c);
+		}
+	}
+#endif
+#endif
+}
+
 void board_gpio_initialize(void)
 {
 #ifdef CONFIG_GPIO
@@ -266,6 +313,9 @@ void board_initialize(void)
 	ipc_table_init();
 	amebad_mount_partions();
 	board_gpio_initialize();
+	board_i2c_initialize();
+	board_spi_initialize();
+	board_i2s_initialize();
 #ifdef CONFIG_WATCHDOG
 	amebad_wdg_initialize(CONFIG_WATCHDOG_DEVPATH, 5000);
 #endif
diff --git a/os/board/rtl8721csm/src/rtl8721csm_i2schar.c b/os/board/rtl8721csm/src/rtl8721csm_i2schar.c
new file mode 100644
index 0000000000..cd85cabf37
--- /dev/null
+++ b/os/board/rtl8721csm/src/rtl8721csm_i2schar.c
@@ -0,0 +1,99 @@
+/****************************************************************************
+ *
+ * Copyright 2021 Samsung Electronics All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+#include <tinyara/config.h>
+
+#include <sys/types.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <debug.h>
+
+#if defined(CONFIG_AUDIO_I2SCHAR) && defined(CONFIG_AMEBAD_I2S)
+
+#include <tinyara/audio/i2s.h>
+#include "amebad_i2s.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+#ifndef CONFIG_AMEBAD_I2SCHAR_MINOR
+#define CONFIG_AMEBAD_I2SCHAR_MINOR 0
+#endif
+/*****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+static void err_cb(FAR struct i2s_dev_s *dev, FAR void *arg, int flags)
+{
+/* Do something here */
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: i2schar_devinit
+ *
+ * Description:
+ *   All architectures must provide the following interface in order to
+ *   work with apps/examples/i2schar.
+ *
+ ****************************************************************************/
+
+int i2schar_devinit(void)
+{
+	static bool initialized;
+	struct i2s_dev_s *i2s;
+	int ret;
+
+	/* Have we already initialized? */
+
+	if (!initialized) {
+		/* Call amebad_i2s_initialize() to get an instance of the I2S interface */
+
+		i2s = amebad_i2s_initialize(0);
+		if (!i2s) {
+			lldbg("ERROR: Failed to get the AMEBAD I2S driver\n");
+			return -ENODEV;
+		}
+
+		/* Register the I2S character driver at "/dev/i2schar0" */
+
+		ret = i2schar_register(i2s, CONFIG_AMEBAD_I2SCHAR_MINOR);
+		if (ret < 0) {
+			lldbg("ERROR: i2schar_register failed: %d\n", ret);
+			return ret;
+		}
+
+		I2S_ERR_CB_REG(i2s, err_cb, "Error_Test_String");
+
+
+		/* Now we are initialized */
+
+		initialized = true;
+	}
+
+	return OK;
+}
+
+#endif							/* CONFIG_AUDIO_I2SCHAR && CONFIG_AMEBAD_I2S */
