diff --git a/os/arch/arm/src/amebasmart/Kconfig b/os/arch/arm/src/amebasmart/Kconfig
index e1a387451..d6e273385 100644
--- a/os/arch/arm/src/amebasmart/Kconfig
+++ b/os/arch/arm/src/amebasmart/Kconfig
@@ -130,26 +130,17 @@ config AMEBASMART_I2CTIMEOTICKS
 endif
 
 config AMEBASMART_I2S
-	bool "Enable Amebasmart I2S"
+	bool "Amebasmart I2S"
 	default n
 
 if AMEBASMART_I2S
-config AMEBASMART_I2S0
-	bool "I2S_0"
+config AMEBASMART_I2S2
+	bool "I2S_2"
 	default n
-if AMEBASMART_I2S0
-	config AMEBASMART_I2S0_MASTER
-	bool "I2S0_MASTER"
+config AMEBASMART_I2S3
+	bool "I2S_3"
 	default n
-endif
-config AMEBASMART_I2S1
-	bool "I2S_1"
-	default n
-if AMEBASMART_I2S1
-	config AMEBASMART_I2S1_MASTER
-	bool "I2S1_MASTER"
-	default n
-endif
+
 config AMEBASMART_I2S_RX
 	bool "Enable I2S RX"
 	default n
diff --git a/os/arch/arm/src/amebasmart/amebasmart_i2s.c b/os/arch/arm/src/amebasmart/amebasmart_i2s.c
index 4c1d68005..8704960ae 100644
--- a/os/arch/arm/src/amebasmart/amebasmart_i2s.c
+++ b/os/arch/arm/src/amebasmart/amebasmart_i2s.c
@@ -79,7 +79,7 @@
 
 /* Check for I2S TX support */
 #if defined(CONFIG_AMEBASMART_I2S_TX)
-#define I2S_HAVE_TX 	1
+#define I2S_HAVE_TX 1
 #endif
 
 #ifndef CONFIG_AMEBASMART_I2S_DATALEN
@@ -146,21 +146,27 @@ typedef struct {
 	i2s_bits_per_sample_t bits_per_sample; /*!< I2S bits per sample */
 
 	uint8_t channel_num;
-	uint8_t direction;
-
 } i2s_config_t;
 
-/* The state of the one I2S peripheral */
+/* I2S Device hardware configuration */
+struct amebasmart_i2s_config_s {
+	uint32_t i2s_mclk_pin;
+	uint32_t i2s_sclk_pin;
+	uint32_t i2s_ws_pin;
+	uint32_t i2s_sd_tx_pin;
+	uint32_t i2s_sd_rx_pin;
+
+	uint8_t i2s_idx;	/* I2S index*/
+	uint8_t rxenab : 1; /* True: RX transfers enabled */
+	uint8_t txenab : 1; /* True: TX transfers enabled */
+};
 
+/* The state of the one I2S peripheral */
 struct amebasmart_i2s_s {
 	struct i2s_dev_s dev; /* Externally visible I2S interface, must the first element!! */
 
 	i2s_t i2s_object;
-	uint32_t i2s_sclk_pin;
-	uint32_t i2s_ws_pin;
-	uint32_t i2s_sd_tx_pin;
-	uint32_t i2s_sd_rx_pin;
-	uint32_t i2s_mck_pin;
+	const struct amebasmart_i2s_config_s *config;	/* Port configuration */
 
 #if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
 	uint8_t i2s_tx_buf[(I2S_DMA_PAGE_NUM + 1) * I2S_DMA_PAGE_SIZE]__attribute__((aligned(64))); /* Allocate buffer for use in TX, must I2S_DMA_PAGE_NUM+1 for zero buffer */
@@ -168,12 +174,11 @@ struct amebasmart_i2s_s {
 #endif
 
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
-	uint8_t *i2s_rx_buf;
+	//uint8_t i2s_rx_buf[(I2S_DMA_PAGE_NUM + 1) * I2S_DMA_PAGE_SIZE]__attribute__((aligned(64))); /* Allocate buffer for use in RX, must I2S_DMA_PAGE_NUM+1 for zero buffer */
+	uint8_t* i2s_rx_buf;
 	i2s_irq_handler rx_isr_handler;
 #endif
 
-	uint8_t i2s_num; /* I2S controller register base address */
-
 	i2s_err_cb_t err_cb; /* registered error callback function */
 	void *err_cb_arg;	 /* argiment to return with err cb call */
 
@@ -200,8 +205,31 @@ struct amebasmart_i2s_s {
 	struct amebasmart_buffer_s *freelist_tx; /* A list a free buffer containers */
 	struct amebasmart_buffer_s containers_tx[I2S_DMA_PAGE_NUM];
 #endif
+};
 
+/* I2S device structures */
+static const struct amebasmart_i2s_config_s amebasmart_i2s2_config = {
+	.i2s_mclk_pin = PB_22,
+	.i2s_sclk_pin = PB_21,
+	.i2s_ws_pin = PA_16,
+	.i2s_sd_tx_pin = PB_10,
+	.i2s_sd_rx_pin = PB_19,
+
+	.i2s_idx = I2S_NUM_2,
+	.rxenab = 0,
+	.txenab = 1,
+};
 
+static const struct amebasmart_i2s_config_s amebasmart_i2s3_config = {
+	.i2s_mclk_pin = PA_15,
+	.i2s_sclk_pin = PA_14,
+	.i2s_ws_pin = PA_13,
+	.i2s_sd_tx_pin = PB_11,
+	.i2s_sd_rx_pin = PB_20,
+
+	.i2s_idx = I2S_NUM_3,
+	.rxenab = 1,
+	.txenab = 0,
 };
 
 /****************************************************************************
@@ -262,18 +290,13 @@ static void i2s_buf_tx_initialize(struct amebasmart_i2s_s *priv);
 static uint32_t i2s_rxdatawidth(struct i2s_dev_s *dev, int bits);
 
 static uint32_t i2s_samplerate(struct i2s_dev_s *dev, uint32_t rate);
-
 static uint32_t i2s_txdatawidth(struct i2s_dev_s *dev, int bits);
-
 static int i2s_stop_transfer(struct i2s_dev_s *dev, i2s_ch_dir_t dir);
-
 static int i2s_stop(struct i2s_dev_s *dev, i2s_ch_dir_t dir);
 static int i2s_pause(struct i2s_dev_s *dev, i2s_ch_dir_t dir);
 static int i2s_resume(struct i2s_dev_s *dev, i2s_ch_dir_t dir);
-
 static int i2s_receive(struct i2s_dev_s *dev, struct ap_buffer_s *apb, i2s_callback_t callback, void *arg, uint32_t timeout);
 static int i2s_send(struct i2s_dev_s *dev, struct ap_buffer_s *apb, i2s_callback_t callback, void *arg, uint32_t timeout);
-
 static int i2s_err_cb_register(struct i2s_dev_s *dev, i2s_err_cb_t cb, void *arg);
 
 /****************************************************************************
@@ -282,16 +305,10 @@ static int i2s_err_cb_register(struct i2s_dev_s *dev, i2s_err_cb_t cb, void *arg
 
 static const i2s_config_t i2s_default_config = {
 
-	.sample_rate = SR_48KHZ,
+	.sample_rate = SP_48K,
 	.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
 
-	.channel_num = CH_STEREO,
-#if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
-	.direction = I2S_DIR_TX,
-#endif
-#if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
-	.direction = I2S_DIR_RX,
-#endif
+	.channel_num = 2,
 };
 
 /* I2S device operations */
@@ -363,7 +380,7 @@ static void i2s_txdma_timeout(int argc, uint32_t arg)
 
 static int amebasmart_i2s_tx(struct amebasmart_i2s_s *priv, struct amebasmart_buffer_s *bfcontainer)
 {
-	int ret;
+	int ret = OK;
 	int *ptx_buf;
 	int tx_size;
 
@@ -375,9 +392,6 @@ static int amebasmart_i2s_tx(struct amebasmart_i2s_s *priv, struct amebasmart_bu
 		/* Add the container to the list of active DMAs */
 		sq_addlast((sq_entry_t *)bfcontainer, &priv->tx.act);
 
-		if (!priv->txenab) {	/* Checks tx has been enabled */
-			i2s_set_direction(&priv->i2s_object, I2S_DIR_TX);
-		}
 		priv->apb_tx = apb; /* Reference current TX apb in our I2S struct */
 							/* Start sending first page, after that the txdma callback will be called in the tx irq handler */
 		ptx_buf = i2s_get_tx_page(&priv->i2s_object);
@@ -391,9 +405,10 @@ static int amebasmart_i2s_tx(struct amebasmart_i2s_s *priv, struct amebasmart_bu
 		}
 		apb->curbyte += tx_size; /* No padding, ptx_buf is big enough to fill the whole tx_size */
 
+		i2s_enable(&priv->i2s_object);
 		i2s_send_page(&priv->i2s_object, (uint32_t *)ptx_buf);
 	}
-	return OK;
+	return ret;
 }
 
 static int i2s_tx_start(struct amebasmart_i2s_s *priv)
@@ -402,7 +417,7 @@ static int i2s_tx_start(struct amebasmart_i2s_s *priv)
 	int ret;
 	irqstate_t flags;
 
-	struct ap_buffer_s *apb;
+	//struct ap_buffer_s *apb;
 
 	/* Check if the DMA is IDLE */
 	if (!sq_empty(&priv->tx.act)) {
@@ -696,13 +711,11 @@ void i2s_transfer_tx_handleirq(void *data, char *pbuf)
 			memcpy((void *)ptx_buf, (void *)&priv->apb_tx->samp[priv->apb_tx->curbyte], I2S_DMA_PAGE_SIZE);
 		}
 		priv->apb_tx->curbyte += tx_size; /* No padding, ptx_buf is big enough to fill the whole tx_size */
-
 		i2s_send_page(&priv->i2s_object, (uint32_t *)ptx_buf);
 	}
 }
 
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
-
 /****************************************************************************
  * Name: i2s_rxdma_callback
  *
@@ -717,17 +730,14 @@ void i2s_transfer_tx_handleirq(void *data, char *pbuf)
  *   None
  *
  ****************************************************************************/
-
 static void i2s_rxdma_callback(struct amebasmart_i2s_s *priv, int result)
 {
 	DEBUGASSERT(priv != NULL);
 
 	/* Cancel the watchdog timeout */
-
 	(void)wd_cancel(priv->rx.dog);
 
 	/* Then schedule completion of the transfer to occur on the worker thread */
-
 	i2s_rx_schedule(priv, result);
 }
 
@@ -783,7 +793,6 @@ static int i2s_rx_start(struct amebasmart_i2s_s *priv)
 		/* Add the container to the list of active DMAs */
 		sq_addlast((sq_entry_t *)bfcontainer, &priv->rx.act);
 
-		i2s_set_direction(&priv->i2s_object, I2S_DIR_RX);
 		i2s_recv_page(&priv->i2s_object);
 	}
 	irqrestore(flags);
@@ -823,7 +832,6 @@ static void i2s_rx_worker(void *arg)
 	 * of the rx.done queue and rx.act queue will be emptied before this worker
 	 * is started.
 	 */
-
 	i2sinfo("rx.act.head=%p rx.done.head=%p\n", priv->rx.act.head, priv->rx.done.head);
 
 	/* Process each buffer in the rx.done queue */
@@ -832,20 +840,17 @@ static void i2s_rx_worker(void *arg)
 		 * interrupts must be disabled to do this because the rx.done queue is
 		 * also modified from the interrupt level.
 		 */
-
 		flags = irqsave();
 		bfcontainer = (struct amebasmart_buffer_s *)sq_remfirst(&priv->rx.done);
 		irqrestore(flags);
 
 		/* Perform the RX transfer done callback */
-
 		DEBUGASSERT(bfcontainer && bfcontainer->apb && bfcontainer->callback);
 		apb = bfcontainer->apb;
 
 		/* If the DMA was successful, then update the number of valid bytes in
 		 * the audio buffer.
 		 */
-
 		if (bfcontainer->result == OK) {
 			apb->nbytes = apb->nmaxbytes;
 		}
@@ -877,20 +882,15 @@ static void i2s_rx_schedule(struct amebasmart_i2s_s *priv, int result)
 	 * both indirectly via the amebasmart_dmastop() logic and directly via the
 	 * i2s_rxdma_timeout() logic.
 	 */
-
 	/* Move first entry from the rx.act queue to the rx.done queue */
-
 	if (!sq_empty(&priv->rx.act)) {
 		/* Remove the next buffer container from the rx.act list */
-
 		bfcontainer = (struct amebasmart_buffer_s *)sq_remfirst(&priv->rx.act);
 
 		/* Report the result of the transfer */
-
 		bfcontainer->result = result;
 
 		/* Add the completed buffer container to the tail of the rx.done queue */
-
 		sq_addlast((sq_entry_t *)bfcontainer, &priv->rx.done);
 	}
 
@@ -908,7 +908,6 @@ static void i2s_rx_schedule(struct amebasmart_i2s_s *priv, int result)
 	 */
 	if (work_available(&priv->rx.work)) {
 		/* Schedule the TX DMA done processing to occur on the worker thread. */
-
 		ret = work_queue(HPWORK, &priv->rx.work, i2s_rx_worker, priv, 0);
 		if (ret != 0) {
 			i2serr("ERROR: Failed to queue RX work: %d\n", ret);
@@ -932,7 +931,6 @@ static void i2s_rx_schedule(struct amebasmart_i2s_s *priv, int result)
  *   Returns the resulting bitrate
  *
  ****************************************************************************/
-
 static uint32_t i2s_rxdatawidth(struct i2s_dev_s *dev, int bits)
 {
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
@@ -986,7 +984,6 @@ static uint32_t i2s_rxdatawidth(struct i2s_dev_s *dev, int bits)
  *   failed.
  *
  ****************************************************************************/
-
 static int i2s_receive(struct i2s_dev_s *dev, struct ap_buffer_s *apb, i2s_callback_t callback, void *arg, uint32_t timeout)
 {
 	struct amebasmart_i2s_s *priv = (struct amebasmart_i2s_s *)dev;
@@ -1014,11 +1011,9 @@ static int i2s_receive(struct i2s_dev_s *dev, struct ap_buffer_s *apb, i2s_callb
 	i2sinfo("RX Exclusive Enter\n");
 
 	/* Add a reference to the audio buffer */
-
 	apb_reference(apb);
 
 	/* Initialize the buffer container structure */
-
 	bfcontainer->callback = (void *)callback;
 	bfcontainer->timeout = timeout;
 	bfcontainer->arg = arg;
@@ -1031,7 +1026,7 @@ static int i2s_receive(struct i2s_dev_s *dev, struct ap_buffer_s *apb, i2s_callb
 	flags = irqsave();
 	sq_addlast((sq_entry_t *)bfcontainer, &priv->rx.pend);
 	irqrestore(flags);
-	printf("i2s_rx_start\n");
+	i2sinfo("i2s_rx_start\n");
 	/* Start transfer */
 	ret = i2s_rx_start(priv);
 
@@ -1061,9 +1056,7 @@ void i2s_transfer_rx_handleirq(void *data, char *pbuf)
 	/* submit a new page for receive */
 	i2s_recv_page(obj);
 
-	int result = OK;
-
-	i2s_rxdma_callback(priv, result);
+	i2s_rxdma_callback(priv, OK);
 }
 
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
@@ -1080,7 +1073,6 @@ void i2s_transfer_rx_handleirq(void *data, char *pbuf)
  *  None
  *
  ****************************************************************************/
-
 static void i2s_bufsem_rx_take(struct amebasmart_i2s_s *priv)
 {
 	int ret;
@@ -1114,7 +1106,6 @@ static void i2s_bufsem_rx_take(struct amebasmart_i2s_s *priv)
  *   That would result in a deadlock!
  *
  ****************************************************************************/
-
 static struct amebasmart_buffer_s *i2s_buf_rx_allocate(struct amebasmart_i2s_s *priv)
 {
 	struct amebasmart_buffer_s *bfcontainer;
@@ -1154,7 +1145,6 @@ static struct amebasmart_buffer_s *i2s_buf_rx_allocate(struct amebasmart_i2s_s *
  *   The caller has exclusive access to the I2S state structure
  *
  ****************************************************************************/
-
 static void i2s_buf_rx_free(struct amebasmart_i2s_s *priv, struct amebasmart_buffer_s *bfcontainer)
 {
 	irqstate_t flags;
@@ -1187,7 +1177,6 @@ static void i2s_buf_rx_free(struct amebasmart_i2s_s *priv, struct amebasmart_buf
  *   concurrency.
  *
  ****************************************************************************/
-
 static void i2s_buf_rx_initialize(struct amebasmart_i2s_s *priv)
 {
 	int i;
@@ -1215,7 +1204,6 @@ static void i2s_buf_rx_initialize(struct amebasmart_i2s_s *priv)
  *  None
  *
  ****************************************************************************/
-
 static void i2s_bufsem_tx_take(struct amebasmart_i2s_s *priv)
 {
 	int ret;
@@ -1249,7 +1237,6 @@ static void i2s_bufsem_tx_take(struct amebasmart_i2s_s *priv)
  *   That would result in a deadlock!
  *
  ****************************************************************************/
-
 static struct amebasmart_buffer_s *i2s_buf_tx_allocate(struct amebasmart_i2s_s *priv)
 {
 	struct amebasmart_buffer_s *bfcontainer;
@@ -1289,7 +1276,6 @@ static struct amebasmart_buffer_s *i2s_buf_tx_allocate(struct amebasmart_i2s_s *
  *   The caller has exclusive access to the I2S state structure
  *
  ****************************************************************************/
-
 static void i2s_buf_tx_free(struct amebasmart_i2s_s *priv, struct amebasmart_buffer_s *bfcontainer)
 {
 	irqstate_t flags;
@@ -1322,7 +1308,6 @@ static void i2s_buf_tx_free(struct amebasmart_i2s_s *priv, struct amebasmart_buf
  *   concurrency.
  *
  ****************************************************************************/
-
 static void i2s_buf_tx_initialize(struct amebasmart_i2s_s *priv)
 {
 	int i;
@@ -1351,7 +1336,6 @@ static void i2s_buf_tx_initialize(struct amebasmart_i2s_s *priv)
  *  None
  *
  ****************************************************************************/
-
 static void i2s_exclsem_take(struct amebasmart_i2s_s *priv)
 {
 	int ret;
@@ -1387,13 +1371,13 @@ static int i2s_pause(struct i2s_dev_s *dev, i2s_ch_dir_t dir)
 
 #if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
 	if (dir == I2S_TX && priv->txenab) {
-		i2s_disable(&priv->i2s_object);
+		ameba_i2s_pause(&priv->i2s_object);
 	}
 #endif
 
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
 	if (dir == I2S_RX && priv->rxenab) {
-		i2s_disable(&priv->i2s_object);
+		ameba_i2s_pause(&priv->i2s_object);
 	}
 #endif
 
@@ -1421,13 +1405,13 @@ static int i2s_resume(struct i2s_dev_s *dev, i2s_ch_dir_t dir)
 
 #if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
 	if (dir == I2S_TX && priv->txenab) {
-		i2s_enable(&priv->i2s_object);
+		ameba_i2s_resume(&priv->i2s_object);
 	}
 #endif
 
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
 	if (dir == I2S_RX && priv->rxenab) {
-		i2s_enable(&priv->i2s_object);
+		ameba_i2s_resume(&priv->i2s_object);
 	}
 #endif
 
@@ -1455,13 +1439,13 @@ static int i2s_stop_transfer(struct i2s_dev_s *dev, i2s_ch_dir_t dir)
 
 #if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
 	if (dir == I2S_TX) {
-		i2s_disable(&priv->i2s_object);
+		ameba_i2s_pause(&priv->i2s_object);
 	}
 #endif
 
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
 	if (dir == I2S_RX) {
-		i2s_disable(&priv->i2s_object);
+		ameba_i2s_pause(&priv->i2s_object);
 	}
 #endif
 
@@ -1581,7 +1565,6 @@ static int i2s_err_cb_register(struct i2s_dev_s *dev, i2s_err_cb_t cb, void *arg
  ****************************************************************************/
 int amebasmart_i2s_isr_initialize(struct amebasmart_i2s_s *priv)
 {
-
 	/* Attach the GPIO peripheral to the allocated CPU interrupt */
 #if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
 	i2s_tx_irq_handler(&priv->i2s_object, (i2s_irq_handler)priv->tx_isr_handler, (uint32_t)priv);
@@ -1589,7 +1572,6 @@ int amebasmart_i2s_isr_initialize(struct amebasmart_i2s_s *priv)
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
 	i2s_rx_irq_handler(&priv->i2s_object, (i2s_irq_handler)priv->rx_isr_handler, (uint32_t)priv);
 #endif
-
 	return 0;
 }
 
@@ -1607,7 +1589,6 @@ int amebasmart_i2s_isr_initialize(struct amebasmart_i2s_s *priv)
  *   Returns the resulting bitrate
  *
  ****************************************************************************/
-
 static uint32_t i2s_samplerate(struct i2s_dev_s *dev, uint32_t rate)
 {
 	struct amebasmart_i2s_s *priv = (struct amebasmart_i2s_s *)dev;
@@ -1616,31 +1597,9 @@ static uint32_t i2s_samplerate(struct i2s_dev_s *dev, uint32_t rate)
 	priv->i2s_object.sampling_rate = rate;
 	priv->sample_rate = rate;
 
-	return priv->i2s_object.sampling_rate;
-}
+	i2s_set_param(&priv->i2s_object, priv->i2s_object.channel_num, priv->i2s_object.sampling_rate, priv->i2s_object.word_length);
 
-/****************************************************************************
- * Name: amebasmart_i2s_initpins
- *
- * Description:
- *   Set the I2S pins.
- *
- * Input Parameters:
- *   dev  - Device-specific state data
- *   	 - sclk Serial Clock
- *   	 - ws Word Select
- *   	 - sd_rx, sd_tx Serial Data rx tx
- *   	 - mck Master Clock
- *
- ****************************************************************************/
-
-static void amebasmart_i2s_initpins(struct amebasmart_i2s_s *priv)
-{
-	priv->i2s_sclk_pin = PB_21;
-	priv->i2s_ws_pin = PA_16;
-	priv->i2s_sd_tx_pin = PB_10;
-	priv->i2s_sd_rx_pin = PA_29;
-	priv->i2s_mck_pin = PB_22;
+	return priv->i2s_object.sampling_rate;
 }
 
 /****************************************************************************
@@ -1653,33 +1612,41 @@ static void amebasmart_i2s_initpins(struct amebasmart_i2s_s *priv)
  *   priv  - Device-specific private data
  *
  ****************************************************************************/
-
 static void i2s_getdefaultconfig(struct amebasmart_i2s_s *priv)
 {
-	priv->channel_num = (&i2s_default_config)->channel_num;
-	priv->i2s_object.channel_num = (&i2s_default_config)->channel_num;
-
-	priv->sample_rate = (&i2s_default_config)->sample_rate;
-	priv->i2s_object.sampling_rate = (&i2s_default_config)->sample_rate;
-
-	priv->i2s_object.direction = (&i2s_default_config)->direction;
-
-	priv->bits_per_sample = (&i2s_default_config)->bits_per_sample;
+	priv->i2s_object.i2s_idx = priv->config->i2s_idx;
+	priv->i2s_object.sampling_rate = i2s_default_config.sample_rate;
+	priv->sample_rate = priv->i2s_object.sampling_rate;
+	/* priv->i2s_object.clock = ; */
+	priv->i2s_object.channel_num = i2s_default_config.channel_num;
+	priv->channel_num = priv->i2s_object.channel_num;
+
+	priv->bits_per_sample = i2s_default_config.bits_per_sample;
 	if (priv->bits_per_sample == I2S_BITS_PER_SAMPLE_16BIT)
 		priv->i2s_object.word_length = WL_16b;
 	else if (priv->bits_per_sample == I2S_BITS_PER_SAMPLE_24BIT)
 		priv->i2s_object.word_length = WL_24b;
 	else if (priv->bits_per_sample == I2S_BITS_PER_SAMPLE_32BIT)
 		priv->i2s_object.word_length = WL_32b;
+	else
+		priv->i2s_object.word_length = WL_32b;
 
+	priv->rxenab = priv->config->rxenab;
+	if (priv->config->rxenab) {
+		priv->i2s_object.channel_length = SP_RXCL_32;
+		priv->i2s_object.fifo_num = SP_RX_FIFO2;
+		priv->i2s_object.direction = SP_DIR_RX;
+		priv->i2s_object.role = MASTER;
+	}
+	priv->txenab = priv->config->txenab;
+	if (priv->config->txenab) {
+		priv->i2s_object.channel_length = SP_TXCL_32;
+		priv->i2s_object.fifo_num = SP_TX_FIFO2;
+		priv->i2s_object.direction = SP_DIR_TX;
+		priv->i2s_object.role = MASTER;
+	}
 
-	priv->i2s_object.word_length = WL_16b;
-	priv->i2s_object.sampling_rate = SR_16KHZ;
-	priv->i2s_object.channel_length = CL_32b;
-	priv->i2s_object.direction = I2S_DIR_TX;
-	priv->i2s_object.role = MASTER;
-	priv->i2s_object.fifo_num = SP_TX_FIFO2;
-	/* priv->i2s_object.mode = MULTIIO;		//disable for now*/
+	priv->i2s_object.mode = MULTIIO;
 }
 
 /****************************************************************************
@@ -1692,7 +1659,6 @@ static void i2s_getdefaultconfig(struct amebasmart_i2s_s *priv)
  *   priv  - Device-specific private data
  *
  ****************************************************************************/
-
 static int i2s_allocate_wd(struct amebasmart_i2s_s *priv)
 {
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
@@ -1748,12 +1714,19 @@ errout:
  *   Valid i2s device structure reference on succcess; a NULL on failure
  *
  ****************************************************************************/
-
-
 struct i2s_dev_s *amebasmart_i2s_initialize(uint16_t port)
 {
-	if (port >= I2S_NUM_MAX) {
-		i2serr("ERROR: Port number outside the allowed port number range\n");
+	struct amebasmart_i2s_config_s *hw_config_s = NULL;
+	struct amebasmart_i2s_s *priv;
+	int ret;
+
+	/* Assign HW configuration */
+	if (port == I2S_NUM_2) {
+		hw_config_s = (struct amebasmart_i2s_config_s *)&amebasmart_i2s2_config;
+	} else if (port == I2S_NUM_3) {
+		hw_config_s = (struct amebasmart_i2s_config_s *)&amebasmart_i2s3_config;
+	} else {
+		i2serr("Please select I2S2 or I2S3 bus\n");
 		return NULL;
 	}
 
@@ -1761,40 +1734,33 @@ struct i2s_dev_s *amebasmart_i2s_initialize(uint16_t port)
 		return &g_i2sdevice[port]->dev;
 	}
 
-	struct amebasmart_i2s_s *priv;
-
-	int ret;
-
 	/* Allocate a new state structure for this chip select.  NOTE that there
 	 * is no protection if the same chip select is used in two different
 	 * chip select structures.
 	 */
 	priv = (struct amebasmart_i2s_s *)kmm_zalloc(sizeof(struct amebasmart_i2s_s));
-
 	if (!priv) {
 		i2serr("ERROR: Failed to allocate a chip select structure\n");
 		return NULL;
 	}
 
+	/* Config values initialization */
+	priv->config = hw_config_s;	/* Get HW configuation */
+
 	/* Get default configuration */
 	i2s_getdefaultconfig(priv);
 
-	/* Config values initialization */
-	amebasmart_i2s_initpins(priv);
-
 	/* Initialize buffering */
 #if defined(I2S_HAVE_RX) && (0 < I2S_HAVE_RX)
 	i2s_buf_rx_initialize(priv);
-	priv->rxenab = 1;
 #endif
 
 #if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
 	i2s_buf_tx_initialize(priv);
-	priv->txenab = 1;
 #endif
 
 	/* I2s object initialization */
-	i2s_init(&priv->i2s_object, priv->i2s_sclk_pin, priv->i2s_ws_pin, priv->i2s_sd_tx_pin, priv->i2s_sd_rx_pin, priv->i2s_mck_pin);
+	i2s_init(&priv->i2s_object, hw_config_s->i2s_sclk_pin, hw_config_s->i2s_ws_pin, hw_config_s->i2s_sd_tx_pin, hw_config_s->i2s_sd_rx_pin, hw_config_s->i2s_mclk_pin);
 
 	/* Initialize buffering */
 #if defined(I2S_HAVE_TX) && (0 < I2S_HAVE_TX)
@@ -1824,7 +1790,7 @@ struct i2s_dev_s *amebasmart_i2s_initialize(uint16_t port)
 		goto errout_with_alloc;
 	}
 	/* Basic settings */
-	priv->i2s_num = priv->i2s_object.i2s_idx;
+	//priv->i2s_num = priv->i2s_object.i2s_idx;
 	g_i2sdevice[port] = priv;
 
 	i2s_disable(&priv->i2s_object);
diff --git a/os/arch/arm/src/amebasmart/amebasmart_i2s.h b/os/arch/arm/src/amebasmart/amebasmart_i2s.h
index 4df37a595..030f866ad 100644
--- a/os/arch/arm/src/amebasmart/amebasmart_i2s.h
+++ b/os/arch/arm/src/amebasmart/amebasmart_i2s.h
@@ -52,7 +52,9 @@ extern "C" {
 */
 typedef enum {
 	I2S_NUM_0 = 0x0,			/*!< I2S 0 */
-	//I2S_NUM_1 = 0x1,			/*!< I2S 1 */
+	I2S_NUM_1 = 0x1,			/*!< I2S 1 */
+	I2S_NUM_2 = 0x2,			/*!< I2S 2 */
+	I2S_NUM_3 = 0x3,			/*!< I2S 3 */
 	I2S_NUM_MAX,
 } i2s_port_t;
 /**
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/README.md b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/README.md
index adb0400e8..c5f1c3b65 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/README.md
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/README.md
@@ -47,6 +47,27 @@ Please make sure your amplifier configurations are correctly set.
     #define AUDIO_HW_AMPLIFIER_MUTE_ENABLE  0
 ```
 
+If your amplifier is not controled by GPIO, and you need to add logic in our codes to avoid amplifier noise.
+Here is the time sequence of our playback:
+
+```
+    1. when create hal's render, ameba_audio_stream_render.c's API ameba_audio_stream_tx_sport_init will be called, in which bclk clock will be generated.
+    2. when create hal's render, ameba_audio_stream_tx_codec_init will be called after ameba_audio_stream_tx_sport_init,         ameba_audio_stream_tx_codec_init->ameba_audo_stream_tx_codec_configure->ameba_audio_stream_tx_set_amp_state(true), amplifier will be enabled.
+    3. if hal is in standby mode, and user write first data, hal will exit standby and call ameba_audio_stream_tx_set_amp_state(true), amplifier will be enabled.
+    4. if hal enters standby mode, ameba_audio_stream_tx_set_amp_state(false) will be called to disable amplifer.
+    5. when destroy hal's render, first hal enters standby mode, and disable amplifier, then ameba_audio_stream_render.c's API ameba_audio_stream_tx_close will be called, and bclk clock will stop output.
+```
+
+Here are the suggestions for you to add related codes:
+
+```
+    1. set ameba_audio_hw_usrcfg.h's AUDIO_HW_AMPLIFIER_MUTE_ENABLE as 1.
+    2. if you want to do some initialization work of amplifier, the codes can be added in ameba_audio_stream_render.c's API ameba_audio_stream_tx_init.
+       after line:ameba_audio_stream_tx_sport_init(&rstream, config, device);
+    3. in ameba_audio_stream_control.c's ameba_audio_ctl_set_amp_state, add amplifer enable, and disable implementations.
+    4. if you want to deinit amplifier, the codes can be added in ameba_audio_stream_render.c's API ameba_audio_stream_tx_close, before line:AUDIO_SP_Deinit.
+```
+
 ### I2S playback
 
 If you want to play with I2S, please change the following codes:
@@ -78,13 +99,33 @@ If you want to play with I2S, please change the following codes:
     #define AUDIO_I2S_OUT_MULTIIO_EN         0
 
     //if your external codec needs mclk from soc, and it's mclk should be mulitiplier of fs, set mulitiplier here.
-    #define AUDIO_HW_OUT_MCLK_MULITIPLIER   256
+    #define AUDIO_HW_OUT_MCLK_MULITIPLIER    256
 
     //if your external codec needs fixed mclk from soc, set it's max mclk here:
-    #define AUDIO_HW_OUT_FIXED_MCLK         20000000
+    #define AUDIO_HW_OUT_FIXED_MCLK          20000000
+
+    //attention: if you use PA13, PA14 for I2S, it may conflict with SWD, please call sys_jtag_off() to disable SWD in your application codes.
+```
+
+For I2S, if you need to add logic in our codes to avoid amplifier noise.
+Here is the time sequence of our playback:
 
+```
+    1. when create hal's render, ameba_audio_stream_render.c's API ameba_audio_stream_tx_sport_init will be called, in which bclk clock will be generated.
+    2. if hal is in standby mode, and user write first data, hal will exit standby and call ameba_audio_stream_tx_set_amp_state(true), amplifier will be enabled.
+    3. if hal enters standby mode, ameba_audio_stream_tx_set_amp_state(false) will be called to disable amplifer.
+    4. when destroy hal's render, first hal enters standby mode, and disable amplifier, then ameba_audio_stream_render.c's API ameba_audio_stream_tx_close will be called, and bclk clock will stop output.
 ```
 
+Here are the suggestions for you to add related codes:
+
+```
+    1. set ameba_audio_hw_usrcfg.h's AUDIO_HW_AMPLIFIER_MUTE_ENABLE as 1.
+    2. if you want to do some initialization work of amplifier, the codes can be added in ameba_audio_stream_render.c's API ameba_audio_stream_tx_init.
+       after line:ameba_audio_stream_tx_sport_init(&rstream, config, device);
+    3. in ameba_audio_stream_control.c's ameba_audio_ctl_set_amp_state, add amplifer enable, and disable implementations.
+    4. if you want to deinit amplifier, the codes can be added in ameba_audio_stream_render.c's API ameba_audio_stream_tx_close, before line:AUDIO_SP_Deinit.
+```
 ### internal record
 
 For audio record, the default setting is using amic.
@@ -105,6 +146,11 @@ If you want to use dmic, please set following configurations.
 If you want to record with I2S, please change the following codes:
 
 ```
+    //in your test code with RTAudioRecord, please set device as I2S:
+    RTAudioRecordConfig record_config;
+    ......
+    record_config.device = RTPIN_IN_I2S;
+
     component/usrcfg/rtl**/ameba_audio_hw_usrcfg.h
     //if your external codec needs mclk from soc, and it's mclk should be mulitiplier of fs, set 1 here.
     //if your external codec needs fixed mclk from soc, set 2 here.
@@ -133,4 +179,9 @@ If you want to record with I2S, please change the following codes:
     //if your external codec needs fixed mclk from soc, set it's max mclk here:
     #define AUDIO_HW_IN_FIXED_MCLK         20000000
 
+    //if your I2S in works in slave mode, set role as 1, otherwise set it as 0:
+    #define AUDIO_I2S_IN_ROLE              1
+
+    //attention: if you use PA13, PA14 for I2S, it may conflict with SWD, please call sys_jtag_off() to disable SWD in your application codes.
+
 ```
\ No newline at end of file
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream.h b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream.h
index a8ea00047..63e589ab4 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream.h
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream.h
@@ -63,6 +63,16 @@ enum {
 	SPORT3        = 12,
 };
 
+enum {
+	STATE_INVALID          = 0,
+	STATE_INITED           = 1,
+	STATE_XRUN             = 2,
+	STATE_XRUN_NOTIFIED    = 3,
+	STATE_STARTED          = 4,
+	STATE_STANDBY          = 5,
+	STATE_DEINITED         = 6,
+};
+
 typedef struct _GdmaCallbackData GdmaCallbackData;
 
 typedef struct _StreamConfig {
@@ -95,7 +105,11 @@ typedef struct _Stream {
 	uint32_t              sport_irq_count;
 	uint32_t              sport_compare_val;
 	uint64_t              total_counter_boundary;
+	uint64_t              start_atstamp;
+	uint64_t              total_dma_bytes;
 	bool                  extra_restart_by_user;
+	uint32_t              device;
+	int32_t               state;
 
 	// member below for channel <= 4
 	AudioBuffer          *rbuffer;
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_buffer.c b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_buffer.c
index 6178cd810..f62581ab8 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_buffer.c
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_buffer.c
@@ -83,10 +83,9 @@ size_t ameba_audio_stream_buffer_get_available_size(AudioBuffer *buffer)
 
 void ameba_audio_stream_buffer_flush(AudioBuffer *buffer)
 {
-	if (buffer && buffer->raw_data) {
-		HAL_AUDIO_INFO("flush audio rbuffer\n");
-		memset(buffer->raw_data, 0, buffer->capacity);
-	}
+	buffer->read_ptr = 0;
+	buffer->write_ptr = 0;
+	buffer->size_remain = 0;
 }
 
 /*write to buffer by hal*/
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_capture.c b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_capture.c
index e539b28c1..d51b14b17 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_capture.c
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_capture.c
@@ -48,7 +48,7 @@ static void ameba_audio_stream_rx_sport_init(CaptureStream **stream, StreamConfi
 	AUDIO_SP_StructInit(&cstream->stream.sp_initstruct);
 	cstream->stream.sp_initstruct.SP_SelI2SMonoStereo = ameba_audio_get_channel(config.channels);
 	cstream->stream.sp_initstruct.SP_SelWordLen = ameba_audio_get_sp_format(config.format, cstream->stream.direction);
-	cstream->stream.sp_initstruct.SP_SelTDM = ameba_audio_get_tdm(config.channels);
+	cstream->stream.sp_initstruct.SP_SelTDM = ameba_audio_get_sp_tdm(config.channels);
 	cstream->stream.sp_initstruct.SP_SelFIFO = ameba_audio_get_fifo_num(config.channels);
 	cstream->stream.sp_initstruct.SP_SR = ameba_audio_get_sp_rate(config.rate);
 	HAL_AUDIO_VERBOSE("selmo:%lu, wordlen:%lu, sr:%lu, seltdm:%lu, selfifo:%lu,",
@@ -92,7 +92,7 @@ static void ameba_audio_stream_rx_sport_init(CaptureStream **stream, StreamConfi
 		PLL_I2S_45P158M(ENABLE);
 		RCC_PeriphClockSource_SPORT(cstream->stream.sport_dev_num, CKSL_I2S_PLL45M);
 		PLL_I2S_Div(cstream->stream.sport_dev_num, Clock_Params.PLL_DIV);
-		PLL_I2S_45P158M_ClkTune(NULL, PLL_AUTO);
+		PLL_I2S_45P158M_ClkTune(0, PLL_AUTO);
 		clock_mode = PLL_CLOCK_45P1584M / Clock_Params.PLL_DIV;
 		break;
 
@@ -138,7 +138,7 @@ static void ameba_audio_stream_rx_sport_init(CaptureStream **stream, StreamConfi
 		}
 
 		if (AUDIO_I2S_IN_ROLE == AUDIO_I2S_SLAVE) {
-			AUDIO_SP_SetMasterSlave(cstream->stream.sport_dev_addr, SLAVE);
+			AUDIO_SP_SetMasterSlave(cstream->stream.sport_dev_num, SLAVE);
 		}
 	}
 }
@@ -151,6 +151,7 @@ static void ameba_audio_stream_rx_codec_adc_reset(void)
 		uint32_t adc_idx = ameba_audio_stream_get_adc_idx(idx);
 
 		AUDIO_CODEC_EnableADC(adc_chn_idx, DISABLE);
+		AUDIO_CODEC_EnableADCFifo(adc_chn_idx, DISABLE);
 		AUDIO_CODEC_SetADCHPF(idx, 3, DISABLE);
 		AUDIO_CODEC_SetADCMute(adc_idx, MUTE);
 		AUDIO_CODEC_SetADCMixMute(adc_idx, ANAAD, MUTE);
@@ -181,6 +182,7 @@ static void ameba_audio_stream_rx_adc_mic_configure(StreamConfig config)
 			uint32_t adc_idx = ameba_audio_stream_get_adc_idx(j);
 
 			AUDIO_CODEC_EnableADC(adc_chn_idx, ENABLE);
+			AUDIO_CODEC_EnableADCFifo(adc_chn_idx, ENABLE);
 			AUDIO_CODEC_SetADCHPF(adc_idx, 3, ENABLE);
 			AUDIO_CODEC_SetADCMute(adc_idx, dc->mute_for_adc[j - 1] ? MUTE : UNMUTE);
 			AUDIO_CODEC_SetADCVolume(adc_idx, dc->volume_for_adc[j - 1]);
@@ -197,6 +199,7 @@ static void ameba_audio_stream_rx_adc_mic_configure(StreamConfig config)
 				uint32_t adc_idx = ameba_audio_stream_get_adc_idx(k);
 
 				AUDIO_CODEC_EnableADC(adc_chn_idx, ENABLE);
+				AUDIO_CODEC_EnableADCFifo(adc_chn_idx, ENABLE);
 				AUDIO_CODEC_SetADCHPF(adc_idx, 3, ENABLE);
 				AUDIO_CODEC_SetADCMute(adc_idx, dc->mute_for_adc[k - 1] ? MUTE : UNMUTE);
 				AUDIO_CODEC_SetADCVolume(adc_idx, dc->volume_for_adc[k - 1]);
@@ -310,7 +313,7 @@ static void ameba_audio_stream_rx_codec_init(CaptureStream **stream, StreamConfi
 	ameba_audio_set_audio_ip_use_status(cstream->stream.direction, POWER, true);
 
 	AUDIO_CODEC_I2S_StructInit(&cstream->stream.i2s_initstruct);
-	cstream->stream.i2s_initstruct.CODEC_SelRxI2STdm = ameba_audio_get_tdm(config.channels);
+	cstream->stream.i2s_initstruct.CODEC_SelRxI2STdm = ameba_audio_get_codec_tdm(config.channels);
 	cstream->stream.i2s_initstruct.CODEC_SelI2SRxSR = ameba_audio_get_codec_rate(config.rate);
 
 	AUDIO_CODEC_SetI2SIP(I2S1, ENABLE);
@@ -395,6 +398,7 @@ int  ameba_audio_stream_rx_get_position(Stream *stream, uint64_t *captured_frame
 		return -1;
 	}
 
+	AUDIO_SP_SetPhaseLatch(cstream->stream.sport_dev_num);
 	delta_counter = AUDIO_SP_GetRXCounterVal(cstream->stream.sport_dev_num);
 	now_counter = cstream->stream.total_counter + delta_counter;
 
@@ -412,6 +416,36 @@ int  ameba_audio_stream_rx_get_position(Stream *stream, uint64_t *captured_frame
 	return 0;
 }
 
+int  ameba_audio_stream_rx_get_time(Stream *stream, int64_t *now_ns, int64_t *audio_ns)
+{
+	//now nsec;
+	uint64_t nsec;
+	//current total i2s counter of audio frames;
+	uint64_t now_counter = 0;
+	//means the delta_counter between now counter and last irq total counter.
+	uint32_t delta_counter = 0;
+
+	uint32_t phase = 0;
+
+	CaptureStream *cstream = (CaptureStream *)stream;
+	if (!cstream) {
+		return -1;
+	}
+
+	AUDIO_SP_SetPhaseLatch(cstream->stream.sport_dev_num);
+	delta_counter = AUDIO_SP_GetRXCounterVal(cstream->stream.sport_dev_num);
+	phase = AUDIO_SP_GetRXPhaseVal(cstream->stream.sport_dev_num);
+	now_counter = cstream->stream.total_counter + delta_counter;
+
+	//nsec will exceed at (2^64 / 50M / 3600 / 24 / 365 / 20 = 584 years)
+	nsec = ameba_audio_get_now_ns();
+
+	*now_ns = nsec;
+	*audio_ns = (int64_t)((double)((double)now_counter + (double)phase / (double)32) / (double)cstream->stream.config.rate * (double)1000000000);
+
+	return 0;
+}
+
 Stream *ameba_audio_stream_rx_init(uint32_t device, StreamConfig config)
 {
 	CaptureStream *cstream;
@@ -447,7 +481,7 @@ Stream *ameba_audio_stream_rx_init(uint32_t device, StreamConfig config)
 	ameba_audio_periphclock_init(cstream->stream.sport_dev_num);
 
 	if (!ameba_audio_is_audio_ip_in_use(SPORT0)) {
-		AUDIO_SP_Reset(cstream->stream.sport_dev_addr);
+		AUDIO_SP_Reset(cstream->stream.sport_dev_num);
 	}
 
 	/*configure sport according to the parameters*/
@@ -564,19 +598,12 @@ Stream *ameba_audio_stream_rx_init(uint32_t device, StreamConfig config)
 		cstream->stream.sport_compare_val *= 2;
 	}
 
-	if (device == AMEBA_AUDIO_IN_MIC) {
-		//enable sport interrupt
-		InterruptDis(SPORT1_IRQ);
-		InterruptUnRegister(SPORT1_IRQ);
-		InterruptRegister((IRQ_FUN)ameba_audio_stream_rx_sport_interrupt, SPORT1_IRQ, (uint32_t)cstream, 4);
-		InterruptEn(SPORT1_IRQ, 4);
-	} else if (device == AMEBA_AUDIO_IN_I2S) {
-		//enable sport interrupt
-		InterruptDis(SPORT2_IRQ);
-		InterruptUnRegister(SPORT2_IRQ);
-		InterruptRegister((IRQ_FUN)ameba_audio_stream_rx_sport_interrupt, SPORT2_IRQ, (uint32_t)cstream, 4);
-		InterruptEn(SPORT2_IRQ, 4);
-	}
+	uint32_t irq = ameba_audio_get_sport_irq(cstream->stream.sport_dev_num);
+	InterruptDis(irq);
+	InterruptUnRegister(irq);
+	InterruptRegister((IRQ_FUN)ameba_audio_stream_rx_sport_interrupt, irq, (uint32_t)cstream, 4);
+	InterruptEn(irq, 4);
+
 
 	ameba_audio_set_native_time();
 
@@ -614,6 +641,7 @@ uint32_t ameba_audio_stream_rx_complete(void *data)
 		if (ameba_audio_stream_buffer_get_available_size(cstream->stream.rbuffer) == 0) {
 			HAL_AUDIO_IRQ_INFO("buffer full, overrun(%lldns)", OsalGetSysTimeNs(OSAL_TIME_MONOTONIC));
 			cstream->stream.restart_by_user = true;
+			AUDIO_SP_SetPhaseLatch(cstream->stream.sport_dev_num);
 			cstream->stream.total_counter += AUDIO_SP_GetRXCounterVal(cstream->stream.sport_dev_num);
 			AUDIO_SP_SetRXCounter(cstream->stream.sport_dev_num, DISABLE);
 		} else {
@@ -625,6 +653,7 @@ uint32_t ameba_audio_stream_rx_complete(void *data)
 			} else {
 				HAL_AUDIO_IRQ_INFO("buffer near full, overrun(%lldns)", OsalGetSysTimeNs(OSAL_TIME_MONOTONIC));
 				cstream->stream.restart_by_user = true;
+				AUDIO_SP_SetPhaseLatch(cstream->stream.sport_dev_num);
 				cstream->stream.total_counter += AUDIO_SP_GetRXCounterVal(cstream->stream.sport_dev_num);
 				AUDIO_SP_SetRXCounter(cstream->stream.sport_dev_num, DISABLE);
 			}
@@ -650,6 +679,7 @@ uint32_t ameba_audio_stream_rx_complete(void *data)
 		if (ameba_audio_stream_buffer_get_available_size(cstream->stream.extra_rbuffer) == 0) {
 			HAL_AUDIO_IRQ_INFO("extra buffer full, overrun");
 			cstream->stream.extra_restart_by_user = true;
+			AUDIO_SP_SetPhaseLatch(cstream->stream.sport_dev_num);
 			cstream->stream.total_counter += AUDIO_SP_GetRXCounterVal(cstream->stream.sport_dev_num);
 			AUDIO_SP_SetRXCounter(cstream->stream.sport_dev_num, DISABLE);
 		} else {
@@ -661,6 +691,7 @@ uint32_t ameba_audio_stream_rx_complete(void *data)
 			} else {
 				HAL_AUDIO_IRQ_INFO("extra buffer near full, overrun(%lldns)", OsalGetSysTimeNs(OSAL_TIME_MONOTONIC));
 				cstream->stream.extra_restart_by_user = true;
+				AUDIO_SP_SetPhaseLatch(cstream->stream.sport_dev_num);
 				cstream->stream.total_counter += AUDIO_SP_GetRXCounterVal(cstream->stream.sport_dev_num);
 				AUDIO_SP_SetRXCounter(cstream->stream.sport_dev_num, DISABLE);
 			}
@@ -678,7 +709,7 @@ static void ameba_audio_stream_rx_start_in_noirq_mode(Stream *stream)
 	CaptureStream *cstream = (CaptureStream *)stream;
 	PGDMA_InitTypeDef sp_rxgdma_initstruct = &(cstream->stream.gdma_struct->u.SpRxGdmaInitStruct);
 
-	AUDIO_SP_DmaCmd(cstream->stream.sport_dev_addr, ENABLE);
+	AUDIO_SP_DmaCmd(cstream->stream.sport_dev_num, ENABLE);
 
 	if (!cstream->stream.start_gdma) {
 		cstream->stream.start_gdma = true;
@@ -689,7 +720,7 @@ static void ameba_audio_stream_rx_start_in_noirq_mode(Stream *stream)
 		HAL_AUDIO_INFO("gdma init: index:%d, chNum:%d", sp_rxgdma_initstruct->GDMA_Index,
 					   sp_rxgdma_initstruct->GDMA_ChNum);
 
-		AUDIO_SP_RXStart(cstream->stream.sport_dev_addr, ENABLE);
+		AUDIO_SP_RXStart(cstream->stream.sport_dev_num, ENABLE);
 
 	}
 }
@@ -699,7 +730,7 @@ static void ameba_audio_stream_rx_start_in_irq_mode(Stream *stream)
 	CaptureStream *cstream = (CaptureStream *)stream;
 	PGDMA_InitTypeDef sp_rxgdma_initstruct = &(cstream->stream.gdma_struct->u.SpRxGdmaInitStruct);
 
-	AUDIO_SP_DmaCmd(cstream->stream.sport_dev_addr, ENABLE);
+	AUDIO_SP_DmaCmd(cstream->stream.sport_dev_num, ENABLE);
 
 	cstream->stream.gdma_need_stop = false;
 
@@ -722,7 +753,7 @@ static void ameba_audio_stream_rx_start_in_irq_mode(Stream *stream)
 		}
 
 		HAL_AUDIO_VERBOSE("RX START AT:%lld", OsalGetSysTimeNs(OSAL_TIME_MONOTONIC));
-		AUDIO_SP_RXStart(cstream->stream.sport_dev_addr, ENABLE);
+		AUDIO_SP_RXStart(cstream->stream.sport_dev_num, ENABLE);
 
 		cstream->stream.start_gdma = true;
 	}
@@ -747,6 +778,7 @@ void ameba_audio_stream_rx_start(Stream *stream)
 	cstream->stream.sport_irq_count = 0;
 	AUDIO_SP_SetRXCounterCompVal(cstream->stream.sport_dev_num, cstream->stream.sport_compare_val);
 	AUDIO_SP_SetRXCounter(cstream->stream.sport_dev_num, ENABLE);
+	AUDIO_SP_SetPhaseLatch(cstream->stream.sport_dev_num);
 
 	if (cstream) {
 		if (cstream->stream.stream_mode) {
@@ -768,6 +800,7 @@ static void ameba_audio_stream_rx_check_and_start_gdma(CaptureStream *cstream)
 
 			AUDIO_SP_RXGDMA_Restart(sp_rxgdma_initstruct.GDMA_Index, sp_rxgdma_initstruct.GDMA_ChNum, rx_addr, bytes);
 			AUDIO_SP_SetRXCounter(cstream->stream.sport_dev_num, ENABLE);
+			AUDIO_SP_SetPhaseLatch(cstream->stream.sport_dev_num);
 			cstream->stream.gdma_cnt++;
 			cstream->stream.restart_by_user = false;
 		}
@@ -783,6 +816,7 @@ static void ameba_audio_stream_rx_check_and_start_gdma(CaptureStream *cstream)
 
 			AUDIO_SP_RXGDMA_Restart(extra_sp_rxgdma_initstruct.GDMA_Index, extra_sp_rxgdma_initstruct.GDMA_ChNum, extra_rx_addr, extra_bytes);
 			AUDIO_SP_SetRXCounter(cstream->stream.sport_dev_num, ENABLE);
+			AUDIO_SP_SetPhaseLatch(cstream->stream.sport_dev_num);
 			cstream->stream.extra_gdma_cnt++;
 			cstream->stream.extra_restart_by_user = false;
 		}
@@ -930,8 +964,8 @@ void ameba_audio_stream_rx_stop(Stream *stream)
 		cstream->stream.extra_sem_gdma_end_need_post = false;
 	}
 
-	AUDIO_SP_DmaCmd(cstream->stream.sport_dev_addr, DISABLE);
-	AUDIO_SP_RXStart(cstream->stream.sport_dev_addr, DISABLE);
+	AUDIO_SP_DmaCmd(cstream->stream.sport_dev_num, DISABLE);
+	AUDIO_SP_RXStart(cstream->stream.sport_dev_num, DISABLE);
 
 }
 
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_capture.h b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_capture.h
index 3e1f71fa2..25fb50563 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_capture.h
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_capture.h
@@ -32,6 +32,7 @@ void ameba_audio_stream_rx_stop(Stream *stream);
 int  ameba_audio_stream_rx_read(Stream *stream, void *data, uint32_t bytes);
 void ameba_audio_stream_rx_close(Stream *stream);
 int  ameba_audio_stream_rx_get_position(Stream *stream, uint64_t *captured_frames, struct timespec *tstamp);
+int  ameba_audio_stream_rx_get_time(Stream *stream, int64_t *now_ns, int64_t *audio_ns);
 
 #ifdef __cplusplus
 }
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_control.c b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_control.c
index 6fe995c76..65f550f9c 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_control.c
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_control.c
@@ -159,7 +159,7 @@ int32_t ameba_audio_ctl_get_tx_volume(StreamControl *control, float *left, float
 	return HAL_OSAL_OK;
 }
 
-int32_t ameba_audio_ctl_set_tx_mute(StreamControl *control, bool muted)
+int32_t ameba_audio_ctl_set_tx_mute(StreamControl *control, bool muted, bool should_zdet, bool user_set)
 {
 	if (control == NULL) {
 		HAL_AUDIO_ERROR("ops, %s fail, control null", __func__);
@@ -168,25 +168,30 @@ int32_t ameba_audio_ctl_set_tx_mute(StreamControl *control, bool muted)
 
 	if (ameba_audio_is_audio_ip_in_use(CODEC)) {
 		if (muted) {
-			HAL_AUDIO_INFO("dac mute.");
-			AUDIO_CODEC_SetDACVolume(DAC_L, 0);
-			AUDIO_CODEC_SetDACVolume(DAC_R, 0);
-			//max time wait: 175/44100ms
-			vTaskDelay(4 / portTICK_RATE_MS);
+			if (should_zdet) {
+				AUDIO_CODEC_SetDACVolume(DAC_L, 0);
+				AUDIO_CODEC_SetDACVolume(DAC_R, 0);
+				//max time wait: 175/44100ms
+				vTaskDelay(4 / portTICK_RATE_MS);
+			}
 			AUDIO_CODEC_SetDACMute(DAC_L, MUTE);
 			AUDIO_CODEC_SetDACMute(DAC_R, MUTE);
 		} else {
-			HAL_AUDIO_INFO("dac unmute.");
 			AUDIO_CODEC_SetDACMute(DAC_L, UNMUTE);
 			AUDIO_CODEC_SetDACMute(DAC_R, UNMUTE);
 			//no need to wait, because, we set volume here, and then data render
 			//to hardware, and hardware will itself fade in.
-			AUDIO_CODEC_SetDACVolume(DAC_L, control->volume_for_dacl);
-			AUDIO_CODEC_SetDACVolume(DAC_R, control->volume_for_dacr);
+			if (should_zdet) {
+				AUDIO_CODEC_SetDACVolume(DAC_L, control->volume_for_dacl);
+				AUDIO_CODEC_SetDACVolume(DAC_R, control->volume_for_dacr);
+			}
 		}
 	}
 
-	control->tx_state = muted;
+	if (user_set) {
+		control->tx_state = muted;
+	}
+
 	return HAL_OSAL_OK;
 }
 
@@ -501,20 +506,22 @@ int32_t ameba_audio_ctl_get_mic_bst_gain(StreamControl *control, uint32_t mic_ca
 	return control->gain_for_micbst[amic_num - 1];
 }
 
-int32_t ameba_audio_ctl_pll_clock_tune(StreamControl *control, uint32_t rate, uint32_t ppm, uint32_t action)
+float ameba_audio_ctl_pll_clock_tune(StreamControl *control, uint32_t rate, float ppm, uint32_t action)
 {
+	float tuned_ppm = 0;
+
 	if (control == NULL) {
 		HAL_AUDIO_ERROR("ops, %s fail, control null", __func__);
-		return HAL_OSAL_ERR_INVALID_OPERATION;
+		return 0;
 	}
 
 	if (rate % 8000 == 0) {
-		PLL_I2S_98P304M_ClkTune(ppm, action);
+		tuned_ppm = PLL_I2S_98P304M_ClkTune(ppm, action);
 	} else {
-		PLL_I2S_45P158M_ClkTune(ppm, action);
+		tuned_ppm = PLL_I2S_45P158M_ClkTune(ppm, action);
 	}
 
-	return HAL_OSAL_OK;
+	return tuned_ppm;
 }
 
 int32_t ameba_audio_ctl_set_adc_mute(StreamControl *control, uint32_t adc_num, bool muted)
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_control.h b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_control.h
index d3c25141d..16170bcec 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_control.h
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_control.h
@@ -47,7 +47,7 @@ int32_t ameba_audio_ctl_set_amp_pin(StreamControl *control, uint32_t pin);
 int32_t ameba_audio_ctl_get_amp_pin(StreamControl *control);
 int32_t ameba_audio_ctl_set_amp_state(StreamControl *control, bool state);
 bool ameba_audio_ctl_get_amp_state(StreamControl *control);
-int32_t ameba_audio_ctl_set_tx_mute(StreamControl *control, bool muted);
+int32_t ameba_audio_ctl_set_tx_mute(StreamControl *control, bool muted, bool should_zdet, bool user_set);
 bool ameba_audio_ctl_get_tx_mute(StreamControl *control);
 int32_t ameba_audio_ctl_set_device_category(StreamControl *control, uint32_t device_category);
 int32_t ameba_audio_ctl_get_device_category(StreamControl *control);
@@ -62,7 +62,7 @@ int32_t ameba_audio_ctl_set_mic_bst_gain(StreamControl *control, uint32_t mic_ca
 int32_t ameba_audio_ctl_get_mic_bst_gain(StreamControl *control, uint32_t mic_category);
 int32_t ameba_audio_ctl_set_mic_usage(StreamControl *control, uint32_t mic_usage);
 int32_t ameba_audio_ctl_get_mic_usage(StreamControl *control);
-int32_t ameba_audio_ctl_pll_clock_tune(StreamControl *control, uint32_t rate, uint32_t ppm, uint32_t action);
+float ameba_audio_ctl_pll_clock_tune(StreamControl *control, uint32_t rate, float ppm, uint32_t action);
 
 #ifdef __cplusplus
 }
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_render.c b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_render.c
index 40b22c931..17397f639 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_render.c
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_render.c
@@ -26,6 +26,7 @@
 #include "ameba_soc.h"
 #include "ameba_rcc.h"
 #include "audio_hw_debug.h"
+#include "audio_hw_osal_errnos.h"
 #include "osal_c/osal_time.h"
 #include "platform_stdlib.h"
 
@@ -33,6 +34,12 @@ extern void PLL_I2S_24P576M(u32 NewState);
 extern void AUDIO_SP_SetMclk(u32 index, u32 NewState);
 extern void AUDIO_SP_SetMclkDiv(u32 index, u32 mck_div);
 
+#define DEBUG_FRAMES  0
+#if DEBUG_FRAMES
+static uint64_t s_counter_frames = 0;
+static uint64_t s_dma_frames = 0;
+#endif
+
 int ameba_audio_stream_tx_set_amp_state(bool state)
 {
 	StreamControl *control = ameba_audio_get_ctl();
@@ -85,6 +92,7 @@ uint64_t ameba_audio_stream_tx_sport_rendered_frames(Stream *stream)
 		return -1;
 	}
 
+	AUDIO_SP_SetPhaseLatch(rstream->stream.sport_dev_num);
 	counter = AUDIO_SP_GetTXCounterVal(rstream->stream.sport_dev_num);
 	total_counter = counter + (uint64_t)rstream->stream.sport_irq_count * rstream->stream.sport_compare_val;
 
@@ -103,6 +111,7 @@ static uint64_t ameba_audio_stream_tx_get_counter_ntime(RenderStream *rstream)
 		return -1;
 	}
 
+	AUDIO_SP_SetPhaseLatch(rstream->stream.sport_dev_num);
 	delta_counter = AUDIO_SP_GetTXCounterVal(rstream->stream.sport_dev_num);
 	now_counter = rstream->stream.total_counter + delta_counter;
 
@@ -150,15 +159,40 @@ int  ameba_audio_stream_tx_get_position(Stream *stream, uint64_t *rendered_frame
 	//means the delta_counter between now counter and last irq total counter.
 	uint32_t delta_counter = 0;
 
+	uint64_t ratio_ns = 0;
+
 	RenderStream *rstream = (RenderStream *)stream;
 	if (!rstream) {
 		return -1;
 	}
 
-	delta_counter = AUDIO_SP_GetTXCounterVal(rstream->stream.sport_dev_num);
-	now_counter = rstream->stream.total_counter + delta_counter;
+	PGDMA_InitTypeDef sp_txgdma_initstruct = &(rstream->stream.gdma_struct->u.SpTxGdmaInitStruct);
 
-	*rendered_frames = now_counter;
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_COUNTER || DEBUG_FRAMES) {
+		AUDIO_SP_SetPhaseLatch(rstream->stream.sport_dev_num);
+		delta_counter = AUDIO_SP_GetTXCounterVal(rstream->stream.sport_dev_num);
+		now_counter = rstream->stream.total_counter + delta_counter;
+#if DEBUG_FRAMES
+		s_counter_frames = now_counter;
+#else
+		*rendered_frames = now_counter;
+#endif
+	}
+
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_DMA || DEBUG_FRAMES) {
+#if DEBUG_FRAMES
+		s_dma_frames = (rstream->stream.total_dma_bytes +
+						GDMA_GetBlkSize(sp_txgdma_initstruct->GDMA_Index, sp_txgdma_initstruct->GDMA_ChNum)) / rstream->stream.frame_size;
+#else
+		*rendered_frames = (rstream->stream.total_dma_bytes +
+							GDMA_GetBlkSize(sp_txgdma_initstruct->GDMA_Index, sp_txgdma_initstruct->GDMA_ChNum)) / rstream->stream.frame_size;
+#endif
+	}
+
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_RATIO) {
+		ratio_ns = (OsalGetAudioClockTimeNs(OSAL_TIME_MONOTONIC, OSAL_AUDIO_CLOCK_1) - rstream->stream.start_atstamp);
+		*rendered_frames =  ratio_ns * rstream->stream.rate / 1000000000LL;
+	}
 
 	//tv_sec is lld, tv_nsec is ld
 	//nsec will exceed at (2^64 / 50M / 3600 / 24 / 365 / 20 = 584 years)
@@ -169,6 +203,46 @@ int  ameba_audio_stream_tx_get_position(Stream *stream, uint64_t *rendered_frame
 	HAL_AUDIO_PVERBOSE("rendered_frames:%" PRIu64 ", trigger:%" PRIu64 ", usec:%" PRIu64 ", tv_sec:%" PRIu64 ", tv_nsec:%" PRIu32 "",
 					   *rendered_frames, rstream->stream.trigger_tstamp, nsec, tstamp->tv_sec, tstamp->tv_nsec);
 
+#if DEBUG_FRAMES
+	if (rstream->write_cnt % 2000 == 0) {
+		HAL_AUDIO_DEBUG("counter frames:%llu, dma frames:%llu, ratio frames:%llu, ratio ns:%llu", s_counter_frames, s_dma_frames, *rendered_frames, ratio_ns);
+	}
+#endif
+
+	return 0;
+}
+
+int  ameba_audio_stream_tx_get_time(Stream *stream, int64_t *now_ns, int64_t *audio_ns)
+{
+	//now nsec;
+	uint64_t nsec;
+	//current total i2s counter of audio frames;
+	uint64_t now_counter = 0;
+	//means the delta_counter between now counter and last irq total counter.
+	uint32_t delta_counter = 0;
+
+	uint32_t phase = 0;
+
+	RenderStream *rstream = (RenderStream *)stream;
+	if (!rstream) {
+		return -1;
+	}
+
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_COUNTER) {
+		AUDIO_SP_SetPhaseLatch(rstream->stream.sport_dev_num);
+		delta_counter = AUDIO_SP_GetTXCounterVal(rstream->stream.sport_dev_num);
+		phase = AUDIO_SP_GetTXPhaseVal(rstream->stream.sport_dev_num);
+		now_counter = rstream->stream.total_counter + delta_counter;
+	} else {
+		HAL_AUDIO_ERROR("not supported tstamp type(%d) now.", AUDIO_OUT_TSTAMP_TYPE);
+	}
+
+	//nsec will exceed at (2^64 / 50M / 3600 / 24 / 365 / 20 = 584 years)
+	nsec = ameba_audio_get_now_ns();
+
+	*now_ns = nsec;
+	*audio_ns = (int64_t)((double)((double)now_counter + (double)phase / (double)32) / (double)rstream->stream.config.rate * (double)1000000000);
+
 	return 0;
 }
 
@@ -180,8 +254,9 @@ static void ameba_audo_stream_tx_codec_configure(uint32_t i2s, uint32_t type, ui
 
 	AUDIO_CODEC_SetDACSRSrc(SOURCE0, i2s_initstruct->CODEC_SelI2STxSR);
 	AUDIO_CODEC_EnableDAC(DAC_L, ENABLE);
+	AUDIO_CODEC_EnableDACFifo(ENABLE);
 	AUDIO_CODEC_SetDACHPF(DAC_L, ENABLE);
-	AUDIO_CODEC_SetDACMute(DAC_L, UNMUTE);
+	AUDIO_CODEC_SetDACMute(DAC_L, ameba_audio_get_ctl()->tx_state);
 	AUDIO_CODEC_SetDACSrc(i2s, I2SL, I2SR);
 
 	//for I2S PLL case
@@ -191,8 +266,9 @@ static void ameba_audo_stream_tx_codec_configure(uint32_t i2s, uint32_t type, ui
 
 	if (channels == 2) {
 		AUDIO_CODEC_EnableDAC(DAC_R, ENABLE);
+		AUDIO_CODEC_EnableDACFifo(ENABLE);
 		AUDIO_CODEC_SetDACHPF(DAC_R, ENABLE);
-		AUDIO_CODEC_SetDACMute(DAC_R, UNMUTE);
+		AUDIO_CODEC_SetDACMute(DAC_R, ameba_audio_get_ctl()->tx_state);
 	}
 
 	//5V power supply, the gain is set to 0X86 by default, otherwise clipping;
@@ -265,7 +341,7 @@ static void ameba_audio_stream_tx_sport_init(RenderStream **stream, StreamConfig
 	rstream->stream.sp_initstruct.SP_SelI2SMonoStereo = ameba_audio_get_channel(config.channels);
 	rstream->stream.sp_initstruct.SP_SelWordLen = ameba_audio_get_sp_format(config.format, rstream->stream.direction);
 	rstream->stream.sp_initstruct.SP_SR = ameba_audio_get_sp_rate(config.rate);
-	rstream->stream.sp_initstruct.SP_SelTDM = ameba_audio_get_tdm(config.channels);
+	rstream->stream.sp_initstruct.SP_SelTDM = ameba_audio_get_sp_tdm(config.channels);
 	rstream->stream.sp_initstruct.SP_SelFIFO = ameba_audio_get_fifo_num(config.channels);
 	HAL_AUDIO_VERBOSE("selmo:%lu, wordlen:%lu, sr:%lu, seltdm:%lu, selfifo:%lu,",
 					  rstream->stream.sp_initstruct.SP_SelI2SMonoStereo,
@@ -308,7 +384,7 @@ static void ameba_audio_stream_tx_sport_init(RenderStream **stream, StreamConfig
 		PLL_I2S_45P158M(ENABLE);
 		RCC_PeriphClockSource_SPORT(rstream->stream.sport_dev_num, CKSL_I2S_PLL45M);
 		PLL_I2S_Div(rstream->stream.sport_dev_num, Clock_Params.PLL_DIV);
-		PLL_I2S_45P158M_ClkTune(NULL, PLL_AUTO);
+		PLL_I2S_45P158M_ClkTune(0, PLL_AUTO);
 		clock_mode = PLL_CLOCK_45P1584M / Clock_Params.PLL_DIV;
 		break;
 
@@ -353,7 +429,7 @@ static void ameba_audio_stream_tx_sport_init(RenderStream **stream, StreamConfig
 			AUDIO_SP_SetMclkDiv(rstream->stream.sport_dev_num, mck_div);
 		}
 
-		AUDIO_SP_SetMasterSlave(rstream->stream.sport_dev_addr, MASTER);
+		AUDIO_SP_SetMasterSlave(rstream->stream.sport_dev_num, MASTER);
 	}
 }
 
@@ -429,6 +505,8 @@ Stream *ameba_audio_stream_tx_init(uint32_t device, StreamConfig config)
 	rstream->write_cnt = 0;
 	rstream->stream.config = config;
 	rstream->stream.direction = STREAM_OUT;
+	rstream->stream.device = device;
+
 	if (device == AMEBA_AUDIO_DEVICE_I2S) {
 		rstream->stream.sport_dev_num = AUDIO_I2S_OUT_SPORT_INDEX;
 		if (AUDIO_I2S_OUT_NEED_MCLK_OUT) {
@@ -450,7 +528,7 @@ Stream *ameba_audio_stream_tx_init(uint32_t device, StreamConfig config)
 	ameba_audio_periphclock_init(rstream->stream.sport_dev_num);
 
 	if (!ameba_audio_is_audio_ip_in_use(SPORT0)) {
-		AUDIO_SP_Reset(rstream->stream.sport_dev_addr);
+		AUDIO_SP_Reset(rstream->stream.sport_dev_num);
 	}
 
 	/*configure sport according to the parameters*/
@@ -506,7 +584,6 @@ Stream *ameba_audio_stream_tx_init(uint32_t device, StreamConfig config)
 
 	rstream->stream.start_gdma = false;
 	rstream->stream.gdma_need_stop = false;
-	rstream->stream.restart_by_user = false;
 	rstream->stream.frame_size = config.frame_size * rstream->stream.channel / config.channels;
 	rstream->stream.gdma_cnt = 0;
 	rstream->stream.gdma_irq_cnt = 0;
@@ -524,7 +601,6 @@ Stream *ameba_audio_stream_tx_init(uint32_t device, StreamConfig config)
 	rtw_init_sema(&rstream->stream.sem_gdma_end, 0);
 
 	rstream->stream.extra_gdma_struct = NULL;
-	rstream->stream.extra_restart_by_user = false;
 	rstream->stream.extra_frame_size = config.frame_size * rstream->stream.extra_channel / config.channels;
 	rstream->stream.extra_gdma_cnt = 0;
 	rstream->stream.extra_gdma_irq_cnt = 0;
@@ -545,10 +621,13 @@ Stream *ameba_audio_stream_tx_init(uint32_t device, StreamConfig config)
 	}
 
 	rstream->stream.trigger_tstamp = 0;
+	rstream->stream.start_atstamp = 0;
+	rstream->stream.total_dma_bytes = 0;
 	rstream->stream.total_counter = 0;
 	rstream->stream.sport_irq_count = 0;
 	rstream->stream.sport_compare_val = config.period_size * config.period_count;
 	rstream->stream.total_counter_boundary = UINT64_MAX;
+	rstream->total_written_from_tx_start = 0;
 
 	while (rstream->stream.sport_compare_val * 2 <= AUDIO_HW_MAX_SPORT_IRQ_X) {
 		rstream->stream.sport_compare_val *= 2;
@@ -565,14 +644,19 @@ Stream *ameba_audio_stream_tx_init(uint32_t device, StreamConfig config)
 		ameba_audio_stream_tx_llp_init(&rstream->stream);
 	}
 
-	//enable sport interrupt
-	InterruptDis(SPORT0_IRQ);
-	InterruptUnRegister(SPORT0_IRQ);
-	InterruptRegister((IRQ_FUN)ameba_audio_stream_tx_sport_interrupt, SPORT0_IRQ, (uint32_t)rstream, 4);
-	InterruptEn(SPORT0_IRQ, 4);
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_COUNTER || DEBUG_FRAMES) {
+		//enable sport interrupt
+		uint32_t irq = ameba_audio_get_sport_irq(rstream->stream.sport_dev_num);
+		InterruptDis(irq);
+		InterruptUnRegister(irq);
+		InterruptRegister((IRQ_FUN)ameba_audio_stream_tx_sport_interrupt, irq, (uint32_t)rstream, 4);
+		InterruptEn(irq, 4);
+	}
 
 	ameba_audio_set_native_time();
 
+	rstream->stream.state = STATE_INITED;
+
 	return &rstream->stream;
 }
 
@@ -595,36 +679,105 @@ uint32_t ameba_audio_stream_tx_get_buffer_status(Stream *stream)
 	return remain;
 }
 
-void ameba_audio_stream_tx_start(Stream *stream)
+void ameba_audio_stream_tx_start(Stream *stream, int32_t state)
 {
 	RenderStream *rstream = (RenderStream *)stream;
 
+	if (state == rstream->stream.state) {
+		return;
+	}
+
+	ameba_audio_ctl_set_tx_mute(ameba_audio_get_ctl(), ameba_audio_get_ctl()->tx_state, true, false);
+
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_COUNTER || DEBUG_FRAMES) {
+		AUDIO_SP_SetTXCounterCompVal(rstream->stream.sport_dev_num, rstream->stream.sport_compare_val);
+	}
+
+	AUDIO_SP_TXSetFifo(rstream->stream.sport_dev_num, rstream->stream.sp_initstruct.SP_SelFIFO, ENABLE);
+
+	if (rstream->stream.device == AMEBA_AUDIO_DEVICE_SPEAKER || rstream->stream.device == AMEBA_AUDIO_DEVICE_HEADPHONE) {
+		AUDIO_CODEC_EnableDACFifo(ENABLE);
+	}
+
+	AUDIO_SP_DmaCmd(rstream->stream.sport_dev_num, ENABLE);
+
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_COUNTER || DEBUG_FRAMES) {
+		AUDIO_SP_SetPhaseLatch(rstream->stream.sport_dev_num);
+		AUDIO_SP_SetTXCounter(rstream->stream.sport_dev_num, ENABLE);
+	}
+
+	AUDIO_SP_TXStart(rstream->stream.sport_dev_num, ENABLE);
+
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_RATIO) {
+		rstream->stream.start_atstamp = OsalGetAudioClockTimeNs(OSAL_TIME_MONOTONIC, OSAL_AUDIO_CLOCK_1);
+	}
+
 	rstream->stream.trigger_tstamp = ameba_audio_get_now_ns();
 	rstream->stream.total_counter = 0;
 	rstream->stream.sport_irq_count = 0;
 	rstream->stream.gdma_need_stop = false;
+	//should not set zero here, because when user write data after xrun, it may not up to start threhold bytes.
+	//rstream->total_written_from_tx_start = 0;
 
-	ameba_audio_ctl_set_tx_mute(ameba_audio_get_ctl(), false);
-	if (AUDIO_HW_AMPLIFIER_MUTE_ENABLE) {
-		ameba_audio_stream_tx_set_amp_state(true);
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_DMA || DEBUG_FRAMES) {
+		rstream->stream.total_dma_bytes = 0;
 	}
 
-	HAL_AUDIO_VERBOSE("TX START AT:%lld", OsalGetSysTimeNs(OSAL_TIME_MONOTONIC));
-	AUDIO_SP_DmaCmd(rstream->stream.sport_dev_addr, ENABLE);
-	AUDIO_SP_TXStart(rstream->stream.sport_dev_addr, ENABLE);
+	rstream->stream.state = state;
 
-	AUDIO_SP_SetTXCounterCompVal(rstream->stream.sport_dev_num, rstream->stream.sport_compare_val);
 }
 
-void ameba_audio_stream_tx_stop(Stream *stream)
+void ameba_audio_stream_tx_stop(Stream *stream, int32_t state)
 {
 	RenderStream *rstream = (RenderStream *)stream;
 
-	if (AUDIO_HW_AMPLIFIER_MUTE_ENABLE) {
-		ameba_audio_stream_tx_set_amp_state(false);
+	//if xrun happens, and fifo should be flushed, if directly flushed, may cause more pop noise than xrun itself.
+	//for example, if xrun happens when data is on high level, it will remain in this high level until xrun disappear.
+	//but if directly flused, data will directly change to 0, which will cause bigger noise.
+	//we need to add mute for this case, and should not add zdet here, because it will takes more time.
+	//If mute first, the data will stay on it's high level, only mute function will work.
+	bool should_mute_zdet = state == STATE_XRUN ? false : true;
+
+	if (state == rstream->stream.state) {
+		return;
+	}
+
+	ameba_audio_ctl_set_tx_mute(ameba_audio_get_ctl(), true, should_mute_zdet, false);
+
+	AUDIO_SP_DmaCmd(rstream->stream.sport_dev_num, DISABLE);
+	AUDIO_SP_TXStart(rstream->stream.sport_dev_num, DISABLE);
+
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_COUNTER || DEBUG_FRAMES) {
+		AUDIO_SP_SetTXCounter(rstream->stream.sport_dev_num, DISABLE);
+		AUDIO_SP_TXSetFifo(rstream->stream.sport_dev_num, rstream->stream.sp_initstruct.SP_SelFIFO, DISABLE);
 	}
-	ameba_audio_ctl_set_tx_mute(ameba_audio_get_ctl(), true);
 
+	if (rstream->stream.device == AMEBA_AUDIO_DEVICE_SPEAKER || rstream->stream.device == AMEBA_AUDIO_DEVICE_HEADPHONE) {
+		//flush codec fifo
+		AUDIO_CODEC_EnableDACFifo(DISABLE);
+	}
+
+	rstream->stream.trigger_tstamp = ameba_audio_get_now_ns();
+	rstream->stream.total_counter = 0;
+	rstream->stream.sport_irq_count = 0;
+	rstream->total_written_from_tx_start = 0;
+
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_RATIO) {
+		rstream->stream.start_atstamp = 0;
+	}
+
+	if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_DMA || DEBUG_FRAMES) {
+		rstream->stream.total_dma_bytes = 0;
+	}
+
+	ameba_audio_stream_tx_buffer_flush(stream);
+	rstream->stream.state = state;
+
+}
+
+void ameba_audio_stream_tx_standby(Stream *stream)
+{
+	RenderStream *rstream = (RenderStream *)stream;
 	rstream->stream.gdma_need_stop = true;
 
 	if (rstream->stream.gdma_cnt != rstream->stream.gdma_irq_cnt) {
@@ -638,18 +791,7 @@ void ameba_audio_stream_tx_stop(Stream *stream)
 		rstream->stream.extra_sem_gdma_end_need_post = false;
 	}
 
-	rstream->stream.trigger_tstamp = ameba_audio_get_now_ns();
-	rstream->stream.total_counter = 0;
-	rstream->stream.sport_irq_count = 0;
-
-	HAL_AUDIO_PVERBOSE("stream_tx_stop sport(%" PRId32 ") at:%" PRIu64 "\n", rstream->stream.sport_dev_num, rstream->stream.trigger_tstamp);
-	AUDIO_SP_DmaCmd(rstream->stream.sport_dev_addr, DISABLE);
-	AUDIO_SP_TXStart(rstream->stream.sport_dev_addr, DISABLE);
-
-	AUDIO_SP_SetTXCounter(rstream->stream.sport_dev_num, DISABLE);
-	ameba_audio_stream_tx_buffer_flush((Stream *)rstream);
-
-	rstream->stream.restart_by_user = true;
+	ameba_audio_stream_tx_stop(stream, STATE_STANDBY);
 }
 
 //gdma done moving one period size data IRQ. Data is gdma_cb_data
@@ -673,21 +815,23 @@ uint32_t ameba_audio_stream_tx_complete(void *data)
 		ameba_audio_stream_buffer_update_tx_readptr(rstream->stream.rbuffer, tx_length);
 		rstream->stream.gdma_irq_cnt++;
 
+		if (AUDIO_OUT_TSTAMP_TYPE == AUDIO_TSTAMP_BY_DMA || DEBUG_FRAMES) {
+			rstream->stream.total_dma_bytes += tx_length;
+		}
+
 		if (rstream->stream.sem_gdma_end_need_post) {
 			rtw_up_sema_from_isr(rstream->stream.sem_gdma_end);
 			return 0;
 		}
 
-		if (rstream->stream.restart_by_user == true || rstream->stream.gdma_need_stop) {
+		if (rstream->stream.gdma_need_stop) {
 			return 0;
 		}
 
 		if (ameba_audio_stream_buffer_get_available_size(rstream->stream.rbuffer) == rstream->stream.rbuffer->capacity ||
 			ameba_audio_stream_buffer_get_remain_size(rstream->stream.rbuffer) < tx_length) {
 			HAL_AUDIO_IRQ_INFO("buffer empty,underrun(%lldns)", OsalGetSysTimeNs(OSAL_TIME_MONOTONIC));
-			rstream->stream.restart_by_user = true;
-			rstream->stream.total_counter += AUDIO_SP_GetTXCounterVal(rstream->stream.sport_dev_num);
-			AUDIO_SP_SetTXCounter(rstream->stream.sport_dev_num, DISABLE);
+			ameba_audio_stream_tx_stop(gdata->stream, STATE_XRUN);
 		} else {
 			tx_addr = (uint32_t)(rstream->stream.rbuffer->raw_data + ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.rbuffer));
 			AUDIO_SP_TXGDMA_Restart(txgdma_initstruct->GDMA_Index, txgdma_initstruct->GDMA_ChNum, tx_addr, tx_length);
@@ -707,15 +851,14 @@ uint32_t ameba_audio_stream_tx_complete(void *data)
 			return 0;
 		}
 
-		if (rstream->stream.extra_restart_by_user == true || rstream->stream.gdma_need_stop) {
+		if (rstream->stream.gdma_need_stop) {
 			return 0;
 		}
 
 		if (ameba_audio_stream_buffer_get_available_size(rstream->stream.extra_rbuffer) == rstream->stream.extra_rbuffer->capacity ||
 			ameba_audio_stream_buffer_get_remain_size(rstream->stream.extra_rbuffer) < extra_tx_length) {
 			HAL_AUDIO_IRQ_INFO("buffer empty,underrun(%lldns)", OsalGetSysTimeNs(OSAL_TIME_MONOTONIC));
-			rstream->stream.extra_restart_by_user = true;
-			AUDIO_SP_SetTXCounter(rstream->stream.sport_dev_num, DISABLE);
+			ameba_audio_stream_tx_stop(gdata->stream, STATE_XRUN);
 		} else {
 			extra_tx_addr = (uint32_t)(rstream->stream.extra_rbuffer->raw_data + ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.extra_rbuffer));
 			AUDIO_SP_TXGDMA_Restart(txgdma_initstruct->GDMA_Index, txgdma_initstruct->GDMA_ChNum, extra_tx_addr, extra_tx_length);
@@ -766,14 +909,16 @@ static int ameba_audio_stream_tx_write_in_noirq_mode(Stream *stream, const void
 				AUDIO_SP_LLPTXGDMA_Init(rstream->stream.sport_dev_num, GDMA_INT, sp_txgdma_initstruct, rstream->stream.gdma_struct,
 										(IRQ_FUN)NULL,
 										rstream->stream.period_bytes, rstream->stream.period_count, rstream->stream.gdma_ch_lli);
-				AUDIO_SP_DmaCmd(AUDIO_SPORT0_DEV, ENABLE);
-				AUDIO_SP_TXStart(AUDIO_SPORT0_DEV, ENABLE);
+				AUDIO_SP_DmaCmd(rstream->stream.sport_dev_num, ENABLE);
+				AUDIO_SP_TXStart(rstream->stream.sport_dev_num, ENABLE);
 			}
 		}
 
 		bytes_left_to_write -= bytes_written;
 	}
 
+	rstream->total_written_from_tx_start += bytes / rstream->stream.config.frame_size;
+
 	return bytes;
 }
 
@@ -800,6 +945,13 @@ static int ameba_audio_stream_tx_write_in_irq_mode(Stream *stream, const void *d
 
 	rstream->write_cnt++;
 
+	if (rstream->stream.state == STATE_XRUN) {
+		//If xrun ,return -EPIPE. Application should handle xrun according to the return value.
+		//HAL_AUDIO_INFO("xrun happens, state change to STATE_XRUN_NOTIFIED");
+		rstream->stream.state = STATE_XRUN_NOTIFIED;
+		return HAL_OSAL_ERR_DEAD_OBJECT;
+	}
+
 	if (AUDIO_OUT_DEBUG_BUFFER_LEVEL == 1) {
 		if (rstream->write_cnt % 100 == 0) {
 			HAL_AUDIO_DEBUG("wr cnt:%llu, remain:%dbytes, avail:%dbytes",
@@ -839,7 +991,7 @@ static int ameba_audio_stream_tx_write_in_irq_mode(Stream *stream, const void *d
 			extra_dma_len = rstream->stream.period_bytes * rstream->stream.extra_channel / (rstream->stream.channel + rstream->stream.extra_channel);
 		}
 
-		if (!rstream->stream.start_gdma) {
+		if (rstream->stream.state == STATE_INITED) {
 			if (ameba_audio_stream_buffer_get_remain_size(rstream->stream.rbuffer) >= dma_len) {
 				rstream->stream.start_gdma = true;
 				tx_addr = (uint32_t)(rstream->stream.rbuffer->raw_data + ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.rbuffer));
@@ -858,7 +1010,8 @@ static int ameba_audio_stream_tx_write_in_irq_mode(Stream *stream, const void *d
 					HAL_AUDIO_INFO("gdma extra init: index:%d, chNum:%d, tx_addr:0x%lx, extra_dma_len:%lu",
 								   extra_sp_txgdma_initstruct->GDMA_Index, extra_sp_txgdma_initstruct->GDMA_ChNum, extra_tx_addr, extra_dma_len);
 				}
-				AUDIO_SP_SetTXCounter(rstream->stream.sport_dev_num, ENABLE);
+
+				ameba_audio_stream_tx_start(stream, STATE_STARTED);
 
 #if HAL_AUDIO_PLAYBACK_DUMP_DEBUG
 				ameba_audio_dump_gdma_regs(sp_txgdma_initstruct->GDMA_ChNum);
@@ -868,25 +1021,20 @@ static int ameba_audio_stream_tx_write_in_irq_mode(Stream *stream, const void *d
 			}
 		}
 
-		if (rstream->stream.restart_by_user) {
+		if (rstream->stream.state == STATE_XRUN_NOTIFIED || rstream->stream.state == STATE_STANDBY) {
 			if (ameba_audio_stream_buffer_get_remain_size(rstream->stream.rbuffer) >= dma_len) {
-				rstream->stream.restart_by_user = false;
 				tx_addr = (uint32_t)(rstream->stream.rbuffer->raw_data + ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.rbuffer));
-				HAL_AUDIO_PVERBOSE("restart gdma at rp:%u", ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.rbuffer));
+				HAL_AUDIO_VERBOSE("restart gdma at rp:%u", ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.rbuffer));
 				AUDIO_SP_TXGDMA_Restart(sp_txgdma_initstruct->GDMA_Index, sp_txgdma_initstruct->GDMA_ChNum, tx_addr, dma_len);
-				AUDIO_SP_SetTXCounter(rstream->stream.sport_dev_num, ENABLE);
 				rstream->stream.gdma_cnt++;
-			}
-		}
 
-		if (has_extra_dma && rstream->stream.extra_restart_by_user) {
-			if (ameba_audio_stream_buffer_get_remain_size(rstream->stream.extra_rbuffer) >= extra_dma_len) {
-				rstream->stream.extra_restart_by_user = false;
-				extra_tx_addr = (uint32_t)(rstream->stream.extra_rbuffer->raw_data + ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.extra_rbuffer));
-				HAL_AUDIO_PVERBOSE("restart extra gdma at rp:%u", ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.extra_rbuffer));
-				AUDIO_SP_TXGDMA_Restart(extra_sp_txgdma_initstruct->GDMA_Index, extra_sp_txgdma_initstruct->GDMA_ChNum, extra_tx_addr, extra_dma_len);
-				AUDIO_SP_SetTXCounter(rstream->stream.sport_dev_num, ENABLE);
-				rstream->stream.extra_gdma_cnt++;
+				if (has_extra_dma) {
+					extra_tx_addr = (uint32_t)(rstream->stream.extra_rbuffer->raw_data + ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.extra_rbuffer));
+					HAL_AUDIO_VERBOSE("restart extra gdma at rp:%u", ameba_audio_stream_buffer_get_tx_readptr(rstream->stream.extra_rbuffer));
+					AUDIO_SP_TXGDMA_Restart(extra_sp_txgdma_initstruct->GDMA_Index, extra_sp_txgdma_initstruct->GDMA_ChNum, extra_tx_addr, extra_dma_len);
+					rstream->stream.extra_gdma_cnt++;
+				}
+				ameba_audio_stream_tx_start(stream, STATE_STARTED);
 			}
 		}
 
@@ -920,9 +1068,16 @@ static int ameba_audio_stream_tx_write_in_irq_mode(Stream *stream, const void *d
 		}
 	}
 
+	rstream->total_written_from_tx_start += bytes / rstream->stream.config.frame_size;
 	return bytes;
 }
 
+uint64_t ameba_audio_stream_tx_get_frames_written(Stream *stream)
+{
+	RenderStream *rstream = (RenderStream *)stream;
+	return rstream->total_written_from_tx_start;
+}
+
 int ameba_audio_stream_tx_write(Stream *stream, const void *data, uint32_t bytes, bool block)
 {
 	if (stream) {
@@ -950,8 +1105,8 @@ void ameba_audio_stream_tx_close(Stream *stream)
 
 		rstream->stream.trigger_tstamp = ameba_audio_get_now_ns();
 
-		AUDIO_SP_DmaCmd(rstream->stream.sport_dev_addr, DISABLE);
-		AUDIO_SP_TXStart(rstream->stream.sport_dev_addr, DISABLE);
+		AUDIO_SP_DmaCmd(rstream->stream.sport_dev_num, DISABLE);
+		AUDIO_SP_TXStart(rstream->stream.sport_dev_num, DISABLE);
 
 		AUDIO_SP_Deinit(rstream->stream.sport_dev_num, SP_DIR_TX);
 		//AUDIO_CODEC_DeInit(APP_LINE_OUT);
@@ -973,6 +1128,7 @@ void ameba_audio_stream_tx_close(Stream *stream)
 			rstream->stream.gdma_ch_lli = NULL;
 		}
 
+		rstream->stream.state = STATE_DEINITED;
 		free(rstream);
 	}
 }
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_render.h b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_render.h
index d971c5398..a1d060975 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_render.h
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_render.h
@@ -25,18 +25,22 @@ extern "C" {
 typedef struct _RenderStream {
 	Stream stream;
 	uint64_t write_cnt;
+	uint64_t total_written_from_tx_start;
 } RenderStream;
 
 Stream *ameba_audio_stream_tx_init(uint32_t device, StreamConfig config);
-void ameba_audio_stream_tx_start(Stream *stream);
+void ameba_audio_stream_tx_start(Stream *stream, int32_t state);
 uint32_t ameba_audio_stream_tx_get_buffer_status(Stream *stream);
 int  ameba_audio_stream_tx_write(Stream *stream, const void *data, uint32_t bytes, bool block);
-void ameba_audio_stream_tx_stop(Stream *stream);
+void ameba_audio_stream_tx_stop(Stream *stream, int32_t state);
+void ameba_audio_stream_tx_standby(Stream *stream);
 void ameba_audio_stream_tx_close(Stream *stream);
 int  ameba_audio_stream_tx_set_amp_state(bool state);
 int  ameba_audio_stream_tx_get_htimestamp(Stream *stream, uint32_t *avail, struct timespec *tstamp);
 int  ameba_audio_stream_tx_get_position(Stream *stream, uint64_t *rendered_frames, struct timespec *tstamp);
+int  ameba_audio_stream_tx_get_time(Stream *stream, int64_t *now_ns, int64_t *audio_ns);
 uint64_t ameba_audio_stream_tx_sport_rendered_frames(Stream *stream);
+uint64_t ameba_audio_stream_tx_get_frames_written(Stream *stream);
 
 #ifdef __cplusplus
 }
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_utils.c b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_utils.c
index b0c6a38fb..ea966ce45 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_utils.c
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_utils.c
@@ -48,7 +48,31 @@ uint32_t ameba_audio_get_channel(uint32_t channel_count)
 	return tmp;
 }
 
-uint32_t ameba_audio_get_tdm(uint32_t channel_count)
+uint32_t ameba_audio_get_sp_tdm(uint32_t channel_count)
+{
+	uint32_t tmp;
+	switch (channel_count) {
+	case 1:
+	case 2:
+		tmp = SP_TX_NOTDM;
+		break;
+	case 4:
+		tmp = SP_TX_TDM4;
+		break;
+	case 6:
+		tmp = SP_TX_TDM6;
+		break;
+	case 8:
+		tmp = SP_TX_TDM8;
+		break;
+	default:
+		HAL_AUDIO_ERROR("[AmebaAudioUtils] invalid format");
+		return -1;
+	}
+	return tmp;
+}
+
+uint32_t ameba_audio_get_codec_tdm(uint32_t channel_count)
 {
 	uint32_t tmp;
 	switch (channel_count) {
@@ -364,18 +388,18 @@ void ameba_audio_dump_gdma_regs(u8 GDMA_ChNum)
 {
 	GDMA_TypeDef *GDMA = ((GDMA_TypeDef *)GDMA_BASE);
 
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].SAR:%lx\r\n", GDMA_ChNum, GDMA->CH[GDMA_ChNum].SAR);
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].DAR:%lx\r\n", GDMA_ChNum, GDMA->CH[GDMA_ChNum].DAR);
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].CTL_LOW:%lx\r\n", GDMA_ChNum, GDMA->CH[GDMA_ChNum].CTL_LOW);
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].CTL_HIGH:%lx\r\n", GDMA_ChNum, GDMA->CH[GDMA_ChNum].CTL_HIGH);
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].CFG_LOW:%lx\r\n", GDMA_ChNum, GDMA->CH[GDMA_ChNum].CFG_LOW);
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].CFG_HIGH:%lx\r\n", GDMA_ChNum, GDMA->CH[GDMA_ChNum].CFG_HIGH);
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].ChEnReg:%lx\r\n", GDMA_ChNum, GDMA->ChEnReg);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].SAR:%lx", GDMA_ChNum, GDMA->CH[GDMA_ChNum].SAR);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].DAR:%lx", GDMA_ChNum, GDMA->CH[GDMA_ChNum].DAR);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].CTL_LOW:%lx", GDMA_ChNum, GDMA->CH[GDMA_ChNum].CTL_LOW);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].CTL_HIGH:%lx", GDMA_ChNum, GDMA->CH[GDMA_ChNum].CTL_HIGH);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].CFG_LOW:%lx", GDMA_ChNum, GDMA->CH[GDMA_ChNum].CFG_LOW);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].CFG_HIGH:%lx", GDMA_ChNum, GDMA->CH[GDMA_ChNum].CFG_HIGH);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].ChEnReg:%lx", GDMA_ChNum, GDMA->ChEnReg);
 
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].MASK_TFR:%lx\r\n", GDMA_ChNum, GDMA->MASK_TFR);
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].MASK_BLOCK:%lx\r\n", GDMA_ChNum, GDMA->MASK_BLOCK);
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].MASK_ERR:%lx\r\n", GDMA_ChNum, GDMA->MASK_ERR);
-	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].STATUS_BLOCK:%lx\r\n", GDMA_ChNum, GDMA->STATUS_BLOCK);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].MASK_TFR:%lx", GDMA_ChNum, GDMA->MASK_TFR);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].MASK_BLOCK:%lx", GDMA_ChNum, GDMA->MASK_BLOCK);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].MASK_ERR:%lx", GDMA_ChNum, GDMA->MASK_ERR);
+	HAL_AUDIO_DUMP_INFO("GDMA->CH[%d].STATUS_BLOCK:%lx", GDMA_ChNum, GDMA->STATUS_BLOCK);
 
 }
 
@@ -383,64 +407,65 @@ void ameba_audio_dump_sport_regs(uint32_t SPORTx)
 {
 	uint32_t tmp;
 	AUDIO_SPORT_TypeDef *sportx = (AUDIO_SPORT_TypeDef *)SPORTx;
+	HAL_AUDIO_DUMP_INFO("dump sportx:0x%p", sportx);
 	tmp = sportx->SP_REG_MUX;
-	HAL_AUDIO_DUMP_INFO("REG_SP_REG_MUX:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_REG_MUX:%lx", tmp);
 	tmp = sportx->SP_CTRL0;
-	HAL_AUDIO_DUMP_INFO("REG_SP_CTRL0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_CTRL0:%lx", tmp);
 	tmp = sportx->SP_CTRL1;
-	HAL_AUDIO_DUMP_INFO("REG_SP_CTRL1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_CTRL1:%lx", tmp);
 	tmp = sportx->SP_INT_CTRL;
-	HAL_AUDIO_DUMP_INFO("REG_SP_INT_CTRL:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_INT_CTRL:%lx", tmp);
 	tmp = sportx->RSVD0;
-	HAL_AUDIO_DUMP_INFO("REG_RSVD0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_RSVD0:%lx", tmp);
 	tmp = sportx->SP_TRX_COUNTER_STATUS;
-	HAL_AUDIO_DUMP_INFO("REG_SP_TRX_COUNTER_STATUS:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_TRX_COUNTER_STATUS:%lx", tmp);
 	tmp = sportx->SP_ERR;
-	HAL_AUDIO_DUMP_INFO("REG_SP_ERR:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_ERR:%lx", tmp);
 	tmp = sportx->SP_SR_TX_BCLK;
-	HAL_AUDIO_DUMP_INFO("REG_SP_SR_TX_BCLK:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_SR_TX_BCLK:%lx", tmp);
 	tmp = sportx->SP_TX_LRCLK;
-	HAL_AUDIO_DUMP_INFO("REG_SP_TX_LRCLK:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_TX_LRCLK:%lx", tmp);
 	tmp = sportx->SP_FIFO_CTRL;
-	HAL_AUDIO_DUMP_INFO("REG_SP_FIFO_CTRL:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_FIFO_CTRL:%lx", tmp);
 	tmp = sportx->SP_FORMAT;
-	HAL_AUDIO_DUMP_INFO("REG_SP_FORMAT:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_FORMAT:%lx", tmp);
 	tmp = sportx->SP_RX_BCLK;
-	HAL_AUDIO_DUMP_INFO("REG_SP_RX_BCLK:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_RX_BCLK:%lx", tmp);
 	tmp = sportx->SP_RX_LRCLK;
-	HAL_AUDIO_DUMP_INFO("REG_SP_RX_LRCLK:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_RX_LRCLK:%lx", tmp);
 	tmp = sportx->SP_DSP_COUNTER;
-	HAL_AUDIO_DUMP_INFO("REG_SP_DSP_COUNTER:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_DSP_COUNTER:%lx", tmp);
 	tmp = sportx->RSVD1;
-	HAL_AUDIO_DUMP_INFO("REG_RSVD1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_RSVD1:%lx", tmp);
 	tmp = sportx->SP_DIRECT_CTRL0;
-	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL0:%lx", tmp);
 	tmp = sportx->RSVD2;
-	HAL_AUDIO_DUMP_INFO("REG_RSVD2:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_RSVD2:%lx", tmp);
 	tmp = sportx->SP_FIFO_IRQ;
-	HAL_AUDIO_DUMP_INFO("REG_SP_FIFO_IRQ:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_FIFO_IRQ:%lx", tmp);
 	tmp = sportx->SP_DIRECT_CTRL1;
-	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL1:%lx", tmp);
 	tmp = sportx->SP_DIRECT_CTRL2;
-	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL2:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL2:%lx", tmp);
 	tmp = sportx->RSVD3;
-	HAL_AUDIO_DUMP_INFO("REG_RSVD3:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_RSVD3:%lx", tmp);
 	tmp = sportx->SP_DIRECT_CTRL3;
-	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL3:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL3:%lx", tmp);
 	tmp = sportx->SP_DIRECT_CTRL4;
-	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL4:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_DIRECT_CTRL4:%lx", tmp);
 	tmp = sportx->SP_RX_COUNTER1;
-	HAL_AUDIO_DUMP_INFO("REG_SP_RX_COUNTER1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_RX_COUNTER1:%lx", tmp);
 	tmp = sportx->SP_RX_COUNTER2;
-	HAL_AUDIO_DUMP_INFO("REG_SP_RX_COUNTER2:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_RX_COUNTER2:%lx", tmp);
 	tmp = sportx->SP_TX_FIFO_0_WR_ADDR;
-	HAL_AUDIO_DUMP_INFO("REG_SP_TX_FIFO_0_WR_ADDR:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_TX_FIFO_0_WR_ADDR:%lx", tmp);
 	tmp = sportx->SP_RX_FIFO_0_RD_ADDR;
-	HAL_AUDIO_DUMP_INFO("REG_SP_RX_FIFO_0_RD_ADDR:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_RX_FIFO_0_RD_ADDR:%lx", tmp);
 	tmp = sportx->SP_TX_FIFO_1_WR_ADDR;
-	HAL_AUDIO_DUMP_INFO("REG_SP_TX_FIFO_1_WR_ADDR:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_TX_FIFO_1_WR_ADDR:%lx", tmp);
 	tmp = sportx->SP_RX_FIFO_1_RD_ADDR;
-	HAL_AUDIO_DUMP_INFO("REG_SP_RX_FIFO_1_RD_ADDR:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("REG_SP_RX_FIFO_1_RD_ADDR:%lx", tmp);
 
 }
 
@@ -449,95 +474,95 @@ void ameba_audio_dump_codec_regs(void)
 	uint32_t tmp;
 
 	tmp = g_audio_analog->AUD_ADDA_CTL;
-	HAL_AUDIO_DUMP_INFO("ADDA_CTL:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("ADDA_CTL:%lx", tmp);
 	tmp = g_audio_analog->AUD_HPO_CTL;
-	HAL_AUDIO_DUMP_INFO("AUD_HPO_CTL:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("AUD_HPO_CTL:%lx", tmp);
 	tmp = g_audio_analog->AUD_MICBIAS_CTL0;
-	HAL_AUDIO_DUMP_INFO("MICBIAS_CTL0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("MICBIAS_CTL0:%lx", tmp);
 	tmp = g_audio_analog->AUD_MICBST_CTL0;
-	HAL_AUDIO_DUMP_INFO("MICBST_CTL0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("MICBST_CTL0:%lx", tmp);
 	tmp = g_audio_analog->AUD_MICBST_CTL1;
-	HAL_AUDIO_DUMP_INFO("MICBST_CTL1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("MICBST_CTL1:%lx", tmp);
 	tmp = g_audio_analog->RSVD0;
-	HAL_AUDIO_DUMP_INFO("ANALOG_RSVD0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("ANALOG_RSVD0:%lx", tmp);
 	tmp = g_audio_analog->AUD_DTS_CTL;
-	HAL_AUDIO_DUMP_INFO("DTS_CTL:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("DTS_CTL:%lx", tmp);
 	tmp = g_audio_analog->AUD_MBIAS_CTL0;
-	HAL_AUDIO_DUMP_INFO("MBIAS_CTL0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("MBIAS_CTL0:%lx", tmp);
 	tmp = g_audio_analog->AUD_MBIAS_CTL1;
-	HAL_AUDIO_DUMP_INFO("MBIAS_CTL1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("MBIAS_CTL1:%lx", tmp);
 	tmp = g_audio_analog->AUD_MBIAS_CTL2;
-	HAL_AUDIO_DUMP_INFO("MBIAS_CTL2:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("MBIAS_CTL2:%lx", tmp);
 
 	/***digital reg dump***/
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_AUDIO_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_AUDIO_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_AUDIO_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_AUDIO_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_AUDIO_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_AUDIO_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_CLOCK_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_CLOCK_CONTROL_2);
-	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_CLOCK_CONTROL_3);
-	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_CLOCK_CONTROL_4);
-	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_4:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_4:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_CLOCK_CONTROL_5);
-	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_5:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_5:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_CLOCK_CONTROL_6);
-	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_5:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_5:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_CLOCK_CONTROL_7);
-	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_5:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_CLOCK_CONTROL_5:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_I2S_0_CONTROL);
-	HAL_AUDIO_DUMP_INFO("CODEC_I2S_0_CONTROL:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_I2S_0_CONTROL:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_I2S_0_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_I2S_0_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_I2S_0_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_I2S_1_CONTROL);
-	HAL_AUDIO_DUMP_INFO("CODEC_I2S_1_CONTROL:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_I2S_1_CONTROL:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_I2S_1_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_I2S_1_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_I2S_1_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_I2S_AD_SEL_CONTROL);
-	HAL_AUDIO_DUMP_INFO("CODEC_I2S_AD_SEL_CONTROL:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_I2S_AD_SEL_CONTROL:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_0_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_0_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_0_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_1_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_1_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_1_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_2_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_2_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_2_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_3_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_3_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_3_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_4_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_4_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_4_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_5_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_5_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_5_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_6_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_6_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_6_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_0_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_0_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_0_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_1_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_1_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_1_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_2_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_2_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_2_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_3_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_3_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_3_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_4_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_4_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_4_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_5_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_5_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_5_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_ADC_6_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_ADC_6_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_ADC_6_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_DAC_L_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_DAC_L_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_DAC_L_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_DAC_L_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_DAC_L_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_DAC_L_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_DAC_L_CONTROL_2);
-	HAL_AUDIO_DUMP_INFO("CODEC_DAC_L_CONTROL_2:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_DAC_L_CONTROL_2:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_DAC_R_CONTROL_0);
-	HAL_AUDIO_DUMP_INFO("CODEC_DAC_R_CONTROL_0:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_DAC_R_CONTROL_0:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_DAC_R_CONTROL_1);
-	HAL_AUDIO_DUMP_INFO("CODEC_DAC_R_CONTROL_1:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_DAC_R_CONTROL_1:%lx", tmp);
 	tmp = HAL_READ32(AUDIO_REG_BASE, CODEC_DAC_R_CONTROL_2);
-	HAL_AUDIO_DUMP_INFO("CODEC_DAC_R_CONTROL_2:%lx \n", tmp);
+	HAL_AUDIO_DUMP_INFO("CODEC_DAC_R_CONTROL_2:%lx", tmp);
 
 }
 
@@ -606,4 +631,27 @@ uint32_t ameba_audio_get_i2s_pin_func(uint32_t index)
 		break;
 	}
 	return pin_func;
+}
+
+uint32_t ameba_audio_get_sport_irq(uint32_t index)
+{
+	uint32_t irq = 0;
+	switch (index) {
+	case 0:
+		irq = SPORT0_IRQ;
+		break;
+	case 1:
+		irq = SPORT1_IRQ;
+		break;
+	case 2:
+		irq = SPORT2_IRQ;
+		break;
+	case 3:
+		irq = SPORT3_IRQ;
+		break;
+	default:
+		HAL_AUDIO_ERROR("unsupported sport:%lu", index);
+		break;
+	}
+	return irq;
 }
\ No newline at end of file
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_utils.h b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_utils.h
index 0d33dba5e..289e59a24 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_utils.h
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/ameba_audio_stream_utils.h
@@ -35,7 +35,8 @@ extern "C" {
 void ameba_audio_set_native_time(void);
 int64_t ameba_audio_get_now_ns(void);
 uint32_t ameba_audio_get_channel(uint32_t channel_count);
-uint32_t ameba_audio_get_tdm(uint32_t channel_count);
+uint32_t ameba_audio_get_sp_tdm(uint32_t channel_count);
+uint32_t ameba_audio_get_codec_tdm(uint32_t channel_count);
 uint32_t ameba_audio_get_fifo_num(uint32_t channel_count);
 uint32_t ameba_audio_stream_get_mic_idx(uint32_t mic_category);
 uint32_t ameba_audio_stream_get_adc_idx(uint32_t index);
@@ -46,6 +47,7 @@ int ameba_audio_get_codec_format(AudioHwFormat format, uint32_t direction);
 int ameba_audio_get_codec_rate(uint32_t rate);
 AUDIO_SPORT_TypeDef *ameba_audio_get_sport_addr(uint32_t index);
 uint32_t ameba_audio_get_i2s_pin_func(uint32_t index);
+uint32_t ameba_audio_get_sport_irq(uint32_t index);
 
 void ameba_audio_dump_gdma_regs(u8 GDMA_ChNum);
 void ameba_audio_dump_sport_regs(uint32_t SPORTx);
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/audio_hw_control.c b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/audio_hw_control.c
index 65392bd61..97bd640b8 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/audio_hw_control.c
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/audio_hw_control.c
@@ -61,7 +61,7 @@ static bool AmebaGetAmplifierMute(struct AudioHwControl *control)
 static int32_t AmebaSetPlaybackMute(struct AudioHwControl *control, bool mute)
 {
 	(void) control;
-	return ameba_audio_ctl_set_tx_mute(ameba_audio_get_ctl(), mute);
+	return ameba_audio_ctl_set_tx_mute(ameba_audio_get_ctl(), mute, true, true);
 }
 
 static bool AmebaGetPlaybackMute(struct AudioHwControl *control)
@@ -136,7 +136,7 @@ static int32_t AmebaGetMicUsage(struct AudioHwControl *control)
 	return ameba_audio_ctl_get_mic_usage(ameba_audio_get_ctl());
 }
 
-static int32_t AmebaAdjustPLLClock(struct AudioHwControl *control, uint32_t rate, uint32_t ppm, uint32_t action)
+static float AmebaAdjustPLLClock(struct AudioHwControl *control, uint32_t rate, float ppm, uint32_t action)
 {
 	(void) control;
 	return ameba_audio_ctl_pll_clock_tune(ameba_audio_get_ctl(), rate, ppm, action);
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/primary_audio_hw_capture.c b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/primary_audio_hw_capture.c
index 25ab17260..ec998e45a 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/primary_audio_hw_capture.c
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/primary_audio_hw_capture.c
@@ -248,14 +248,15 @@ static int PrimaryGetCapturePosition(const struct AudioHwCapture *stream, uint64
 	struct PrimaryAudioHwCapture *cap = (struct PrimaryAudioHwCapture *)stream;
 	int ret = -1;
 
-	rtw_mutex_get(&cap->lock);
+	//Better not add mutex, because if only do record, will always lock in read api.So this api will not work.
+	//rtw_mutex_get(&cap->lock);
 
 	if (cap->in_pcm) {
 		uint64_t captured_frames;
 		if (ameba_audio_stream_rx_get_position(cap->in_pcm, &captured_frames, timestamp) == 0) {
 			*frames = captured_frames;
 			HAL_AUDIO_VERBOSE("frames:%llu", *frames);
-			rtw_mutex_put(&cap->lock);
+			//rtw_mutex_put(&cap->lock);
 			return 0;
 		} else {
 			HAL_AUDIO_ERROR("get ts fail");
@@ -264,7 +265,27 @@ static int PrimaryGetCapturePosition(const struct AudioHwCapture *stream, uint64
 		HAL_AUDIO_ERROR("%s no in_pcm", __func__);
 	}
 
-	rtw_mutex_put(&cap->lock);
+	//rtw_mutex_put(&cap->lock);
+
+	return ret;
+}
+
+static int PrimaryGetPresentTime(const struct AudioHwCapture *stream, int64_t *now_ns, int64_t *audio_ns)
+{
+
+	struct PrimaryAudioHwCapture *cap = (struct PrimaryAudioHwCapture *)stream;
+	int ret = -1;
+
+	//Better not add mutex, because if only do record, will always lock in read api.So this api will not work.
+	//rtw_mutex_get(&cap->lock);
+
+	if (cap->in_pcm) {
+		ret = ameba_audio_stream_rx_get_time(cap->in_pcm, now_ns, audio_ns);
+	} else {
+		HAL_AUDIO_ERROR("%s no in_pcm", __func__);
+	}
+
+	//rtw_mutex_put(&cap->lock);
 
 	return ret;
 }
@@ -580,7 +601,7 @@ static int CheckInputParameters(uint32_t sample_rate, AudioHwFormat format, uint
 	case 48000:
 	case 88200:
 	case 96000:
-	case 174000:
+	case 176400:
 	case 192000:
 		break;
 	default:
@@ -657,6 +678,7 @@ struct AudioHwCapture *GetAudioHwCaptureFuncs(struct AudioHwAdapter *adapter, co
 	in->stream.common.GetParameters = PrimaryGetCaptureParameters;
 	in->stream.GetLatency = PrimaryGetCaptureLatency;
 	in->stream.GetCapturePosition = PrimaryGetCapturePosition;
+	in->stream.GetPresentTime = PrimaryGetPresentTime;
 	in->stream.Read = PrimaryCaptureRead;
 
 	in->config = stream_input_config;
diff --git a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/primary_audio_hw_render.c b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/primary_audio_hw_render.c
index 319f317ca..7f2a45e0b 100755
--- a/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/primary_audio_hw_render.c
+++ b/os/board/rtl8730e/src/component/audio/audio_hal/rtl8730e/primary_audio_hw_render.c
@@ -15,6 +15,7 @@
 #include "audio_hw_compat.h"
 #include <inttypes.h>
 
+#include "ameba_audio_hw_usrcfg.h"
 #include "ameba_audio_types.h"
 #include "ameba_audio_stream_control.h"
 #include "ameba_audio_stream_render.h"
@@ -63,7 +64,6 @@ struct PrimaryAudioHwRender {
 
 	//max value should sync with ameba audio driver's total_counter_boundary.
 	uint64_t written;
-	uint64_t written_to_driver;
 };
 
 static inline size_t PrimaryAudioHwRenderFrameSize(const struct AudioHwRender *s)
@@ -136,8 +136,12 @@ static int DoStandbyOutput(struct PrimaryAudioHwRender *out)
 {
 	if (!out->standby) {
 		out->standby = 1;
-		ameba_audio_stream_tx_stop(out->out_pcm);
-		out->written_to_driver = 0;
+		if (AUDIO_HW_AMPLIFIER_MUTE_ENABLE) {
+			ameba_audio_stream_tx_set_amp_state(false);
+		}
+
+		ameba_audio_stream_tx_standby(out->out_pcm);
+		ameba_audio_stream_buffer_flush(out->out_pcm->rbuffer);
 	}
 	return 0;
 }
@@ -171,6 +175,7 @@ static uint32_t PrimaryGetRenderBufferStatus(struct AudioHwStream *stream)
 		return 0;
 	}
 
+
 	return ameba_audio_stream_tx_get_buffer_status(out->out_pcm);
 }
 
@@ -203,8 +208,9 @@ static uint32_t PrimaryGetRenderLatency(const struct AudioHwRender *stream)
 {
 	struct PrimaryAudioHwRender *out = (struct PrimaryAudioHwRender *)stream;
 	uint64_t sport_out_frames = ameba_audio_stream_tx_sport_rendered_frames(out->out_pcm);
-	uint32_t latency_ms = (out->written_to_driver - sport_out_frames) * 1000 / out->config.rate;
-	HAL_AUDIO_VERBOSE("hal written_to_driver:%llu, sport_out_frames:%llu, latency_ms:%lu", out->written_to_driver, sport_out_frames, latency_ms);
+	uint32_t latency_ms = (ameba_audio_stream_tx_get_frames_written(out->out_pcm) - sport_out_frames) * 1000 / out->config.rate;
+	HAL_AUDIO_VERBOSE("hal written_to_driver:%llu, sport_out_frames:%llu, latency_ms:%lu", ameba_audio_stream_tx_get_frames_written(out->out_pcm), sport_out_frames,
+					  latency_ms);
 
 	uint32_t dma_buf_add_codec_latency_ms = (out->config.period_size * out->config.period_count + 36) * 1000 / out->config.rate;
 	if (latency_ms > dma_buf_add_codec_latency_ms * 2) {
@@ -226,9 +232,10 @@ static int PrimaryGetPresentationPosition(const struct AudioHwRender *stream, ui
 	if (out->out_pcm) {
 		uint64_t rendered_frames;
 		if (ameba_audio_stream_tx_get_position(out->out_pcm, &rendered_frames, timestamp) == 0) {
-			int64_t signed_frames = out->written - (out->written_to_driver - rendered_frames);
-			HAL_AUDIO_PVERBOSE("out->written:%llu, rendered_frames:%llu, signed_frames:%lld, sec:%lld, nsec:%ld", out->written, rendered_frames,
-							   signed_frames, timestamp->tv_sec, timestamp->tv_nsec);
+			int64_t signed_frames = out->written - (ameba_audio_stream_tx_get_frames_written(out->out_pcm) - rendered_frames);
+			HAL_AUDIO_VERBOSE("out->written:%llu, rendered_frames:%llu, written to driver:%llu, signed_frames:%lld, sec:%lld, nsec:%ld", out->written, rendered_frames,
+							  ameba_audio_stream_tx_get_frames_written(out->out_pcm),
+							  signed_frames, timestamp->tv_sec, timestamp->tv_nsec);
 			if (signed_frames >= 0) {
 				*frames = signed_frames;
 				HAL_AUDIO_VERBOSE("frames:%llu", *frames);
@@ -247,6 +254,35 @@ static int PrimaryGetPresentationPosition(const struct AudioHwRender *stream, ui
 	return ret;
 }
 
+static int PrimaryGetPresentTime(const struct AudioHwRender *stream, int64_t *now_ns, int64_t *audio_ns)
+{
+	HAL_AUDIO_VERBOSE("primaryGetPresentationPosition latency:%lu", PrimaryGetRenderLatency(stream));
+
+	struct PrimaryAudioHwRender *out = (struct PrimaryAudioHwRender *)stream;
+	int ret = -1;
+	int64_t tmp_now_ns = 0;
+	int64_t tmp_audio_ns = 0;
+
+	rtw_mutex_get(&out->lock);
+
+	if (out->out_pcm) {
+		int64_t written_to_driver_frames = ameba_audio_stream_tx_get_frames_written(out->out_pcm);
+		ret = ameba_audio_stream_tx_get_time(out->out_pcm, &tmp_now_ns, &tmp_audio_ns);
+		int64_t out_written_to_hal_ns = (int64_t)(((double)out->written / (double)PrimaryGetRenderSampleRate((const struct AudioHwStream *)stream) *
+										(double)1000000000));
+		int64_t written_to_driver_ns = (int64_t)(((double)written_to_driver_frames / (double)PrimaryGetRenderSampleRate((const struct AudioHwStream *)stream) *
+									   (double)1000000000));
+		*audio_ns = out_written_to_hal_ns - (written_to_driver_ns - tmp_audio_ns);
+		*now_ns = tmp_now_ns;
+	} else {
+		HAL_AUDIO_ERROR("%s no out_pcm", __func__);
+	}
+
+	rtw_mutex_put(&out->lock);
+
+	return ret;
+}
+
 static int PrimarySetRenderVolume(struct AudioHwRender *stream, float left,
 								  float right)
 {
@@ -260,9 +296,11 @@ static int PrimarySetRenderVolume(struct AudioHwRender *stream, float left,
 static int StartAudioHwRender(struct PrimaryAudioHwRender *out)
 {
 	HAL_AUDIO_VERBOSE("start output stream enter");
-
-	ameba_audio_stream_tx_start(out->out_pcm);
-
+	(void) out;
+	//ameba_audio_ctl_set_tx_mute(ameba_audio_get_ctl(), false);
+	if (AUDIO_HW_AMPLIFIER_MUTE_ENABLE) {
+		ameba_audio_stream_tx_set_amp_state(true);
+	}
 	return HAL_OSAL_OK;
 }
 
@@ -307,7 +345,6 @@ static ssize_t PrimaryRenderWrite(struct AudioHwRender *stream, const void *buff
 	//write successfully
 	if (ret >= 0) {
 		out->written += ret / frame_size;
-		out->written_to_driver += ret / frame_size;
 		//sync with ameba audio driver's total_counter_boundary max value.
 		if (out->written > UINT64_MAX) {
 			out->written = 0;
@@ -367,6 +404,7 @@ struct AudioHwRender *GetAudioHwRenderFuncs(struct AudioHwAdapter *adapter, cons
 	out->stream.common.GetParameters = PrimaryGetRenderParameters;
 	out->stream.common.GetBufferStatus = PrimaryGetRenderBufferStatus;
 	out->stream.GetPresentationPosition = PrimaryGetPresentationPosition;
+	out->stream.GetPresentTime = PrimaryGetPresentTime;
 	out->stream.GetLatency = PrimaryGetRenderLatency;
 	out->stream.SetVolume = PrimarySetRenderVolume;
 	out->stream.Write = PrimaryRenderWrite;
@@ -378,7 +416,6 @@ struct AudioHwRender *GetAudioHwRenderFuncs(struct AudioHwAdapter *adapter, cons
 	out->adap = adap;
 	out->standby = 1;
 	out->written = 0;
-	out->written_to_driver = 0;
 	out->amp_pin = -1;
 
 	AudioHwFormat format = out->stream.common.GetFormat(&out->stream.common);
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_control.h b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_control.h
index a2a872c67..9d9d3fafa 100755
--- a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_control.h
+++ b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_control.h
@@ -379,15 +379,11 @@ int32_t RTAudioControl_GetMicUsage(void);
  * @param rate sample rate of current stream
  * @param ppm ~1.55ppm per FOF step
  * @param action can be RTAUDIO_PLL_AUTO RTAUDIO_PLL_FASTER RTAUDIO_PLL_SLOWER
- * @return Returns a value listed below: \n
- * rt_status_t | Description
- * ----------------------| -----------------------
- * OSAL_OK | the operation is successful.
- * OSAL_ERR_INVALID_OPERATION | param not supported.
+ * @return Returns the ppm adjusted.
  * @since 1.0
  * @version 1.0
  */
-rt_status_t RTAudioControl_AdjustPLLClock(uint32_t rate, uint32_t ppm, uint32_t action);
+float RTAudioControl_AdjustPLLClock(uint32_t rate, float ppm, uint32_t action);
 
 /**
  * @brief Set Audio Record Mute.
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_equalizer.h b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_equalizer.h
index 0e55b7f2b..5f00a0c52 100755
--- a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_equalizer.h
+++ b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_equalizer.h
@@ -24,6 +24,7 @@ extern "C" {
 #endif
 
 struct RTAudioEqualizer;
+struct RTEffectModule;
 
 /**
  * @brief Create RTAudioEqualizer instance.
@@ -41,6 +42,20 @@ struct RTAudioEqualizer *RTAudioEqualizer_Create(void);
  */
 void RTAudioEqualizer_Destroy(struct RTAudioEqualizer *equalizer);
 
+/**
+ * @brief Set RTEffectModule to equalizer.Only works in passthrough mode.
+ * @param module is the pointer of struct RTEffectModule.
+ * @return Returns a value listed below: \n
+ * rt_status_t | Description
+ * ----------------------| -----------------------
+ * OSAL_OK | the operation is successful.
+ * OSAL_ERR_INVALID_OPERATION | the operation is invalid.
+ * OSAL_ERR_INVALID_PARAM | the params are invalid.
+ * @since 1.0
+ * @version 1.0
+ */
+rt_status_t RTAudioEqualizer_SetModule(struct RTAudioEqualizer *equalizer, struct RTEffectModule *module);
+
 /**
  * @brief Init RTAudioEqualizer.
  * @param equalizer is the pointer of struct RTAudioEqualizer.
@@ -71,6 +86,20 @@ rt_status_t RTAudioEqualizer_Init(struct RTAudioEqualizer *equalizer, int32_t pr
  */
 rt_status_t RTAudioEqualizer_SetEnabled(struct RTAudioEqualizer *equalizer, bool enabled);
 
+/**
+ * @brief Get number of bands RTAudioEqualizer supports.
+ * @param equalizer is the pointer of struct RTAudioEqualizer.
+ * @param bands is the total bands.
+ * @return Returns a value listed below: \n
+ * rt_status_t | Description
+ * ----------------------| -----------------------
+ * OSAL_OK | the operation is successful.
+ * OSAL_ERR_INVALID_OPERATION | the operation is invalid.
+ * @since 1.0
+ * @version 1.0
+ */
+rt_status_t RTAudioEqualizer_SetNumberOfBands(struct RTAudioEqualizer *equalizer, uint32_t bands);
+
 /**
  * @brief Get number of bands RTAudioEqualizer supports.
  * @param equalizer is the pointer of struct RTAudioEqualizer.
@@ -121,27 +150,31 @@ rt_status_t RTAudioEqualizer_SetBandLevel(struct RTAudioEqualizer *equalizer, ui
 int16_t RTAudioEqualizer_GetBandLevel(struct RTAudioEqualizer *equalizer, uint32_t band);
 
 /**
- * @brief Get RTAudioEqualizer center frequency.
+ * @brief Set RTAudioEqualizer center frequency.
  * @param equalizer is the pointer of struct RTAudioEqualizer.
- * @param band is the band number, for example, RTAudioEqualizer total supports 5 bands, which band frequency to get?
- * The band value range is [0, BAND_TATAL_NUM).BAND_TATAL_NUM is got from RTAudioEqualizer_GetNumberOfBands.
- * @return Returns a value of center frequency.
+ * @param band is the band number.
+ * @param freq is the new center frequency set to band in hz.
+ * @return Returns a value listed below: \n
+ * rt_status_t | Description
+ * ----------------------| -----------------------
+ * OSAL_OK | the operation is successful.
+ * OSAL_ERR_INVALID_OPERATION | the operation is invalid.
+ * OSAL_ERR_INVALID_PARAM | the params are invalid.
  * @since 1.0
  * @version 1.0
  */
-int32_t RTAudioEqualizer_GetCenterFreq(struct RTAudioEqualizer *equalizer, uint32_t band);
+rt_status_t RTAudioEqualizer_SetCenterFreq(struct RTAudioEqualizer *equalizer, uint32_t band, uint32_t freq);
 
 /**
- * @brief Get RTAudioEqualizer center frequency range.
+ * @brief Get RTAudioEqualizer center frequency.
  * @param equalizer is the pointer of struct RTAudioEqualizer.
- * @param band is the band number, for example, RTAudioEqualizer total supports 5 bands, which band freq range to get?
+ * @param band is the band number, for example, RTAudioEqualizer total supports 5 bands, which band frequency to get?
  * The band value range is [0, BAND_TATAL_NUM).BAND_TATAL_NUM is got from RTAudioEqualizer_GetNumberOfBands.
- * @return Returns a value of frequency range. The return value contains two int32_t integer, represents the range, for
- * example:[30000, 120000].
+ * @return Returns a value of center frequency in hz.
  * @since 1.0
  * @version 1.0
  */
-int32_t *RTAudioEqualizer_GetBandFreqRange(struct RTAudioEqualizer *equalizer, uint32_t band);
+int32_t RTAudioEqualizer_GetCenterFreq(struct RTAudioEqualizer *equalizer, uint32_t band);
 
 /**
  * @brief Get RTAudioEqualizer frequency's band.
@@ -153,6 +186,32 @@ int32_t *RTAudioEqualizer_GetBandFreqRange(struct RTAudioEqualizer *equalizer, u
  */
 int16_t RTAudioEqualizer_GetBand(struct RTAudioEqualizer *equalizer, uint32_t frequency);
 
+/**
+ * @brief Set RTAudioEqualizer Q factor.
+ * @param equalizer is the pointer of struct RTAudioEqualizer.
+ * @param band is the band number.
+ * @param qfactor is the qfactor set to band.
+ * @return Returns a value listed below: \n
+ * rt_status_t | Description
+ * ----------------------| -----------------------
+ * OSAL_OK | the operation is successful.
+ * OSAL_ERR_INVALID_OPERATION | the operation is invalid.
+ * OSAL_ERR_INVALID_PARAM | the params are invalid.
+ * @since 1.0
+ * @version 1.0
+ */
+rt_status_t RTAudioEqualizer_SetQfactor(struct RTAudioEqualizer *equalizer, uint32_t band, uint32_t qfactor);
+
+/**
+ * @brief Get RTAudioEqualizer Q factor.
+ * @param equalizer is the pointer of struct RTAudioEqualizer.
+ * @param band is the band number.
+ * @return Returns qfactor of the band.
+ * @since 1.0
+ * @version 1.0
+ */
+int16_t RTAudioEqualizer_GetQfactor(struct RTAudioEqualizer *equalizer, uint32_t band);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_record.h b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_record.h
index 812292a26..0b05d0c70 100755
--- a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_record.h
+++ b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_record.h
@@ -267,6 +267,22 @@ rt_status_t RTAudioRecord_SetParameters(struct RTAudioRecord *audio_record, cons
  */
 rt_status_t    RTAudioRecord_GetTimestamp(struct RTAudioRecord *audio_record, RTAudioTimestamp *tstamp);
 
+/**
+ * @brief Get present recording PTS of record.
+ *
+ * @param audio_record is the pointer of struct RTAudioRecord.
+ * @param now_ns the system time, or tsf time.
+ * @param audio_ns the audio recording time.
+ * @return Returns a value listed below: \n
+ * rt_status_t | Description
+ * ----------------------| -----------------------
+ * OSAL_OK | the operation is successful.
+ * OSAL_ERR_INVALID_OPERATION | param not supported.
+ * @since 1.0
+ * @version 1.0
+ */
+rt_status_t RTAudioRecord_GetPresentTime(struct RTAudioRecord *audio_record, int64_t *now_ns, int64_t *audio_ns);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_time.h b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_time.h
index 95cc98c38..d90151471 100755
--- a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_time.h
+++ b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_time.h
@@ -43,7 +43,7 @@
 extern "C" {
 #endif
 
-typedef struct {
+typedef struct RTAudioTimestamp {
 	uint64_t        position;
 	OsalTimespec    time;
 } RTAudioTimestamp;
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_track.h b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_track.h
index 64bf19073..199e7249d 100755
--- a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_track.h
+++ b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_track.h
@@ -310,7 +310,7 @@ rt_status_t RTAudioTrack_SetVolume(struct RTAudioTrack *track, float left, float
  * @since 1.0
  * @version 1.0
  */
-rt_status_t    RTAudioTrack_SetPlaybackRate(struct RTAudioTrack *track, RTAudioPlaybackRate rate);
+rt_status_t RTAudioTrack_SetPlaybackRate(struct RTAudioTrack *track, RTAudioPlaybackRate rate);
 
 /**
  * @brief Get speed of track.
@@ -325,7 +325,7 @@ rt_status_t    RTAudioTrack_SetPlaybackRate(struct RTAudioTrack *track, RTAudioP
  * @since 1.0
  * @version 1.0
  */
-rt_status_t    RTAudioTrack_GetPlaybackRate(struct RTAudioTrack *track, RTAudioPlaybackRate *rate);
+rt_status_t RTAudioTrack_GetPlaybackRate(struct RTAudioTrack *track, RTAudioPlaybackRate *rate);
 
 /**
  * @brief Get timestamp of track.
@@ -341,7 +341,23 @@ rt_status_t    RTAudioTrack_GetPlaybackRate(struct RTAudioTrack *track, RTAudioP
  * @since 1.0
  * @version 1.0
  */
-rt_status_t    RTAudioTrack_GetTimestamp(struct RTAudioTrack *track, RTAudioTimestamp *tstamp);
+rt_status_t RTAudioTrack_GetTimestamp(struct RTAudioTrack *track, RTAudioTimestamp *tstamp);
+
+/**
+ * @brief Get present playing PTS of track.
+ *
+ * @param track is the pointer of struct RTAudioTrack.
+ * @param now_ns the system time, or tsf time.
+ * @param audio_ns the audio playing time.
+ * @return Returns a value listed below: \n
+ * rt_status_t | Description
+ * ----------------------| -----------------------
+ * OSAL_OK | the operation is successful.
+ * OSAL_ERR_INVALID_OPERATION | param not supported.
+ * @since 1.0
+ * @version 1.0
+ */
+rt_status_t RTAudioTrack_GetPresentTime(struct RTAudioTrack *track, int64_t *now_ns, int64_t *audio_ns);
 
 /**
  * @brief Set params of track.
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_type.h b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_type.h
index 36b76a6af..cde1c8d97 100755
--- a/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_type.h
+++ b/os/board/rtl8730e/src/component/audio/interfaces/audio/audio_type.h
@@ -146,6 +146,7 @@ enum {
 	RTAUDIO_EFFECT_PARAM_CENTER_FREQ     = 0x3u,
 	RTAUDIO_EFFECT_PARAM_BAND_FREQ_RANGE = 0x4u,
 	RTAUDIO_EFFECT_PARAM_GET_BAND        = 0x5u,
+	RTAUDIO_EFFECT_PARAM_QFACTOR         = 0xAu,
 };
 
 /**
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_capture.h b/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_capture.h
index a1a728be4..d5066fbf2 100755
--- a/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_capture.h
+++ b/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_capture.h
@@ -67,6 +67,17 @@ struct AudioHwCapture {
 	 */
 	int (*GetCapturePosition)(const struct AudioHwCapture *stream, uint64_t *frames, struct timespec *timestamp);
 
+	/**
+	 * @brief Get current capture frames and timestamp of the current <b>AudioHwcapture</b> object .
+	 *
+	 * @param stream Indicates the pointer to the audio capture to operate.
+	 * @param now_ns Indicates the pointer to system time, or tsf time.
+	 * @param audio_ns Indicates the pointer to the playing audio time.
+	 * @return Returns <b>0</b> if capture frames and timestamp get successfully;
+	 * returns a negative value otherwise.
+	 */
+	int (*GetPresentTime)(const struct AudioHwCapture *stream, int64_t *now_ns, int64_t *audio_ns);
+
 	/**
 	 * @brief Get system latency of the current <b>AudioHwCapture</b> object .
 	 *
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_control.h b/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_control.h
index 7d7e4dfb8..08437da5e 100755
--- a/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_control.h
+++ b/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_control.h
@@ -381,7 +381,7 @@ struct AudioHwControl {
 	 * @since 1.0
 	 * @version 1.0
 	 */
-	int32_t (*AdjustPLLClock)(struct AudioHwControl *control, uint32_t rate, uint32_t ppm, uint32_t action);
+	float (*AdjustPLLClock)(struct AudioHwControl *control, uint32_t rate, float ppm, uint32_t action);
 
 	/**
 	 * @brief Set Audio ADC Mute.
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_render.h b/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_render.h
index 386c0da3a..e113e4fc4 100755
--- a/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_render.h
+++ b/os/board/rtl8730e/src/component/audio/interfaces/hardware/audio/audio_hw_render.h
@@ -72,6 +72,17 @@ struct AudioHwRender {
 	 */
 	int (*GetPresentationPosition)(const struct AudioHwRender *stream, uint64_t *frames, struct timespec *timestamp);
 
+	/**
+	 * @brief Get current render frames and timestamp of the current <b>AudioHwRender</b> object .
+	 *
+	 * @param stream Indicates the pointer to the audio render to operate.
+	 * @param now_ns Indicates the pointer to system time, or tsf time.
+	 * @param audio_ns Indicates the pointer to the playing audio time.
+	 * @return Returns <b>0</b> if render frames and timestamp get successfully;
+	 * returns a negative value otherwise.
+	 */
+	int (*GetPresentTime)(const struct AudioHwRender *stream, int64_t *now_ns, int64_t *audio_ns);
+
 	/**
 	 * @brief Write data to sound card for the current <b>AudioHwRender</b> object .
 	 *
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/media/rtfiplayer.h b/os/board/rtl8730e/src/component/audio/interfaces/media/rtfiplayer.h
deleted file mode 100755
index 873d12280..000000000
--- a/os/board/rtl8730e/src/component/audio/interfaces/media/rtfiplayer.h
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Copyright (c) 2021 Realtek, LLC.
- * All rights reserved.
- *
- * Licensed under the Realtek License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License from Realtek
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @addtogroup Media
- * @{
- *
- * @brief Declares APIs for media framework.
- *
- *
- * @since 1.0
- * @version 1.0
- */
-
-/**
- * @file rtfiplayer.h
- *
- *
- * @since 1.0
- * @version 1.0
- */
-
-#ifndef AMEBA_FWK_MEDIA_PLAYBACK_MEDIA_RTFIPLAYER_H
-#define AMEBA_FWK_MEDIA_PLAYBACK_MEDIA_RTFIPLAYER_H
-
-#include "osal_c/osal_types.h"
-#include "cutils/parcel.h"
-
-#include "rtplayer_common.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct RTFiPlayer RTFiPlayer;
-typedef struct RTFiPlayerCallback RTFiPlayerCallback;
-
-/**
- * @brief Provides calback interfaces.
- */
-struct RTFiPlayerCallback {
-	/**
-	 * @brief Called when fiplayer status is changed.
-	 *
-	 * @param listener The RTFiPlayerCallback object pointer.
-	 * @param player The RTFiPlayer object pointer.
-	 * @param state The player status, one of {@link RTPlayerStates}.
-	 * @since 1.0
-	 * @version 1.0
-	 */
-	void (*OnRTFiPlayerStateChanged)(const struct RTFiPlayerCallback *listener, const struct RTFiPlayer *player, int state);
-
-	/**
-	 * @brief Called when fiplayer information is received.
-	 *
-	 * @param listener The RTFiPlayerCallback object pointer.
-	 * @param player The RTFiPlayer object pointer.
-	 * @param info Indicates the information type. For details, see {@link RTPlayerInfos}.
-	 * @param extra Indicates the information code.
-	 * @since 1.0
-	 * @version 1.0
-	 */
-	void (*OnRTFiPlayerInfo)(const struct RTFiPlayerCallback *listener, const struct RTFiPlayer *player, int info, int extra);
-
-	/**
-	 * @brief Called when a fiplayer error occurs.
-	 *
-	 * @param listener The RTFiPlayerCallback object pointer.
-	 * @param player The RTFiPlayer object pointer.
-	 * @param error Indicates the error type. For details, see {@link RTPlayerErrors}.
-	 * @param extra Indicates the error code.
-	 * @since 1.0
-	 * @version 1.0
-	 */
-	void (*OnRTFiPlayerError)(const struct RTFiPlayerCallback *listener, const struct RTFiPlayer *player, int error, int extra);
-};
-
-/**
- * @brief Creates RTFiPlayer.
- *
- * @return a new RTFiPlayer object pointer.
- * @since 1.0
- * @version 1.0
- */
-struct RTFiPlayer *RTFiPlayer_Create(void);
-
-/**
- * @brief Destory RTFiPlayer.
- *
- * @param player The RTFiPlayer object pointer.
- * @since 1.0
- * @version 1.0
- */
-void	RTFiPlayer_Destory(struct RTFiPlayer *player);
-
-
-rt_status_t RTFiPlayer_SetStreamSource(struct RTFiPlayer *player, struct RTStreamSource *source);
-
-/**
- * @brief Prepares the fiplayer for playback, synchronously.
- *
- * @param player The RTFiPlayer object pointer.
- * @return Returns a value listed below: \n
- * rt_status_t | Description
- * ----------------------| -----------------------
- * OSAL_OK | the operation is successful.
- * OSAL_ERR_INVALID_OPERATION | playback is not in idle state.
- * OSAL_ERR_UNKNOWN_ERROR | operation is failed.
- * @since 1.0
- * @version 1.0
- */
-rt_status_t RTFiPlayer_Prepare(struct RTFiPlayer *player);
-
-/**
- * @brief Prepares the fiplayer for playback, asynchronously.
- * A call to {@link RTFiPlayer_PrepareAsync()} (asynchronous) will first transfers
- * the playbackt to the RTPLAYER_PREPARING state after the call returns
- * (which occurs almost right away) while the internal player engine continues
- * working on the rest of preparation work until the preparation work completes.
- * When the preparation completes, the internal player engine then calls a user
- * supplied callback method OnRTPlayerStateChanged(..., RTPLAYER_PREPARED)
- * of the RTPlayerCallbacks interface, if an RTPlayerCallbacks object is registered
- * beforehand via {@link RTFiPlayer_SetCallbacks()}.
- *
- * @param player The RTPlayer object pointer.
- * @return Returns a value listed below: \n
- * rt_status_t | Description
- * ----------------------| -----------------------
- * OSAL_OK | the operation is successful.
- * OSAL_ERR_INVALID_OPERATION | playback is not in idle state.
- * OSAL_ERR_UNKNOWN_ERROR | operation is failed.
- * @since 1.0
- * @version 1.0
- */
-rt_status_t RTFiPlayer_PrepareAsync(struct RTFiPlayer *player);
-
-/**
-* @brief Starts or resumes playback. If playback had previously been paused,
-* playback will continue from where it was paused. If playback had
-* been stopped, or never started before, playback will start at the
-* beginning.
-*
-* @param player The RTFiPlayer object pointer.
-* @return Returns a value listed below: \n
-* rt_status_t | Description
-* ----------------------| -----------------------
-* OSAL_OK | the operation is successful.
-* OSAL_ERR_INVALID_OPERATION | playback is not in idle state.
-* OSAL_ERR_UNKNOWN_ERROR | operation is failed.
-* @since 1.0
-* @version 1.0
-*/
-rt_status_t RTFiPlayer_Start(struct RTFiPlayer *player);
-
-
-//rt_status_t RTPlayer_SetLooping(struct RTPlayer *player, int8_t loop);
-
-
-rt_status_t RTFiPlayer_Stop(struct RTFiPlayer *player);
-
-/**
- * @brief Pauses playback. Call RTFiPlayer_Start() to resume.
- *
- * @param player The RTFiPlayer object pointer.
- * @return Returns a value listed below: \n
- * rt_status_t | Description
- * ----------------------| -----------------------
- * OSAL_OK | the operation is successful.
- * OSAL_ERR_INVALID_OPERATION | playback is not in idle state.
- * OSAL_ERR_UNKNOWN_ERROR | operation is failed.
- * @since 1.0
- * @version 1.0
- */
-rt_status_t RTFiPlayer_Pause(struct RTFiPlayer *player);
-
-
-//rt_status_t RTPlayer_Rewind(struct RTPlayer *player, int64_t msec);
-
-/**
- * @brief Resets the Player to its uninitialized state. After calling
- * this method, you will have to initialize it again by setting the
- * source and calling RTFiPlayer_Prepare() or RTFiPlayer_PrepareAsync().
- *
- * @param player The RTFiPlayer object pointer.
- * @return Returns a value listed below: \n
- * rt_status_t | Description
- * ----------------------| -----------------------
- * OSAL_OK | the operation is successful.
- * OSAL_ERR_INVALID_OPERATION | playback is not in idle state.
- * OSAL_ERR_UNKNOWN_ERROR | operation is failed.
- * @since 1.0
- * @version 1.0
- */
-rt_status_t RTFiPlayer_Reset(struct RTFiPlayer *player);
-
-
-//rt_status_t RTPlayer_GetCurrentTime(struct RTPlayer *player, int64_t *msec);
-
-
-//rt_status_t RTPlayer_GetDuration(struct RTPlayer *player, int64_t *msec);
-
-/**
- * @brief Checks whether the player is playing.
- *
- * @param player The RTFiPlayer object pointer.
- * @return 1 if currently playing, 0 otherwise.
- * @since 1.0
- * @version 1.0
- */
-int RTFiPlayer_IsPlaying(struct RTFiPlayer *player);
-
-/**
- * @brief Sets fiplayer callbacks.
- *
- * @param player The RTFiPlayer object pointer.
- * @param callbacks The {@link RTFiPlayerCallbacks} instance used to receive fiplayer messages.
- * @since 1.0
- * @version 1.0
- */
-void RTFiPlayer_SetCallback(struct RTFiPlayer *player, struct RTFiPlayerCallback *callbacks);
-
-
-//rt_status_t RTPlayer_SetVolume(struct RTPlayer *player, float left, float right);
-
-
-//rt_status_t RTPlayer_SetSpeed(struct RTPlayer *player, float speed, float pitch);
-
-
-//rt_status_t RTPlayer_Invoke(struct RTPlayer *player, Parcel *request, Parcel *reply);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // AMEBA_FWK_MEDIA_PLAYBACK_MEDIA_RTFIPLAYER_H
-/** @} */
\ No newline at end of file
diff --git a/os/board/rtl8730e/src/component/audio/interfaces/media/rtstream_source.h b/os/board/rtl8730e/src/component/audio/interfaces/media/rtstream_source.h
deleted file mode 100755
index 7483a40cb..000000000
--- a/os/board/rtl8730e/src/component/audio/interfaces/media/rtstream_source.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 2021 Realtek, LLC.
- * All rights reserved.
- *
- * Licensed under the Realtek License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License from Realtek
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @addtogroup Media
- * @{
- *
- * @brief Declares APIs for RTStreamSource.
- *
- *
- * @since 1.0
- * @version 1.0
- */
-
-/**
- * @file rtstream_source.h
- *
- *
- * @since 1.0
- * @version 1.0
- */
-
-#ifndef AMEBA_FWK_MEDIA_PLAYBACK_MEDIA_RTSTREAM_SOURCE_H
-#define AMEBA_FWK_MEDIA_PLAYBACK_MEDIA_RTSTREAM_SOURCE_H
-
-#include <stddef.h>
-
-#include "osal_c/osal_types.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct RTStreamSource RTStreamSource;
-
-struct RTStreamSource {
-
-	void (*SetBuffers)(const RTStreamSource *source, size_t buffer_num, size_t buffer_size);
-
-	bool (*OnBufferAvailable)(const RTStreamSource *source, size_t index);
-
-	void (*QueueBuffer)(const RTStreamSource *source, void *data, size_t size);
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // AMEBA_FWK_MEDIA_PLAYBACK_MEDIA_RTSTREAM_SOURCE_H
-/** @} */
diff --git a/os/board/rtl8730e/src/component/mbed/targets/hal/rtl8730e/i2s_api.c b/os/board/rtl8730e/src/component/mbed/targets/hal/rtl8730e/i2s_api.c
index 7d5af5064..4203fbdd1 100755
--- a/os/board/rtl8730e/src/component/mbed/targets/hal/rtl8730e/i2s_api.c
+++ b/os/board/rtl8730e/src/component/mbed/targets/hal/rtl8730e/i2s_api.c
@@ -17,6 +17,8 @@
 #include "objects.h"
 #include "i2s_api.h"
 #include "ameba_soc.h"
+#include "ameba_audio_clock.h"
+#include "amebasmart_i2s.h"
 
 #define SP_MAX_DMA_PAGE_NUM 8
 
@@ -35,57 +37,57 @@
 
 typedef struct {
 	VOID (*TxCCB)(uint32_t id, char *pbuf);
-	u32 TxCBId;
+	uint32_t TxCBId;
 	VOID (*RxCCB)(uint32_t id, char *pbuf);
-	u32 RxCBId;
+	uint32_t RxCBId;
 } I2S_USER_CB;
 
 typedef struct {
-	u8 tx_gdma_own;
-	u32 tx_addr;
+	uint8_t tx_gdma_own;
+	uint32_t tx_addr;
 } TX_BLOCK, *pTX_BLOCK;
 
 typedef struct {
 	TX_BLOCK tx_block[SP_MAX_DMA_PAGE_NUM];
 	TX_BLOCK tx_zero_block;
-	u8 tx_gdma_cnt;
-	u8 tx_usr_cnt;
-	u8 tx_empty_flag;
-	u8 tx_page_num;
-	u16 tx_page_size;
+	uint8_t tx_gdma_cnt;
+	uint8_t tx_usr_cnt;
+	uint8_t tx_empty_flag;
+	uint8_t tx_page_num;
+	uint16_t tx_page_size;
 
 } SP_TX_INFO, *pSP_TX_INFO;
 
 typedef struct {
-	u8 rx_gdma_own;
-	u32 rx_addr;
+	uint8_t rx_gdma_own;
+	uint32_t rx_addr;
 
 } RX_BLOCK, *pRX_BLOCK;
 
 typedef struct {
 	RX_BLOCK rx_block[SP_MAX_DMA_PAGE_NUM];
 	RX_BLOCK rx_full_block;
-	u8 rx_gdma_cnt;
-	u8 rx_usr_cnt;
-	u8 rx_full_flag;
-	u8 rx_page_num;
-	u16 rx_page_size;
+	uint8_t rx_gdma_cnt;
+	uint8_t rx_usr_cnt;
+	uint8_t rx_full_flag;
+	uint8_t rx_page_num;
+	uint16_t rx_page_size;
 
 } SP_RX_INFO, *pSP_RX_INFO;
 
 typedef struct {
-	GDMA_InitTypeDef       	SpTxGdmaInitStruct;
-	GDMA_InitTypeDef       	SpRxGdmaInitStruct;
-} SP_GDMA_STRUCT, *pSP_GDMA_STRUCT;
-
-static SP_InitTypeDef SP_InitStruct;
-static SP_GDMA_STRUCT SPGdmaStruct;
-static SP_TX_INFO sp_tx_info;
-static SP_RX_INFO sp_rx_info;
-static I2S_USER_CB I2SUserCB; //Pointer to I2S User Callback
-static struct GDMA_CH_LLI LliTx[SP_MAX_DMA_PAGE_NUM];
-static struct GDMA_CH_LLI LliRx[SP_MAX_DMA_PAGE_NUM];
-
+	GDMA_InitTypeDef       SpTxGdmaInitStruct;	/* Pointer to GDMA_InitTypeDef */
+	GDMA_InitTypeDef       SpRxGdmaInitStruct;	/* Pointer to GDMA_InitTypeDef */
+	uint8_t                i2s_idx;
+} SP_GDMA_STRUCT;
+
+static SP_InitTypeDef SP_InitStruct[I2S_NUM_MAX];
+static SP_GDMA_STRUCT SPGdmaStruct[I2S_NUM_MAX];
+static SP_TX_INFO sp_tx_info[I2S_NUM_MAX];
+static SP_RX_INFO sp_rx_info[I2S_NUM_MAX];
+static I2S_USER_CB I2SUserCB[I2S_NUM_MAX]; /* Pointer to I2S User Callback */
+static struct GDMA_CH_LLI LliTx[I2S_NUM_MAX][SP_MAX_DMA_PAGE_NUM];
+static struct GDMA_CH_LLI LliRx[I2S_NUM_MAX][SP_MAX_DMA_PAGE_NUM];
 
 /**
   * @}
@@ -95,93 +97,99 @@ static struct GDMA_CH_LLI LliRx[SP_MAX_DMA_PAGE_NUM];
   * @{
   */
 
-static void i2s_release_tx_page(void)
+static void i2s_release_tx_page(uint8_t i2s_index)
 {
-	pTX_BLOCK ptx_block = &(sp_tx_info.tx_block[sp_tx_info.tx_gdma_cnt]);
+	pTX_BLOCK ptx_block = &(sp_tx_info[i2s_index].tx_block[sp_tx_info[i2s_index].tx_gdma_cnt]);
 
-	if (sp_tx_info.tx_empty_flag) {
+	if (sp_tx_info[i2s_index].tx_empty_flag) {
 	} else {
 		ptx_block->tx_gdma_own = 0;
-		sp_tx_info.tx_gdma_cnt++;
-		if (sp_tx_info.tx_gdma_cnt == sp_tx_info.tx_page_num) {
-			sp_tx_info.tx_gdma_cnt = 0;
+		sp_tx_info[i2s_index].tx_gdma_cnt++;
+		if (sp_tx_info[i2s_index].tx_gdma_cnt == sp_tx_info[i2s_index].tx_page_num) {
+			sp_tx_info[i2s_index].tx_gdma_cnt = 0;
 		}
 	}
 }
 
-static u32 *i2s_get_ready_tx_page(void)
+static uint32_t *i2s_get_ready_tx_page(uint8_t i2s_index)
 {
-	pTX_BLOCK ptx_block = &(sp_tx_info.tx_block[sp_tx_info.tx_gdma_cnt]);
+	pTX_BLOCK ptx_block = &(sp_tx_info[i2s_index].tx_block[sp_tx_info[i2s_index].tx_gdma_cnt]);
 
 	if (ptx_block->tx_gdma_own) {
-		sp_tx_info.tx_empty_flag = 0;
-		return (u32 *)ptx_block->tx_addr;
+		sp_tx_info[i2s_index].tx_empty_flag = 0;
+		return (uint32_t *)ptx_block->tx_addr;
 	} else {
-		sp_tx_info.tx_empty_flag = 1;
-		return (u32 *)sp_tx_info.tx_zero_block.tx_addr;	//for audio buffer empty case
+		sp_tx_info[i2s_index].tx_empty_flag = 1;
+		return (uint32_t *)sp_tx_info[i2s_index].tx_zero_block.tx_addr;	//for audio buffer empty case
 	}
 }
 
-static void i2s_release_rx_page(void)
+static void i2s_release_rx_page(uint8_t i2s_index)
 {
-	pRX_BLOCK prx_block = &(sp_rx_info.rx_block[sp_rx_info.rx_gdma_cnt]);
+	pRX_BLOCK prx_block = &(sp_rx_info[i2s_index].rx_block[sp_rx_info[i2s_index].rx_gdma_cnt]);
 
-	if (sp_rx_info.rx_full_flag) {
+	if (sp_rx_info[i2s_index].rx_full_flag) {
 	} else {
 		prx_block->rx_gdma_own = 0;
-		sp_rx_info.rx_gdma_cnt++;
-		if (sp_rx_info.rx_gdma_cnt == sp_rx_info.rx_page_num) {
-			sp_rx_info.rx_gdma_cnt = 0;
+		sp_rx_info[i2s_index].rx_gdma_cnt++;
+		if (sp_rx_info[i2s_index].rx_gdma_cnt == sp_rx_info[i2s_index].rx_page_num) {
+			sp_rx_info[i2s_index].rx_gdma_cnt = 0;
 		}
 	}
 }
 
-static u32 *i2s_get_free_rx_page(void)
+static uint32_t *i2s_get_free_rx_page(uint8_t i2s_index)
 {
-	pRX_BLOCK prx_block = &(sp_rx_info.rx_block[sp_rx_info.rx_gdma_cnt]);
-
+	pRX_BLOCK prx_block = &(sp_rx_info[i2s_index].rx_block[sp_rx_info[i2s_index].rx_gdma_cnt]);
 
 	if (prx_block->rx_gdma_own) {
-		sp_rx_info.rx_full_flag = 0;
-		return (u32 *)prx_block->rx_addr;
+		sp_rx_info[i2s_index].rx_full_flag = 0;
+		return (uint32_t *)prx_block->rx_addr;
 	} else {
-
-		sp_rx_info.rx_full_flag = 1;
-		return (u32 *)sp_rx_info.rx_full_block.rx_addr;	//for audio buffer full case
+		sp_rx_info[i2s_index].rx_full_flag = 1;
+		return (uint32_t *)sp_rx_info[i2s_index].rx_full_block.rx_addr;	//for audio buffer full case
 	}
 }
 
-static void i2s_tx_isr(void)
+static void i2s_tx_isr(void *sp_data)
 {
-	SP_GDMA_STRUCT *gs = &SPGdmaStruct;
+	u32 pbuf;
+	SP_GDMA_STRUCT *gs = sp_data;
 	PGDMA_InitTypeDef GDMA_InitStruct;
 	GDMA_InitStruct = &(gs->SpTxGdmaInitStruct);
 
+	uint8_t i2s_index = gs->i2s_idx;
+
 	/* Clear Pending ISR */
 	GDMA_ClearINT(GDMA_InitStruct->GDMA_Index, GDMA_InitStruct->GDMA_ChNum);
 
-	i2s_release_tx_page();
-	i2s_get_ready_tx_page();
+	i2s_release_tx_page(i2s_index);
+	pbuf = i2s_get_ready_tx_page(i2s_index);
+	I2SUserCB[i2s_index].TxCCB(I2SUserCB[i2s_index].TxCBId, (char*)pbuf);
+
+
 }
 
-static void i2s_rx_isr(void)
+static void i2s_rx_isr(void *sp_data)
 {
-	SP_GDMA_STRUCT *gs = &SPGdmaStruct;
+	SP_GDMA_STRUCT *gs = sp_data;
 	PGDMA_InitTypeDef GDMA_InitStruct;
 	GDMA_InitStruct = &(gs->SpRxGdmaInitStruct);
 
+	uint8_t i2s_index = gs->i2s_idx;
+
 	/* Clear Pending ISR */
 	GDMA_ClearINT(GDMA_InitStruct->GDMA_Index, GDMA_InitStruct->GDMA_ChNum);
-	i2s_release_rx_page();
+	i2s_release_rx_page(i2s_index);
 
-	//read data
-	pRX_BLOCK prx_block = &(sp_rx_info.rx_block[sp_rx_info.rx_usr_cnt]);
-	DCache_CleanInvalidate((u32)prx_block->rx_addr, sp_rx_info.rx_page_size);
-	I2SUserCB.RxCCB(NULL, (void *)(u32)prx_block->rx_addr);
-	i2s_get_free_rx_page();
+	/* Read data */
+	pRX_BLOCK prx_block = &(sp_rx_info[i2s_index].rx_block[sp_rx_info[i2s_index].rx_usr_cnt]);
+	DCache_CleanInvalidate((uint32_t)prx_block->rx_addr, sp_rx_info[i2s_index].rx_page_size);
+	I2SUserCB[i2s_index].RxCCB((uint32_t)NULL, (void *)(uint32_t)prx_block->rx_addr);
+	i2s_get_free_rx_page(i2s_index);
 }
 
-static void i2s_pinmux_config(u32 pin_name, u32 pin_func)
+static void i2s_pinmux_config(uint32_t pin_name, uint32_t pin_func)
 {
 	if (pin_name != _PNC) {
 		Pinmux_Config(pin_name, pin_func);
@@ -190,64 +198,6 @@ static void i2s_pinmux_config(u32 pin_name, u32 pin_func)
 	}
 }
 
-/**
-  * @brief  Initialize the I2S device, including clock, function, interrupt and I2S registers.
-  * @param  obj: I2S object defined in application software.
-  * @param  sck: Serial clock PinName according to pinmux spec.
-  * @param  ws: Word select PinName according to pinmux spec.
-  * @param  sd_tx: Tx PinName according to pinmux spec.
-  * @param  sd_rx: Rx PinName according to pinmux spec.
-  * @param  mck: Master clock PinName according to pinmux spec.
-  * @retval none
-  */
-void i2s_init(i2s_t *obj, PinName sck, PinName ws, PinName sd_tx, PinName sd_rx, PinName mck)
-{
-	obj->i2s_idx = 2;
-	DBG_PRINTF(MODULE_I2S, LEVEL_INFO, "%s: Use I2S%d \n", __func__, obj->i2s_idx);
-
-	assert_param(IS_SP_SEL_I2S(obj->i2s_idx));
-
-	u32 pin_func;
-
-	if (obj->i2s_idx == I2S2) {
-		pin_func = PINMUX_FUNCTION_I2S2;
-	} else {
-		pin_func = PINMUX_FUNCTION_I2S3;
-	}
-
-	i2s_pinmux_config(sck, pin_func);
-	i2s_pinmux_config(ws, pin_func);
-	i2s_pinmux_config(sd_tx, pin_func);
-	i2s_pinmux_config(sd_rx, pin_func);
-	i2s_pinmux_config(mck, pin_func);
-
-	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[obj->i2s_idx].SPORTx;
-	/*Sport Init*/
-	AUDIO_SP_Reset(SPORTx);
-	AUDIO_SP_StructInit(&SP_InitStruct);
-	SP_InitStruct.SP_SelI2SMonoStereo = obj->channel_num;
-	SP_InitStruct.SP_SelChLen = obj->channel_length;
-	SP_InitStruct.SP_SelWordLen = obj->word_length;
-	SP_InitStruct.SP_SR = obj->sampling_rate;
-	SP_InitStruct.SP_SelFIFO = obj->fifo_num;
-	SP_InitStruct.SP_SelTDM = obj->fifo_num;
-	SP_InitStruct.SP_SelClk = obj->clock;
-
-	if (obj->direction == I2S_DIR_TX) {
-		if (obj->mode == MULTIIO) {
-			SP_InitStruct.SP_SetMultiIO = SP_TX_MULTIIO_EN;
-		}
-		AUDIO_SP_Init(obj->i2s_idx, SP_DIR_TX, &SP_InitStruct);
-	} else {
-		if (obj->mode == MULTIIO) {
-			SP_InitStruct.SP_SetMultiIO = SP_RX_MULTIIO_EN;
-		}
-		AUDIO_SP_Init(obj->i2s_idx, SP_DIR_RX, &SP_InitStruct);
-	}
-
-	AUDIO_SP_SetMasterSlave(SPORTx, obj->role);  //only smart support, testchip not support.
-}
-
 /**
   * @brief  Set page number, page size and page address.
   * @param  obj: I2S object defined in application software.
@@ -260,8 +210,8 @@ void i2s_init(i2s_t *obj, PinName sck, PinName ws, PinName sd_tx, PinName sd_rx,
 void i2s_set_dma_buffer(i2s_t *obj, char *tx_buf, char *rx_buf,
 						uint32_t page_num, uint32_t page_size)
 {
-	//uint8_t i2s_idx = obj->i2s_idx;
-	u32 i, j;
+	uint8_t i2s_idx = obj->i2s_idx;
+	uint32_t i, j;
 
 	if ((page_num < 2) || (page_num > 8) || (page_size < 8)) {
 		DBG_PRINTF(MODULE_I2S, LEVEL_INFO, "%s: PageNum(%d) valid value is 2~8; PageSize(%d must > 8)\r\n", \
@@ -271,65 +221,64 @@ void i2s_set_dma_buffer(i2s_t *obj, char *tx_buf, char *rx_buf,
 
 	if (obj->direction == I2S_DIR_TX) {
 
-		sp_tx_info.tx_gdma_cnt = 0;
-		sp_tx_info.tx_usr_cnt = 0;
-		sp_tx_info.tx_empty_flag = 0;
+		sp_tx_info[i2s_idx].tx_gdma_cnt = 0;
+		sp_tx_info[i2s_idx].tx_usr_cnt = 0;
+		sp_tx_info[i2s_idx].tx_empty_flag = 0;
 
 		for (i = 0; i < page_num; i++) {
-			sp_tx_info.tx_block[i].tx_gdma_own = 0;
-			sp_tx_info.tx_block[i].tx_addr = (u32)tx_buf + i * page_size;
+			sp_tx_info[i2s_idx].tx_block[i].tx_gdma_own = 0;
+			sp_tx_info[i2s_idx].tx_block[i].tx_addr = (uint32_t)tx_buf + i * page_size;
 		}
 
-		sp_tx_info.tx_zero_block.tx_addr = (u32)tx_buf + page_num * page_size;
+		sp_tx_info[i2s_idx].tx_zero_block.tx_addr = (uint32_t)tx_buf + page_num * page_size;
 
 		for (i = 0; i < page_size; i++) {
-			((u8 *)(sp_tx_info.tx_zero_block.tx_addr))[i] = 0;
+			((uint8_t *)(sp_tx_info[i2s_idx].tx_zero_block.tx_addr))[i] = 0;
 		}
 
-		sp_tx_info.tx_page_size = page_size;
-		sp_tx_info.tx_page_num = page_num;
+		sp_tx_info[i2s_idx].tx_page_size = page_size;
+		sp_tx_info[i2s_idx].tx_page_num = page_num;
 
 		for (j = 0; j < page_num + 1; j++) {
 
 			if (j == 0) {
-				LliTx[j].LliEle.Sarx = (u32)tx_buf + (page_num) * page_size;
+				LliTx[i2s_idx][j].LliEle.Sarx = (uint32_t)tx_buf + (page_num) * page_size;
 			} else {
-				LliTx[j].LliEle.Sarx = (u32)tx_buf + (j - 1) * page_size;
+				LliTx[i2s_idx][j].LliEle.Sarx = (uint32_t)tx_buf + (j - 1) * page_size;
 			}
 
 			if (j == page_num) {
-				LliTx[j].pNextLli = &LliTx[1];
+				LliTx[i2s_idx][j].pNextLli = &LliTx[i2s_idx][1];
 			} else {
-				LliTx[j].pNextLli = &LliTx[j + 1];
+				LliTx[i2s_idx][j].pNextLli = &LliTx[i2s_idx][j + 1];
 			}
 
 		}
 	} else {
-
-		sp_rx_info.rx_gdma_cnt = 0;
-		sp_rx_info.rx_usr_cnt = 0;
-		sp_rx_info.rx_full_flag = 0;
+		sp_rx_info[i2s_idx].rx_gdma_cnt = 0;
+		sp_rx_info[i2s_idx].rx_usr_cnt = 0;
+		sp_rx_info[i2s_idx].rx_full_flag = 0;
 
 		for (i = 0; i < page_num; i++) {
-			sp_rx_info.rx_block[i].rx_gdma_own = 1;
-			sp_rx_info.rx_block[i].rx_addr = (u32)rx_buf + i * page_size;
+			sp_rx_info[i2s_idx].rx_block[i].rx_gdma_own = 1;
+			sp_rx_info[i2s_idx].rx_block[i].rx_addr = (uint32_t)rx_buf + i * page_size;
 		}
 
-		sp_rx_info.rx_full_block.rx_addr = (u32)rx_buf + page_num * page_size;
+		sp_rx_info[i2s_idx].rx_full_block.rx_addr = (uint32_t)rx_buf + page_num * page_size;
 
 		for (i = 0; i < page_size; i++) {
-			((u8 *)(sp_rx_info.rx_full_block.rx_addr))[i] = 0;
+			((uint8_t *)(sp_rx_info[i2s_idx].rx_full_block.rx_addr))[i] = 0;
 		}
 
-		sp_rx_info.rx_page_size = page_size;
-		sp_rx_info.rx_page_num = page_num;
+		sp_rx_info[i2s_idx].rx_page_size = page_size;
+		sp_rx_info[i2s_idx].rx_page_num = page_num;
 
 		for (j = 0; j < page_num; j++) {
-			LliRx[j].LliEle.Darx = (u32)rx_buf + j * page_size;
+			LliRx[i2s_idx][j].LliEle.Darx = (uint32_t)rx_buf + j * page_size;
 			if (j == page_num - 1) {
-				LliRx[j].pNextLli = &LliRx[0];
+				LliRx[i2s_idx][j].pNextLli = &LliRx[i2s_idx][0];
 			} else {
-				LliRx[j].pNextLli = &LliRx[j + 1];
+				LliRx[i2s_idx][j].pNextLli = &LliRx[i2s_idx][j + 1];
 			}
 		}
 	}
@@ -345,13 +294,17 @@ void i2s_set_dma_buffer(i2s_t *obj, char *tx_buf, char *rx_buf,
   */
 void i2s_tx_irq_handler(i2s_t *obj, i2s_irq_handler handler, uint32_t id)
 {
-	(void) obj;
-	(void) handler;
-	(void) id;
+	uint8_t i2s_index = obj->i2s_idx;
+	SP_GDMA_STRUCT *sp_str = &SPGdmaStruct[i2s_index];
+	sp_str->i2s_idx = i2s_index;	/* Store I2S index */
+
+	I2SUserCB[i2s_index].TxCCB = handler;
+	I2SUserCB[i2s_index].TxCBId = id;
 
-	i2s_get_ready_tx_page();
-	AUDIO_SP_LLPTXGDMA_Init(obj->i2s_idx, GDMA_INT, &SPGdmaStruct.SpTxGdmaInitStruct, &SPGdmaStruct, (IRQ_FUN)i2s_tx_isr, sp_tx_info.tx_page_size,
-							sp_tx_info.tx_page_num + 1, LliTx);
+	i2s_get_ready_tx_page(i2s_index);
+	AUDIO_SP_LLPTXGDMA_Init(i2s_index, GDMA_INT, &sp_str->SpTxGdmaInitStruct, sp_str, (IRQ_FUN)i2s_tx_isr, sp_tx_info[i2s_index].tx_page_size,
+							sp_tx_info[i2s_index].tx_page_num + 1, LliTx[i2s_index]);
+	
 }
 
 /**
@@ -363,14 +316,16 @@ void i2s_tx_irq_handler(i2s_t *obj, i2s_irq_handler handler, uint32_t id)
   */
 void i2s_rx_irq_handler(i2s_t *obj, i2s_irq_handler handler, uint32_t id)
 {
-	(void) obj;
-	(void) id;
+	uint8_t i2s_index = obj->i2s_idx;
+	SP_GDMA_STRUCT *sp_str = &SPGdmaStruct[i2s_index];
+	sp_str->i2s_idx = i2s_index;	/* Store I2S index */
 
-	I2SUserCB.RxCCB = handler;
+	I2SUserCB[i2s_index].RxCCB = handler;
+	I2SUserCB[i2s_index].RxCBId = id;
 
-	i2s_get_free_rx_page();
-	AUDIO_SP_LLPRXGDMA_Init(obj->i2s_idx, GDMA_INT, &SPGdmaStruct.SpRxGdmaInitStruct, &SPGdmaStruct, (IRQ_FUN)i2s_rx_isr, sp_rx_info.rx_page_size,
-							sp_rx_info.rx_page_num, LliRx);
+	i2s_get_free_rx_page(i2s_index);
+	AUDIO_SP_LLPRXGDMA_Init(i2s_index, GDMA_INT, &sp_str->SpRxGdmaInitStruct, sp_str, (IRQ_FUN)i2s_rx_isr, sp_rx_info[i2s_index].rx_page_size,
+							sp_rx_info[i2s_index].rx_page_num, LliRx[i2s_index]);
 }
 
 /**
@@ -385,11 +340,7 @@ void i2s_set_direction(i2s_t *obj, int trx_type)
 {
 	obj->direction = trx_type;
 
-	if (trx_type == I2S_DIR_TX) {
-		AUDIO_SP_Init(obj->i2s_idx, SP_DIR_TX, &SP_InitStruct);
-	} else {
-		AUDIO_SP_Init(obj->i2s_idx, SP_DIR_RX, &SP_InitStruct);
-	}
+	AUDIO_SP_Init(obj->i2s_idx, obj->direction, &(SP_InitStruct[obj->i2s_idx]));
 }
 
 /**
@@ -422,21 +373,99 @@ void i2s_set_direction(i2s_t *obj, int trx_type)
   */
 void i2s_set_param(i2s_t *obj, int channel_num, int rate, int word_len)
 {
+	uint32_t clock_mode;
+	AUDIO_ClockParams Clock_Params;
+	AUDIO_InitParams Init_Params;
+
 	obj->channel_num = channel_num;
 	obj->sampling_rate = rate;
 	obj->word_length = word_len;
 
-	SP_InitStruct.SP_SelI2SMonoStereo = channel_num;
-	SP_InitStruct.SP_SelWordLen = word_len;
-	SP_InitStruct.SP_SR = rate;
+	Init_Params.chn_len = SP_CL_32;
+	Init_Params.chn_cnt = obj->channel_num;
+	Init_Params.sr = obj->sampling_rate;;
+	Init_Params.codec_multiplier_with_rate = 256;
+	Init_Params.sport_mclk_fixed_max = (uint32_t) NULL;
+	Audio_Clock_Choose(PLL_CLK, &Init_Params, &Clock_Params);
+	obj->clock = Clock_Params.Clock;
+
+	switch (Clock_Params.Clock) {
+	case PLL_CLOCK_24P576M:
+		PLL_I2S_24P576M(ENABLE);
+		RCC_PeriphClockSource_SPORT(obj->i2s_idx, CKSL_I2S_PLL24M);
+		PLL_I2S_Div(obj->i2s_idx, Clock_Params.PLL_DIV);
+		clock_mode = PLL_CLOCK_24P576M / Clock_Params.PLL_DIV;
+		break;
+
+	case PLL_CLOCK_98P304M:
+		PLL_I2S_98P304M(ENABLE);
+		RCC_PeriphClockSource_SPORT(obj->i2s_idx, CKSL_I2S_PLL98M);
+		PLL_I2S_Div(obj->i2s_idx, Clock_Params.PLL_DIV);
+		clock_mode = PLL_CLOCK_98P304M / Clock_Params.PLL_DIV;
+		break;
+	}
 
-	if (obj->direction == I2S_DIR_TX) {
-		AUDIO_SP_Init(obj->i2s_idx, SP_DIR_TX, &SP_InitStruct);
+	/* Sport Init */
+	AUDIO_SP_Reset(obj->i2s_idx);
+	AUDIO_SP_StructInit(&SP_InitStruct[obj->i2s_idx]);
+
+	SP_InitStruct[obj->i2s_idx].SP_SelFIFO = obj->fifo_num;
+	SP_InitStruct[obj->i2s_idx].SP_SelChLen = obj->channel_length;
+	SP_InitStruct[obj->i2s_idx].SP_SetMultiIO = obj->mode;
+	SP_InitStruct[obj->i2s_idx].SP_SR = obj->sampling_rate;
+	SP_InitStruct[obj->i2s_idx].SP_SelClk = clock_mode;
+	AUDIO_SP_Init(obj->i2s_idx, obj->direction, &(SP_InitStruct[obj->i2s_idx]));
+	AUDIO_SP_SetMasterSlave(obj->i2s_idx, obj->role);
+
+	if (obj->direction == SP_DIR_TX) {
+		AUDIO_SP_TXCHNSrcSel(obj->i2s_idx, TXCHN2, TX_FIFO0_REG0_L);
+		AUDIO_SP_TXCHNSrcSel(obj->i2s_idx, TXCHN3, TX_FIFO0_REG0_R);
 	} else {
-		AUDIO_SP_Init(obj->i2s_idx, SP_DIR_RX, &SP_InitStruct);
+		AUDIO_SP_RXFIFOSrcSel(obj->i2s_idx, RX_FIFO0_REG0_L, RXCHN6);
+		AUDIO_SP_RXFIFOSrcSel(obj->i2s_idx, RX_FIFO0_REG0_R, RXCHN7);
 	}
 }
 
+
+/**
+  * @brief  Initialize the I2S device, including clock, function, interrupt and I2S registers.
+  * @param  obj: I2S object defined in application software.
+  * @param  sck: Serial clock PinName according to pinmux spec.
+  * @param  ws: Word select PinName according to pinmux spec.
+  * @param  sd_tx: Tx PinName according to pinmux spec.
+  * @param  sd_rx: Rx PinName according to pinmux spec.
+  * @param  mck: Master clock PinName according to pinmux spec.
+  * @retval none
+  */
+void i2s_init(i2s_t *obj, PinName sck, PinName ws, PinName sd_tx, PinName sd_rx, PinName mck)
+{
+	uint32_t pin_func;
+
+	assert_param(IS_SP_SEL_I2S(obj->i2s_idx));
+
+	if (obj->i2s_idx == I2S_NUM_2) {
+		pin_func = PINMUX_FUNCTION_I2S2;
+
+		/*Enable SPORT/AUDIO CODEC CLOCK and Function*/
+		RCC_PeriphClockCmd(APBPeriph_SPORT2, APBPeriph_SPORT2_CLOCK, ENABLE);
+	} else {
+		pin_func = PINMUX_FUNCTION_I2S3;
+
+		/*Enable SPORT/AUDIO CODEC CLOCK and Function*/
+		RCC_PeriphClockCmd(APBPeriph_SPORT3, APBPeriph_SPORT3_CLOCK, ENABLE);
+	}
+
+	i2s_pinmux_config(mck, pin_func);
+	i2s_pinmux_config(sck, pin_func);
+	i2s_pinmux_config(ws, pin_func);
+	i2s_pinmux_config(sd_tx, pin_func);
+	i2s_pinmux_config(sd_rx, pin_func);
+
+	i2s_set_param(obj, obj->channel_num, obj->sampling_rate, obj->word_length);
+
+
+}
+
 /**
   * @brief  Deinitialize the I2S device, including function, interrupt and I2S registers.
   * @param  obj: I2S object defined in application software.
@@ -444,7 +473,15 @@ void i2s_set_param(i2s_t *obj, int channel_num, int rate, int word_len)
   */
 void i2s_deinit(i2s_t *obj)
 {
-	PLL_I2S_98P304M(DISABLE);
+	switch (obj->clock) {
+	case PLL_CLOCK_24P576M:
+		PLL_I2S_24P576M(DISABLE);
+		break;
+
+	case PLL_CLOCK_98P304M:
+		PLL_I2S_98P304M(DISABLE);
+		break;
+	}
 
 	if (obj->i2s_idx == I2S2) {
 		RCC_PeriphClockCmd(APBPeriph_SPORT2, APBPeriph_SPORT2_CLOCK, DISABLE);
@@ -460,10 +497,9 @@ void i2s_deinit(i2s_t *obj)
   */
 int *i2s_get_tx_page(i2s_t *obj)
 {
-	/* To avoid gcc warnings */
-	(void) obj;
+	uint8_t i2s_index = obj->i2s_idx;
 
-	pTX_BLOCK ptx_block = &(sp_tx_info.tx_block[sp_tx_info.tx_usr_cnt]);
+	pTX_BLOCK ptx_block = &(sp_tx_info[i2s_index].tx_block[sp_tx_info[i2s_index].tx_usr_cnt]);
 
 	if (ptx_block->tx_gdma_own) {
 		return NULL;
@@ -481,19 +517,17 @@ int *i2s_get_tx_page(i2s_t *obj)
   */
 void i2s_send_page(i2s_t *obj, uint32_t *pbuf)
 {
-	/* To avoid gcc warnings */
-	(void) obj;
+	uint8_t i2s_index = obj->i2s_idx;
 
-	pTX_BLOCK ptx_block = &(sp_tx_info.tx_block[sp_tx_info.tx_usr_cnt]);
+	pTX_BLOCK ptx_block = &(sp_tx_info[i2s_index].tx_block[sp_tx_info[i2s_index].tx_usr_cnt]);
 
-	memcpy((void *)ptx_block->tx_addr, pbuf, sp_tx_info.tx_page_size);
-	DCache_CleanInvalidate((u32)ptx_block->tx_addr, sp_tx_info.tx_page_size);
+	memcpy((void *)ptx_block->tx_addr, pbuf, sp_tx_info[i2s_index].tx_page_size);
+	DCache_CleanInvalidate((uint32_t)ptx_block->tx_addr, sp_tx_info[i2s_index].tx_page_size);
 	ptx_block->tx_gdma_own = 1;
-	sp_tx_info.tx_usr_cnt++;
-	if (sp_tx_info.tx_usr_cnt == sp_tx_info.tx_page_num) {
-		sp_tx_info.tx_usr_cnt = 0;
+	sp_tx_info[i2s_index].tx_usr_cnt++;
+	if (sp_tx_info[i2s_index].tx_usr_cnt == sp_tx_info[i2s_index].tx_page_num) {
+		sp_tx_info[i2s_index].tx_usr_cnt = 0;
 	}
-
 }
 
 /**
@@ -503,17 +537,15 @@ void i2s_send_page(i2s_t *obj, uint32_t *pbuf)
   */
 void i2s_recv_page(i2s_t *obj)
 {
-	/* To avoid gcc warnings */
-	(void) obj;
+	uint8_t i2s_index = obj->i2s_idx;
 
-	pRX_BLOCK prx_block = &(sp_rx_info.rx_block[sp_rx_info.rx_usr_cnt]);
+	pRX_BLOCK prx_block = &(sp_rx_info[i2s_index].rx_block[sp_rx_info[i2s_index].rx_usr_cnt]);
 
 	prx_block->rx_gdma_own = 1;
-	sp_rx_info.rx_usr_cnt++;
-	if (sp_rx_info.rx_usr_cnt == sp_rx_info.rx_page_num) {
-		sp_rx_info.rx_usr_cnt = 0;
+	sp_rx_info[i2s_index].rx_usr_cnt++;
+	if (sp_rx_info[i2s_index].rx_usr_cnt == sp_rx_info[i2s_index].rx_page_num) {
+		sp_rx_info[i2s_index].rx_usr_cnt = 0;
 	}
-
 }
 
 /**
@@ -523,18 +555,12 @@ void i2s_recv_page(i2s_t *obj)
   */
 void i2s_enable(i2s_t *obj)
 {
-
-	/* To avoid gcc warnings */
-	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[obj->i2s_idx].SPORTx;
-
+	AUDIO_SP_DmaCmd(obj->i2s_idx, ENABLE);
 	if (obj->direction == I2S_DIR_TX) {
-		AUDIO_SP_DmaCmd(SPORTx, ENABLE);
-		AUDIO_SP_TXStart(SPORTx, ENABLE);
+		AUDIO_SP_TXStart(obj->i2s_idx, ENABLE);
 	} else {
-		AUDIO_SP_DmaCmd(SPORTx, ENABLE);
-		AUDIO_SP_RXStart(SPORTx, ENABLE);
+		AUDIO_SP_RXStart(obj->i2s_idx, ENABLE);
 	}
-
 }
 
 /**
@@ -544,37 +570,46 @@ void i2s_enable(i2s_t *obj)
   */
 void i2s_disable(i2s_t *obj)
 {
-	/* To avoid gcc warnings */
-	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[obj->i2s_idx].SPORTx;
+	SP_GDMA_STRUCT *l_SPGdmaStruct = &SPGdmaStruct[obj->i2s_idx];
 
 	if (obj->direction == I2S_DIR_TX) {
-		GDMA_ClearINT(SPGdmaStruct.SpTxGdmaInitStruct.GDMA_Index, SPGdmaStruct.SpTxGdmaInitStruct.GDMA_ChNum);
-		GDMA_Cmd(SPGdmaStruct.SpTxGdmaInitStruct.GDMA_Index, SPGdmaStruct.SpTxGdmaInitStruct.GDMA_ChNum, DISABLE);
-		GDMA_ChnlFree(SPGdmaStruct.SpTxGdmaInitStruct.GDMA_Index, SPGdmaStruct.SpTxGdmaInitStruct.GDMA_ChNum);
-
-		AUDIO_SP_DmaCmd(SPORTx, DISABLE);
-		AUDIO_SP_TXStart(SPORTx, DISABLE);
-
+		GDMA_ClearINT(l_SPGdmaStruct->SpTxGdmaInitStruct.GDMA_Index, l_SPGdmaStruct->SpTxGdmaInitStruct.GDMA_ChNum);
+		GDMA_Cmd(l_SPGdmaStruct->SpTxGdmaInitStruct.GDMA_Index, l_SPGdmaStruct->SpTxGdmaInitStruct.GDMA_ChNum, DISABLE);
+		/* This function will do a deinit in the gdma channe, left here for future reference
+		 * GDMA_ChnlFree(SPGdmaStruct->SpTxGdmaInitStruct.GDMA_Index, SPGdmaStruct->SpTxGdmaInitStruct.GDMA_ChNum);
+		 */
+
+		AUDIO_SP_DmaCmd(obj->i2s_idx, DISABLE);
+		AUDIO_SP_TXStart(obj->i2s_idx, DISABLE);
 	} else {
 
-		GDMA_ClearINT(SPGdmaStruct.SpRxGdmaInitStruct.GDMA_Index, SPGdmaStruct.SpRxGdmaInitStruct.GDMA_ChNum);
-		GDMA_Cmd(SPGdmaStruct.SpRxGdmaInitStruct.GDMA_Index, SPGdmaStruct.SpRxGdmaInitStruct.GDMA_ChNum, DISABLE);
-		GDMA_ChnlFree(SPGdmaStruct.SpRxGdmaInitStruct.GDMA_Index, SPGdmaStruct.SpRxGdmaInitStruct.GDMA_ChNum);
+		GDMA_ClearINT(l_SPGdmaStruct->SpRxGdmaInitStruct.GDMA_Index, l_SPGdmaStruct->SpRxGdmaInitStruct.GDMA_ChNum);
+		GDMA_Cmd(l_SPGdmaStruct->SpRxGdmaInitStruct.GDMA_Index, l_SPGdmaStruct->SpRxGdmaInitStruct.GDMA_ChNum, DISABLE);
 
-		AUDIO_SP_DmaCmd(SPORTx, DISABLE);
-		AUDIO_SP_RXStart(SPORTx, DISABLE);
+		AUDIO_SP_DmaCmd(obj->i2s_idx, DISABLE);
+		AUDIO_SP_RXStart(obj->i2s_idx, DISABLE);
 	}
-
 }
-/**
-  * @}
-  */
 
 /**
-  * @}
+  * @brief  Pause I2S interrupt and function.
+  * @param  obj: I2S object defined in application software.
+  * @retval none
   */
+void ameba_i2s_pause(i2s_t *obj) {
+
+	SP_GDMA_STRUCT *l_SPGdmaStruct = &SPGdmaStruct[obj->i2s_idx];
+	GDMA_Suspend(l_SPGdmaStruct->SpRxGdmaInitStruct.GDMA_Index, l_SPGdmaStruct->SpRxGdmaInitStruct.GDMA_ChNum);
+}
 
 /**
-  * @}
+  * @brief  Resume I2S interrupt and function.
+  * @param  obj: I2S object defined in application software.
+  * @retval none
   */
+void ameba_i2s_resume(i2s_t *obj) {
+
+	SP_GDMA_STRUCT *l_SPGdmaStruct = &SPGdmaStruct[obj->i2s_idx];
+	GDMA_Resume(l_SPGdmaStruct->SpRxGdmaInitStruct.GDMA_Index, l_SPGdmaStruct->SpRxGdmaInitStruct.GDMA_ChNum);
+}
 /******************* (C) COPYRIGHT 2016 Realtek Semiconductor *****END OF FILE****/
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_audio.h b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_audio.h
index dd87eff79..88f66c468 100755
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_audio.h
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_audio.h
@@ -4968,6 +4968,16 @@ typedef struct {
   * @}
   */
 
+/** @defgroup AUDIO_CODEC_LineOutOrHPO_Channel
+  * @{
+  */
+#define CHN_L			((u32)0x00000000)
+#define CHN_R			((u32)0x00000001)
+#define CHN_LR			((u32)0x00000002)
+/**
+  * @}
+  */
+
 /**
   * @}
   */
@@ -5030,6 +5040,12 @@ _LONG_CALL_ void AUDIO_CODEC_SetADCZDET(u32 adc_sel, u32 type);
 _LONG_CALL_ void AUDIO_CODEC_SetADCZDETTimeOut(u32 adc_sel, u32 time_out);
 _LONG_CALL_ void AUDIO_CODEC_Record(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct);
 _LONG_CALL_ void AUDIO_CODEC_Playback(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct);
+_LONG_CALL_ void AUDIO_CODEC_EnableADCFifo(u32 ad_chn, u32 newstate);
+_LONG_CALL_ void AUDIO_CODEC_EnableDACFifo(u32 newstate);
+_LONG_CALL_ void AUDIO_CODEC_SetDACSilenceDet(u32 channel, u32 status);
+_LONG_CALL_ void AUDIO_CODEC_SelDACSilenceLevel(u32 channel, u32 level);
+_LONG_CALL_ void AUDIO_CODEC_SetADCSilenceDet(u32 channel, u32 status);
+_LONG_CALL_ void AUDIO_CODEC_SelADCSilenceLevel(u32 channel, u32 level);
 
 /**
   * @}
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_gdma.h b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_gdma.h
index 7f2fa7a36..60a97001e 100755
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_gdma.h
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_gdma.h
@@ -635,10 +635,8 @@ _LONG_CALL_ void GDMA_SetDstAddr(u8 GDMA_Index, u8 GDMA_ChNum, u32 DstAddr);
 _LONG_CALL_ void GDMA_SetBlkSize(u8 GDMA_Index, u8 GDMA_ChNum, u32 BlkSize);
 _LONG_CALL_ u32	 GDMA_GetBlkSize(u8 GDMA_Index, u8 GDMA_ChNum);
 
-_LONG_CALL_ BOOL GDMA_ChnlRegister(u8 GDMA_Index, u8 GDMA_ChNum);
-_LONG_CALL_ void GDMA_ChnlUnRegister(u8 GDMA_Index, u8 GDMA_ChNum);
 _LONG_CALL_ u8	 GDMA_ChnlAlloc(u32 GDMA_Index, IRQ_FUN IrqFun, u32 IrqData, u32 IrqPriority);
-_LONG_CALL_ void GDMA_ChnlFree(u8 GDMA_Index, u8 GDMA_ChNum);
+_LONG_CALL_ u8   GDMA_ChnlFree(u8 GDMA_Index, u8 GDMA_ChNum);
 _LONG_CALL_ u8	 GDMA_GetIrqNum(u8 GDMA_Index, u8 GDMA_ChNum);
 _LONG_CALL_ void GDMA_SetChnlPriority(u8 GDMA_Index, u8 GDMA_ChNum, u32 ChnlPriority);
 _LONG_CALL_  void GDMA_Suspend(u8 GDMA_Index, u8 GDMA_ChNum);
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_pinmux.h b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_pinmux.h
index ca16c25ca..0ec590ffb 100644
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_pinmux.h
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_pinmux.h
@@ -244,6 +244,27 @@
   * @}
   */
 
+/** @defgroup PINMUX_Special_Pad_definitions
+  * @{
+  */
+#define APAD_NAME_START				_PA_18	/* PA18 & PA19 no pin output in all pkgs */
+#define APAD_NAME_END				_PB_6
+
+#define APAD_MIC_PAD__START			_PA_20
+#define APAD_MIC_PAD_END			_PA_29
+
+#define APAD_MIC_BIAS_PAD_START		_PA_30
+#define APAD_MIC_BIAS_PAD_END		_PB_2
+
+#define APAD_OUT_PAD_START			_PB_3
+#define APAD_OUT_PAD_END			_PB_6
+
+#define SWD_DATA					_PA_13
+#define	SWD_CLK						_PA_14
+/**
+  * @}
+  */
+
 /**
   * @}
   */
@@ -316,12 +337,12 @@ void APAD_InputCtrl(u8 PinName, u32 NewState)
 			RTemp = 0x0;
 		}
 	} else {
-		if (PinName < _PA_18 || PinName > _PB_6) {
+		if (PinName < APAD_NAME_START || PinName > APAD_NAME_END) {
 			return;
 		}
 
 		RTemp = HAL_READ32(PINMUX_REG_BASE, REG_PAD_AUD_PAD_CTRL);
-		PadShift = PinName - _PA_18;
+		PadShift = PinName - APAD_NAME_START;
 		if (NewState != DISABLE) {
 			RTemp |= BIT(PadShift);
 		} else {
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_sport.h b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_sport.h
index 9167389da..536e7dd40 100755
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_sport.h
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/include/ameba_sport.h
@@ -1017,6 +1017,66 @@ typedef struct {
   * @}
   */
 
+/** @defgroup AUDIO_SPORT_TXChannel
+* @{
+*/
+#define TXCHN0		((u32)0x00000000)
+#define TXCHN1		((u32)0x00000001)
+#define TXCHN2		((u32)0x00000002)
+#define TXCHN3		((u32)0x00000003)
+#define TXCHN4		((u32)0x00000004)
+#define TXCHN5		((u32)0x00000005)
+#define TXCHN6		((u32)0x00000006)
+#define TXCHN7		((u32)0x00000007)
+/**
+  * @}
+  */
+
+/** @defgroup AUDIO_SPORT_TXFIFOChannel
+* @{
+*/
+#define TX_FIFO0_REG0_L		((u32)0x00000000)
+#define TX_FIFO0_REG0_R		((u32)0x00000001)
+#define TX_FIFO0_REG1_L		((u32)0x00000002)
+#define TX_FIFO0_REG1_R		((u32)0x00000003)
+#define TX_FIFO1_REG0_L		((u32)0x00000004)
+#define TX_FIFO1_REG0_R		((u32)0x00000005)
+#define TX_FIFO1_REG1_L		((u32)0x00000006)
+#define TX_FIFO1_REG1_R		((u32)0x00000007)
+/**
+  * @}
+  */
+
+/** @defgroup AUDIO_SPORT_RXChannel
+* @{
+*/
+#define RXCHN0		((u32)0x00000000)
+#define RXCHN1		((u32)0x00000001)
+#define RXCHN2		((u32)0x00000002)
+#define RXCHN3		((u32)0x00000003)
+#define RXCHN4		((u32)0x00000004)
+#define RXCHN5		((u32)0x00000005)
+#define RXCHN6		((u32)0x00000006)
+#define RXCHN7		((u32)0x00000007)
+/**
+  * @}
+  */
+
+/** @defgroup AUDIO_SPORT_RXFIFOChannel
+* @{
+*/
+#define RX_FIFO0_REG0_L		((u32)0x00000000)
+#define RX_FIFO0_REG0_R		((u32)0x00000001)
+#define RX_FIFO0_REG1_L		((u32)0x00000002)
+#define RX_FIFO0_REG1_R		((u32)0x00000003)
+#define RX_FIFO1_REG0_L		((u32)0x00000004)
+#define RX_FIFO1_REG0_R		((u32)0x00000005)
+#define RX_FIFO1_REG1_L		((u32)0x00000006)
+#define RX_FIFO1_REG1_R		((u32)0x00000007)
+/**
+  * @}
+  */
+
 /**
   * @}
   */
@@ -1029,14 +1089,14 @@ typedef struct {
 _LONG_CALL_ void AUDIO_SP_StructInit(SP_InitTypeDef *SP_InitStruct);
 _LONG_CALL_ BOOL AUDIO_SP_Register(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct);
 _LONG_CALL_ void AUDIO_SP_Init(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct);
-_LONG_CALL_ void AUDIO_SP_TXStart(AUDIO_SPORT_TypeDef *SPORTx, u32 NewState);
-_LONG_CALL_ void AUDIO_SP_RXStart(AUDIO_SPORT_TypeDef *SPORTx, u32 NewState);
-_LONG_CALL_ void AUDIO_SP_DmaCmd(AUDIO_SPORT_TypeDef *SPORTx, u32 NewState);
-_LONG_CALL_ void AUDIO_SP_SetTXWordLen(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_Tx_WordLen);
-_LONG_CALL_ void AUDIO_SP_SetRXWordLen(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_Rx_WordLen);
-_LONG_CALL_ u32 AUDIO_SP_GetTXWordLen(AUDIO_SPORT_TypeDef *SPORTx);
-_LONG_CALL_ u32 AUDIO_SP_GetRXWordLen(AUDIO_SPORT_TypeDef *SPORTx);
-_LONG_CALL_ void AUDIO_SP_SetMonoStereo(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_MonoStereo);
+_LONG_CALL_ void AUDIO_SP_TXStart(u32 index, u32 NewState);
+_LONG_CALL_ void AUDIO_SP_RXStart(u32 index, u32 NewState);
+_LONG_CALL_ void AUDIO_SP_DmaCmd(u32 index, u32 NewState);
+_LONG_CALL_ void AUDIO_SP_SetTXWordLen(u32 index, u32 SP_Tx_WordLen);
+_LONG_CALL_ void AUDIO_SP_SetRXWordLen(u32 index, u32 SP_Rx_WordLen);
+_LONG_CALL_ u32 AUDIO_SP_GetTXWordLen(u32 index);
+_LONG_CALL_ u32 AUDIO_SP_GetRXWordLen(u32 index);
+_LONG_CALL_ void AUDIO_SP_SetMonoStereo(u32 index, u32 SP_MonoStereo);
 _LONG_CALL_ BOOL AUDIO_SP_TXGDMA_Init(u32 Index, u32 SelGDMA, GDMA_InitTypeDef *GDMA_InitStruct, void *CallbackData,
 									  IRQ_FUN CallbackFunc, u8 *pTxData, u32 Length);
 _LONG_CALL_ BOOL AUDIO_SP_RXGDMA_Init(u32 Index, u32 SelGDMA, GDMA_InitTypeDef *GDMA_InitStruct, void *CallbackData,
@@ -1046,10 +1106,10 @@ _LONG_CALL_ BOOL AUDIO_SP_LLPTXGDMA_Init(u32 Index,	u32 SelGDMA, GDMA_InitTypeDe
 _LONG_CALL_ BOOL AUDIO_SP_LLPRXGDMA_Init(u32 Index,	u32 SelGDMA, GDMA_InitTypeDef *GDMA_InitStruct, void *CallbackData,
 		IRQ_FUN CallbackFunc, u32 Length, u32 MaxLLP, struct GDMA_CH_LLI *Lli);
 _LONG_CALL_ void AUDIO_SP_Deinit(u32 index, u32 direction);
-_LONG_CALL_ void AUDIO_SP_Reset(AUDIO_SPORT_TypeDef *SPORTx);
+_LONG_CALL_ void AUDIO_SP_Reset(u32 index);
 _LONG_CALL_ BOOL AUDIO_SP_TXGDMA_Restart(u8 GDMA_Index, u8 GDMA_ChNum, u32 TX_addr,	u32 TX_length);
 _LONG_CALL_ BOOL AUDIO_SP_RXGDMA_Restart(u8 GDMA_Index,	u8 GDMA_ChNum,	u32 RX_addr,	u32 RX_length);
-_LONG_CALL_ void AUDIO_SP_SetMasterSlave(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_MasterSlave);
+_LONG_CALL_ void AUDIO_SP_SetMasterSlave(u32 index, u32 SP_MasterSlave);
 _LONG_CALL_ void AUDIO_SP_SetTXCounter(u32 index, u32 state);
 _LONG_CALL_ void AUDIO_SP_SetTXCounterCompVal(u32 index, u32 comp_val);
 _LONG_CALL_ void AUDIO_SP_ClearTXCounterIrq(u32 index);
@@ -1058,7 +1118,17 @@ _LONG_CALL_ void AUDIO_SP_SetRXCounter(u32 index, u32 state);
 _LONG_CALL_ void AUDIO_SP_SetRXCounterCompVal(u32 index, u32 comp_val);
 _LONG_CALL_ void AUDIO_SP_ClearRXCounterIrq(u32 index);
 _LONG_CALL_ u32 AUDIO_SP_GetRXCounterVal(u32 index);
-_LONG_CALL_ void AUDIO_SP_SetSelfLPBK(AUDIO_SPORT_TypeDef *SPORTx);
+_LONG_CALL_ void AUDIO_SP_SetSelfLPBK(u32 index);
+_LONG_CALL_ void AUDIO_SP_TXSetFifo(u32 index, u32 fifo_num, u32 NewState);
+_LONG_CALL_ void AUDIO_SP_RXSetFifo(u32 index, u32 fifo_num, u32 NewState);
+_LONG_CALL_ void AUDIO_SP_SetDirectOutMode(u32 index_src, u32 index_dir);
+_LONG_CALL_ void AUDIO_SP_SetPhaseLatch(u32 index);
+_LONG_CALL_ u32 AUDIO_SP_GetTXPhaseVal(u32 index);
+_LONG_CALL_ u32 AUDIO_SP_GetRXPhaseVal(u32 index);
+_LONG_CALL_ void AUDIO_SP_TXCHNSrcSel(u32 index, u32 tx_chn, u32 fifo_chn);
+_LONG_CALL_ void AUDIO_SP_RXFIFOSrcSel(u32 index, u32 fifo_chn, u32 rx_chn);
+
+
 
 /**
   * @}
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/Make.defs b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/Make.defs
index ee7afb763..b156f6a7b 100644
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/Make.defs
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/Make.defs
@@ -77,13 +77,13 @@ CSRCS += ameba_i2c.c \
 	ameba_wakepin.c \
 	ameba_otp.c \
 	ameba_ftl.c \
-	ameba_codec.c
+	ameba_codec.c \
+	ameba_pll.c 
 	#ameba_mpu_ram.c \
 	#ameba_pmc_com.c \
 	#ameba_prs.c \
 	#ameba_sport.c \
 	#ameba_vad.c \
-	#ameba_pll.c \
 	#ameba_psram.c \
 
 DEPPATH += --dep-path component/soc/amebad2/fwlib/ram_common
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/ameba_gdma_ram.c b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/ameba_gdma_ram.c
index 5dd33e9fd..77f020977 100755
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/ameba_gdma_ram.c
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/ameba_gdma_ram.c
@@ -24,7 +24,7 @@
 
 #include "ameba_soc.h"
 
-u8 GDMA_Reg[MAX_GDMA_INDX + 1];
+
 static u8 GDMA_IrqNum[8] = {
 #if defined (ARM_CORE_CM4)
 
@@ -122,7 +122,7 @@ void GDMA_Init(u8 GDMA_Index, u8 GDMA_ChNum, PGDMA_InitTypeDef GDMA_InitStruct)
 	/* Check chanel is avaliable */
 	if (GDMA->ChEnReg & ChEn) {
 		/* Disable Channel */
-		DBG_PRINTF(MODULE_GDMA, LEVEL_WARN, "Channel had used; Disable Channel!!!!\n");
+		lldbg("Channel had used; Disable Channel!!!!\n");
 
 		GDMA_Cmd(GDMA_Index, GDMA_ChNum, DISABLE);
 
@@ -208,7 +208,7 @@ void GDMA_SetLLP(u8 GDMA_Index, u8 GDMA_ChNum, u32 MultiBlockCount, struct GDMA_
 	assert_param(IS_GDMA_Index(GDMA_Index));
 	assert_param(IS_GDMA_ChannelNum(GDMA_ChNum));
 
-	//DBG_GDMA_INFO("Block Count %d\n", MultiBlockCount);
+	//RTK_LOGI(TAG, "Block Count %lu\n", MultiBlockCount);
 
 	CtlxLow = GDMA->CH[GDMA_ChNum].CTL_LOW;
 	CtlxUp = GDMA->CH[GDMA_ChNum].CTL_HIGH;
@@ -676,18 +676,23 @@ u32 GDMA_GetBlkSize(u8 GDMA_Index, u8 GDMA_ChNum)
   * @param  GDMA_ChNum: 0 ~ 7.
   * @retval value: _TRUE/_FALSE
   */
-__weak  BOOL
-GDMA_ChnlRegister(u8 GDMA_Index, u8 GDMA_ChNum)
+static void GDMA_ChnlRegister(u8 GDMA_Index, u8 GDMA_ChNum, IRQ_FUN IrqFun, u32 IrqData, u32 IrqPriority)
 {
+	u8 IrqNum = 0;
+	u8 ValTemp = HAL_READ8(SYSTEM_CTRL_BASE_LP, REG_LSYS_BOOT_REASON_SW + 3);
+
 	assert_param(IS_GDMA_Index(GDMA_Index));
 	assert_param(IS_GDMA_ChannelNum(GDMA_ChNum));
+	/* register idle channel. */
 
-	if ((GDMA_Reg[GDMA_Index] & BIT(GDMA_ChNum)) != 0) {
-		return 0;
-	}
+	ValTemp |= BIT(GDMA_ChNum);
+	HAL_WRITE8(SYSTEM_CTRL_BASE_LP, REG_LSYS_BOOT_REASON_SW + 3, ValTemp);
 
-	GDMA_Reg[GDMA_Index] |= BIT(GDMA_ChNum);
-	return 1;
+	if (IrqFun != NULL) {
+		IrqNum = GDMA_IrqNum[GDMA_ChNum];
+		InterruptRegister(IrqFun, IrqNum, IrqData, IrqPriority);
+		InterruptEn(IrqNum, IrqPriority);
+	}
 }
 
 /**
@@ -696,13 +701,20 @@ GDMA_ChnlRegister(u8 GDMA_Index, u8 GDMA_ChNum)
   * @param  GDMA_ChNum: 0 ~ 7.
   * @retval   None
   */
-__weak  void
-GDMA_ChnlUnRegister(u8 GDMA_Index, u8 GDMA_ChNum)
+static void GDMA_ChnlUnRegister(u8 GDMA_Index, u8 GDMA_ChNum)
 {
+	u8 IrqNum = 0;
+	u8 ValTemp = HAL_READ8(SYSTEM_CTRL_BASE_LP, REG_LSYS_BOOT_REASON_SW + 3);
+
 	assert_param(IS_GDMA_Index(GDMA_Index));
 	assert_param(IS_GDMA_ChannelNum(GDMA_ChNum));
 
-	GDMA_Reg[GDMA_Index] &= ~BIT(GDMA_ChNum);
+	ValTemp &= ~BIT(GDMA_ChNum);
+	HAL_WRITE8(SYSTEM_CTRL_BASE_LP, REG_LSYS_BOOT_REASON_SW + 3, ValTemp);
+
+	IrqNum = GDMA_IrqNum[GDMA_ChNum];
+	InterruptDis(IrqNum);
+	InterruptUnRegister(IrqNum);
 }
 
 /**
@@ -717,45 +729,42 @@ __weak  u8
 GDMA_ChnlAlloc(u32 GDMA_Index, IRQ_FUN IrqFun, u32 IrqData, u32 IrqPriority)
 {
 	u32 found = 0;
-	u32 GDMA_ChNum = 0;
-	u8 IrqNum = 0;
+	u32 GDMA_ChNum = 0xFF;
+	u8 ValTemp = 0;
 
 	assert_param(IS_GDMA_Index(GDMA_Index));
 
+	/* Match idle channel. */
+	ValTemp = HAL_READ8(SYSTEM_CTRL_BASE_LP, REG_LSYS_BOOT_REASON_SW + 3);
+
 	for (GDMA_ChNum = 0; GDMA_ChNum <= MAX_GDMA_CHNL; GDMA_ChNum++) {
-		if ((GDMA_Reg[GDMA_Index] & BIT(GDMA_ChNum)) == 0) {
+		if ((ValTemp & BIT(GDMA_ChNum)) == 0) {
 			found = 1;
 			break;
 		}
 	}
 
+	/*If idle channel is found,  register it. */
 	if (found) {
-		GDMA_ChnlRegister(GDMA_Index, GDMA_ChNum);
-		if (IrqFun != NULL) {
-
-			IrqNum = GDMA_IrqNum[GDMA_ChNum];
-			InterruptRegister(IrqFun, IrqNum, IrqData, IrqPriority);
-			InterruptEn(IrqNum, IrqPriority);
-		}
-
-		return GDMA_ChNum;
+		GDMA_ChnlRegister(GDMA_Index, GDMA_ChNum, IrqFun, IrqData, IrqPriority);
+		lldbg("\n[%s] - %d, gdma_idx = %d, gdma_chnum = %d\n",__FUNCTION__,__LINE__, GDMA_Index, GDMA_ChNum);
 	} else {
-		return 0xFF;
+		GDMA_ChNum = 0xFF;
 	}
+	return GDMA_ChNum;
 }
 
 /**
   * @brief  free a channel, this channel will not be used.
   * @param  GDMA_Index: 0.
   * @param  GDMA_ChNum: 0 ~ 7.
-  * @retval   None
+  * @retval   _TRUE/_FALSE
   */
-__weak  void
+__weak  u8
 GDMA_ChnlFree(u8 GDMA_Index, u8 GDMA_ChNum)
 {
-	u8 IrqNum;
 	GDMA_TypeDef *GDMA = NULL;
-
+	u8 ret = _FALSE;
 	/* Check the parameters */
 	assert_param(IS_GDMA_Index(GDMA_Index));
 	assert_param(IS_GDMA_ChannelNum(GDMA_ChNum));
@@ -766,12 +775,10 @@ GDMA_ChnlFree(u8 GDMA_Index, u8 GDMA_ChNum)
 		GDMA->CH[GDMA_ChNum].CFG_HIGH |= BIT_CFGX_UP_SEC_DISABLE;
 	}
 
-	IrqNum = GDMA_IrqNum[GDMA_ChNum];
-
-	InterruptDis(IrqNum);
-	InterruptUnRegister(IrqNum);
-
 	GDMA_ChnlUnRegister(GDMA_Index, GDMA_ChNum);
+
+	ret = _TRUE;
+	return ret;
 }
 
 /**
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/ameba_rom_patch.c b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/ameba_rom_patch.c
index aee19ef17..0bcfdc48c 100644
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/ameba_rom_patch.c
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_common/ameba_rom_patch.c
@@ -27,61 +27,120 @@ static LOG_UART_PORT LOG_UART_IDX_FLAG[] = {
 	{3, LOGUART_BIT_TP4F_NOT_FULL, LOGUART_BIT_TP4F_EMPTY, 3127500, UART_LOG_IRQ},	/* CA7 IDX NOT_FULL EMPTY TX_TIMEOUT IRQ*/
 };
 
-#define APAD_NAME_START	_PA_20
-#define APAD_NAME_END	_PA_29
+/**
+  *  @brief Pre-Process for Audio pad switch to digital usage
+  *  @param PinName: Pin of Audio share PAD.
+  *  @retval None
+  *  @note Special process for diffrent audio pad type:
+			MIC_PAD:		mute MICBST
+			MIC_BIAS_PAD:	power down MICBIAS
+			AOUT_PAD:		power down HPO
+  */
+static void APAD_PreProcess(u8 PinName)
+{
+	if ((PinName < APAD_NAME_START) || (PinName > APAD_NAME_END)) {
+		return;
+	}
+
+	if ((PinName >= APAD_MIC_PAD__START) && (PinName <= APAD_MIC_PAD_END)) {
+		/* keep audio MICBST be mute */
+		switch (PinName) {
+		case _PA_20:
+		case _PA_21:
+			/* mute AMIC1 */
+			AUDIO_CODEC_SetMicBstChnMute(AMIC1, MICIN, MUTE);
+			break;
+		case _PA_22:
+		case _PA_23:
+			/* mute AMIC2 */
+			AUDIO_CODEC_SetMicBstChnMute(AMIC2, MICIN, MUTE);
+			break;
+		case _PA_24:
+		case _PA_25:
+			/* mute AMIC3 */
+			AUDIO_CODEC_SetMicBstChnMute(AMIC3, MICIN, MUTE);
+			break;
+		case _PA_26:
+		case _PA_27:
+			/* mute AMIC4 */
+			AUDIO_CODEC_SetMicBstChnMute(AMIC4, MICIN, MUTE);
+			break;
+		case _PA_28:
+		case _PA_29:
+			/* mute AMIC5 */
+			AUDIO_CODEC_SetMicBstChnMute(AMIC5, MICIN, MUTE);
+			break;
+		default:
+			break;
+		}
+
+	} else if ((PinName >= APAD_MIC_BIAS_PAD_START) && (PinName <= APAD_MIC_BIAS_PAD_END)) {
+		/* keep audio MICBIAS power be power down mode */
+		AUDIO_CODEC_SetMicBiasPowerMode(POWER_DOWN);
+
+		switch (PinName) {
+		case _PA_30:
+			AUDIO_CODEC_SetMicBiasPCUTMode(AMIC1, POWER_DOWN);
+			break;
+		case _PA_31:
+			AUDIO_CODEC_SetMicBiasPCUTMode(AMIC2, POWER_DOWN);
+			break;
+		case _PB_0:
+			AUDIO_CODEC_SetMicBiasPCUTMode(AMIC3, POWER_DOWN);
+			break;
+		case _PB_1:
+			AUDIO_CODEC_SetMicBiasPCUTMode(AMIC4, POWER_DOWN);
+			break;
+		case _PB_2:
+			AUDIO_CODEC_SetMicBiasPCUTMode(AMIC5, POWER_DOWN);
+			break;
+		default:
+			break;
+		}
+
+	} else if ((PinName >= APAD_OUT_PAD_START) && (PinName <= APAD_OUT_PAD_END)) {
+		/* keep audio HPO power be power down mode */
+		switch (PinName) {
+		case _PB_3:
+		case _PB_4:
+			/* AOUT LPLN */
+			AUDIO_CODEC_SetHPOPowerMode(CHN_L, POWER_DOWN);
+			break;
+		case _PB_5:
+		case _PB_6:
+			/* AOUT RPRN */
+			AUDIO_CODEC_SetHPOPowerMode(CHN_R, POWER_DOWN);
+			break;
+		default:
+			break;
+		}
+	}
+
+}
 
-extern void AUDIO_CODEC_SetMicBstChnMute(u32 amic_sel, u32 type, u32 newstate);
 void Pinmux_Config(u8 PinName, u32 PinFunc)
 {
 	if ((PinName >= APAD_NAME_START) && (PinName <= APAD_NAME_END)) {
 		RCC_PeriphClockCmd(APBPeriph_AUDIO, NULL, ENABLE);
 
 		if (PinFunc != PINMUX_FUNCTION_AUDIO) {
-			/*for audio pad switch to digital usage:*/
-			//step1: mute AMICx
-			switch (PinName) {
-			case _PA_20:
-			case _PA_21:
-				/* mute AMIC1 */
-				AUDIO_CODEC_SetMicBstChnMute(AMIC1, MICIN, MUTE);
-				break;
-			case _PA_22:
-			case _PA_23:
-				/* mute AMIC2 */
-				AUDIO_CODEC_SetMicBstChnMute(AMIC2, MICIN, MUTE);
-				break;
-			case _PA_24:
-			case _PA_25:
-				/* mute AMIC3 */
-				AUDIO_CODEC_SetMicBstChnMute(AMIC3, MICIN, MUTE);
-				break;
-			case _PA_26:
-			case _PA_27:
-				/* mute AMIC4 */
-				AUDIO_CODEC_SetMicBstChnMute(AMIC4, MICIN, MUTE);
-				break;
-			case _PA_28:
-			case _PA_29:
-				/* mute AMIC5 */
-				AUDIO_CODEC_SetMicBstChnMute(AMIC5, MICIN, MUTE);
-				break;
-			default:
-				break;
-			}
-		}
-	}
+			/* for audio pad switch to digital usage: */
 
-	if (PinFunc != PINMUX_FUNCTION_AUDIO) {
-		//step2: enable digital path input
-		APAD_InputCtrl(PinName, ENABLE);
-	} else {
-		APAD_InputCtrl(PinName, DISABLE);
-	}
+			//step1: pre-process for diffrent audio pad types
+			APAD_PreProcess(PinName);
+
+			//step2: enable digital path input
+			APAD_InputCtrl(PinName, ENABLE);
+
+			//RTK_LOGW(TAG, "APAD P%s_%d is configured to funcID %lu \n", PORT_NUM(PinName) ? "B" : "A", PIN_NUM(PinName), PinFunc);
+
+		} else {
+			APAD_InputCtrl(PinName, DISABLE);
+		}
 
-	/*_PA_13: SWD_DATA, _PA_14: SWD_CLK*/
-	if ((PinName == _PA_13) || ((PinName == _PA_14))) {
+	} else if ((PinName == SWD_DATA) || ((PinName == SWD_CLK))) {
 		Pinmux_Swdoff();
-		//RTK_LOGW(TAG, "SWD PAD P%s_%d is configured to funcID %d \n", PORT_NUM(PinName) ? "B" : "A", PIN_NUM(PinName), PinFunc);
+		//RTK_LOGW(TAG, "SWD PAD P%s_%d is configured to funcID %lu \n", PORT_NUM(PinName) ? "B" : "A", PIN_NUM(PinName), PinFunc);
 	}
 
 	_Pinmux_Config(PinName, PinFunc);
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/Make.defs b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/Make.defs
index da9073abe..f84fdcbcf 100644
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/Make.defs
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/Make.defs
@@ -50,6 +50,7 @@
 ############################################################################
 
 CSRCS += ameba_sport.c \
+	ameba_audio_clock.c \
 
 
 DEPPATH += --dep-path component/soc/amebad2/fwlib/ram_hp
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/ameba_codec.c b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/ameba_codec.c
index 2dbb3bfd7..79ff8152b 100755
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/ameba_codec.c
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/ameba_codec.c
@@ -22,6 +22,7 @@
   */
 #include "ameba_soc.h"
 
+static const char *TAG = "CODEC";
 AUD_TypeDef *AUD;
 
 /**
@@ -623,6 +624,111 @@ void AUDIO_CODEC_SetLDOMode(u32 powermode)
 	}
 }
 
+/**
+  * @brief  Enable or disable per AD and AD fifo channel clock.
+  * @param  ad_chn: select ad channel.
+  *			 This parameter can be one of the following values:
+  *			   @arg ADCHN1
+  *			   @arg ADCHN2
+  *			   @arg ADCHN3
+  *			   @arg ADCHN4
+  *			   @arg ADCHN5
+  *			   @arg ADCHN6
+  *			   @arg ADCHN7
+  *			   @arg ADCHN8
+  * @param  newstate: enable or disable per ad channel.
+  *			 This parameter can be one of the following values:
+  *			   @arg ENABLE
+  *			   @arg DISABLE
+  * @return  None
+  */
+void AUDIO_CODEC_EnableADCFifo(u32 ad_chn, u32 newstate)
+{
+
+	u32 Tmp;
+	u32 audio_base;
+
+	if (TrustZone_IsSecure()) {
+		audio_base = AUDIO_REG_BASE_S;
+	} else {
+		audio_base = AUDIO_REG_BASE;
+	}
+
+	Tmp = HAL_READ32(audio_base, CODEC_CLOCK_CONTROL_1);
+
+	switch (ad_chn) {
+
+	case ADCHN1:
+		if (newstate == ENABLE) {
+			Tmp |= AUD_BIT_AD_0_FIFO_EN;
+		} else {
+			Tmp &= ~AUD_BIT_AD_0_FIFO_EN;
+		}
+		break;
+	case ADCHN2:
+
+		if (newstate == ENABLE) {
+			Tmp |= AUD_BIT_AD_1_FIFO_EN;
+		} else {
+			Tmp &= ~(AUD_BIT_AD_1_FIFO_EN);
+		}
+		break;
+	case ADCHN3:
+
+		if (newstate == ENABLE) {
+			Tmp |= AUD_BIT_AD_2_FIFO_EN;
+		} else {
+			Tmp &= ~AUD_BIT_AD_2_FIFO_EN;
+		}
+		break;
+	case ADCHN4:
+
+		if (newstate == ENABLE) {
+			Tmp |= AUD_BIT_AD_3_FIFO_EN;
+		} else {
+			Tmp &= ~(AUD_BIT_AD_3_FIFO_EN);
+		}
+		break;
+
+	case ADCHN5:
+		if (newstate == ENABLE) {
+			Tmp |= AUD_BIT_AD_4_FIFO_EN;
+		} else {
+			Tmp &= ~(AUD_BIT_AD_4_FIFO_EN);
+		}
+		break;
+	case ADCHN6:
+
+		if (newstate == ENABLE) {
+			Tmp |= AUD_BIT_AD_5_FIFO_EN;
+		} else {
+			Tmp &= ~AUD_BIT_AD_5_FIFO_EN;
+		}
+		break;
+	case ADCHN7:
+
+		if (newstate == ENABLE) {
+			Tmp |= AUD_BIT_AD_6_FIFO_EN;
+		} else {
+			Tmp &= ~(AUD_BIT_AD_6_FIFO_EN);
+		}
+		break;
+	case ADCHN8:
+
+		if (newstate == ENABLE) {
+			Tmp |= AUD_BIT_AD_7_FIFO_EN;
+		} else {
+			Tmp &= ~(AUD_BIT_AD_7_FIFO_EN);
+		}
+		break;
+	default:
+		break;
+
+	}
+
+	HAL_WRITE32(audio_base, CODEC_CLOCK_CONTROL_1, Tmp);
+}
+
 
 /**
   * @brief  Enable or disable per AD and AD fifo channel clock.
@@ -660,65 +766,65 @@ void AUDIO_CODEC_EnableADC(u32 ad_chn, u32 newstate)
 
 	case ADCHN1:
 		if (newstate == ENABLE) {
-			Tmp |= AUD_BIT_AD_0_EN | AUD_BIT_AD_0_FIFO_EN;
+			Tmp |= AUD_BIT_AD_0_EN;
 		} else {
-			Tmp &= ~(AUD_BIT_AD_0_EN | AUD_BIT_AD_0_FIFO_EN);
+			Tmp &= ~(AUD_BIT_AD_0_EN);
 		}
 		break;
 	case ADCHN2:
 
 		if (newstate == ENABLE) {
-			Tmp |= AUD_BIT_AD_1_EN | AUD_BIT_AD_1_FIFO_EN;
+			Tmp |= AUD_BIT_AD_1_EN;
 		} else {
-			Tmp &= ~(AUD_BIT_AD_1_EN | AUD_BIT_AD_1_FIFO_EN);
+			Tmp &= ~(AUD_BIT_AD_1_EN);
 		}
 		break;
 	case ADCHN3:
 
 		if (newstate == ENABLE) {
-			Tmp |= AUD_BIT_AD_2_EN | AUD_BIT_AD_2_FIFO_EN;
+			Tmp |= AUD_BIT_AD_2_EN;
 		} else {
-			Tmp &= ~(AUD_BIT_AD_2_EN | AUD_BIT_AD_2_FIFO_EN);
+			Tmp &= ~(AUD_BIT_AD_2_EN);
 		}
 		break;
 	case ADCHN4:
 
 		if (newstate == ENABLE) {
-			Tmp |= AUD_BIT_AD_3_EN | AUD_BIT_AD_3_FIFO_EN;
+			Tmp |= AUD_BIT_AD_3_EN;
 		} else {
-			Tmp &= ~(AUD_BIT_AD_3_EN | AUD_BIT_AD_3_FIFO_EN);
+			Tmp &= ~(AUD_BIT_AD_3_EN);
 		}
 		break;
 
 	case ADCHN5:
 		if (newstate == ENABLE) {
-			Tmp |= AUD_BIT_AD_4_EN | AUD_BIT_AD_4_FIFO_EN;
+			Tmp |= AUD_BIT_AD_4_EN;
 		} else {
-			Tmp &= ~(AUD_BIT_AD_4_EN | AUD_BIT_AD_4_FIFO_EN);
+			Tmp &= ~(AUD_BIT_AD_4_EN);
 		}
 		break;
 	case ADCHN6:
 
 		if (newstate == ENABLE) {
-			Tmp |= AUD_BIT_AD_5_EN | AUD_BIT_AD_5_FIFO_EN;
+			Tmp |= AUD_BIT_AD_5_EN;
 		} else {
-			Tmp &= ~(AUD_BIT_AD_5_EN | AUD_BIT_AD_5_FIFO_EN);
+			Tmp &= ~(AUD_BIT_AD_5_EN);
 		}
 		break;
 	case ADCHN7:
 
 		if (newstate == ENABLE) {
-			Tmp |= AUD_BIT_AD_6_EN | AUD_BIT_AD_6_FIFO_EN;
+			Tmp |= AUD_BIT_AD_6_EN;
 		} else {
-			Tmp &= ~(AUD_BIT_AD_6_EN | AUD_BIT_AD_6_FIFO_EN);
+			Tmp &= ~(AUD_BIT_AD_6_EN);
 		}
 		break;
 	case ADCHN8:
 
 		if (newstate == ENABLE) {
-			Tmp |= AUD_BIT_AD_7_EN | AUD_BIT_AD_7_FIFO_EN;
+			Tmp |= AUD_BIT_AD_7_EN;
 		} else {
-			Tmp &= ~(AUD_BIT_AD_7_EN | AUD_BIT_AD_7_FIFO_EN);
+			Tmp &= ~(AUD_BIT_AD_7_EN);
 		}
 		break;
 	default:
@@ -1700,6 +1806,8 @@ void AUDIO_CODEC_SetMicBstPowerMode(u32 amic_num, u32 powermode)
 	}
 
 	if (powermode == NORMALPOWER) {
+
+		AUD->AUD_DTS_CTL &= ~AUD_BIT_LPMODE_EN;
 		if (amic_num == AMIC1) {
 			AUD->AUD_MICBST_CTL0 |= AUD_BIT_MICBST_POWL;
 			AUD->AUD_MBIAS_CTL1 &= ~(AUD_MASK_MBIAS_ISEL_MICBST_L);
@@ -1905,19 +2013,19 @@ void AUDIO_CODEC_SetMicBstChnMute(u32 amic_sel, u32 type, u32 newstate)
 		} else if (amic_sel == AMIC3) {
 			AUD->AUD_MICBST_CTL1 &= ~AUD_MASK_MICBST2_MUTE_L;
 			if (type == LINEIN) {
-				DBG_8195A("\n AMIC3 NOT SUPPORT LINEIN MODE\n");
+				//RTK_LOGE(TAG, "AMIC3 NOT SUPPORT LINEIN MODE\n");
 				return;
 			}
 		} else if (amic_sel == AMIC4) {
 			AUD->AUD_MICBST_CTL1 &= ~AUD_MASK_MICBST2_MUTE_R;
 			if (type == LINEIN) {
-				DBG_8195A("\n AMIC4 NOT SUPPORT LINEIN MODE\n");
+				//RTK_LOGE(TAG, "AMIC4 NOT SUPPORT LINEIN MODE\n");
 				return;
 			}
 		} else {
 			AUD->AUD_MICBST_CTL1 &= ~ AUD_MASK_MICBST3_MUTE;
 			if (type == LINEIN) {
-				DBG_8195A("\n AMIC5 NOT SUPPORT LINEIN MODE\n");
+				//RTK_LOGE(TAG, "AMIC5 NOT SUPPORT LINEIN MODE\n");
 				return;
 			}
 		}
@@ -2434,6 +2542,35 @@ void AUDIO_CODEC_SetDACSrc(u32 i2s_sel, u32 dac_l_src, u32 dac_r_src)
 
 }
 
+/**
+  * @brief  Enable or disable da fifo channel clock.
+  * @param  newstate: enable or disable da channel.
+  *			 This parameter can be one of the following values:
+  *			   @arg ENABLE
+  *			   @arg DISABLE
+  * @return  None
+  */
+void AUDIO_CODEC_EnableDACFifo(u32 newstate)
+{
+
+	u32 Tmp;
+	u32 audio_base;
+
+	if (TrustZone_IsSecure()) {
+		audio_base = AUDIO_REG_BASE_S;
+	} else {
+		audio_base = AUDIO_REG_BASE;
+	}
+
+	Tmp = HAL_READ32(audio_base, CODEC_CLOCK_CONTROL_1);
+	if (newstate == ENABLE) {
+		Tmp |= AUD_BIT_DA_FIFO_EN;
+	} else {
+		Tmp &= ~AUD_BIT_DA_FIFO_EN;
+	}
+	HAL_WRITE32(audio_base, CODEC_CLOCK_CONTROL_1, Tmp);
+
+}
 
 /**
   * @brief  Enable or disable da and da fifo channel clock.
@@ -2460,7 +2597,6 @@ void AUDIO_CODEC_EnableDAC(u32 channel, u32 newstate)
 	}
 
 	Tmp = HAL_READ32(audio_base, CODEC_CLOCK_CONTROL_1);
-	Tmp |= AUD_BIT_DA_FIFO_EN;
 
 	if (channel == DAC_L) {
 		if (newstate == ENABLE) {
@@ -2700,8 +2836,9 @@ void AUDIO_CODEC_SetDACPowerMode(u32 channel, u32 powermode)
   * @brief  Set lineout power mode.
   * @param  channel: the value of dac path.
   *          This parameter can be one of the following values:
-  *            @arg 0: DAC_L
-  *            @arg 1: DAC_R
+  *            @arg 0: CHN_L
+  *            @arg 1: CHN_R
+  *            @arg 2: CHN_LR
   * @param  newstate: enable or disable dac power.
   *			 This parameter can be one of the following values:
   *			   @arg POWER_ON
@@ -2715,28 +2852,51 @@ void AUDIO_CODEC_SetLineOutPowerMode(u32 channel, u32 powermode)
 		AUD = AUD_SYS_BASE;
 	}
 
-	AUD->AUD_MBIAS_CTL0 &= ~AUD_MASK_MBIAS_ISEL_HPO;
-	AUD->AUD_MBIAS_CTL0 |= AUD_MBIAS_ISEL_HPO(2);
-	AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_ENDPL | AUD_BIT_HPO_ENDPR);
-	AUD->AUD_HPO_BIAS_CTL &= ~(AUD_MASK_HPO_CCSELL | AUD_MASK_HPO_CCSELR);
-	AUD->AUD_HPO_BIAS_CTL |= AUD_HPO_CCSELL(3) | AUD_HPO_CCSELR(3);
-	AUD->AUD_HPO_CTL &= ~(AUD_MASK_HPO_ML | AUD_MASK_HPO_MR);
-	AUD->AUD_HPO_CTL |= AUD_HPO_ML(2) | AUD_HPO_MR(2);
-	AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_SEL | AUD_BIT_HPO_SER);
-	AUD->AUD_HPO_CTL |= (AUD_BIT_HPO_ENAL | AUD_BIT_HPO_ENAR);
-
-	if (channel == DAC_L) {
+	if (channel == CHN_L) {
 		if (powermode == POWER_ON) {
+			AUD->AUD_MBIAS_CTL0 &= ~AUD_MASK_MBIAS_ISEL_HPO;
+			AUD->AUD_MBIAS_CTL0 |= AUD_MBIAS_ISEL_HPO(2);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_ENDPL);
+			AUD->AUD_HPO_BIAS_CTL &= ~(AUD_MASK_HPO_CCSELL);
+			AUD->AUD_HPO_BIAS_CTL |= AUD_HPO_CCSELL(3);
+			AUD->AUD_HPO_CTL &= ~(AUD_MASK_HPO_ML);
+			AUD->AUD_HPO_CTL |= AUD_HPO_ML(2);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_SEL);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENAL;
 			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_L_POW;
 		} else {
 			AUD->AUD_HPO_CTL &= ~AUD_BIT_HPO_L_POW;
 		}
-	} else {
+	} else if (channel == CHN_R) {
 		if (powermode == POWER_ON) {
+			AUD->AUD_MBIAS_CTL0 &= ~AUD_MASK_MBIAS_ISEL_HPO;
+			AUD->AUD_MBIAS_CTL0 |= AUD_MBIAS_ISEL_HPO(2);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_ENDPR);
+			AUD->AUD_HPO_BIAS_CTL &= ~(AUD_MASK_HPO_CCSELR);
+			AUD->AUD_HPO_BIAS_CTL |= AUD_HPO_CCSELR(3);
+			AUD->AUD_HPO_CTL &= ~(AUD_MASK_HPO_MR);
+			AUD->AUD_HPO_CTL |= AUD_HPO_MR(2);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_SER);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENAR;
 			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_R_POW;
 		} else {
 			AUD->AUD_HPO_CTL &= ~AUD_BIT_HPO_R_POW;
 		}
+	} else {
+		if (powermode == POWER_ON) {
+			AUD->AUD_MBIAS_CTL0 &= ~AUD_MASK_MBIAS_ISEL_HPO;
+			AUD->AUD_MBIAS_CTL0 |= AUD_MBIAS_ISEL_HPO(2);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_ENDPL | AUD_BIT_HPO_ENDPR);
+			AUD->AUD_HPO_BIAS_CTL &= ~(AUD_MASK_HPO_CCSELL | AUD_MASK_HPO_CCSELR);
+			AUD->AUD_HPO_BIAS_CTL |= AUD_HPO_CCSELL(3) | AUD_HPO_CCSELR(3);
+			AUD->AUD_HPO_CTL &= ~(AUD_MASK_HPO_ML | AUD_MASK_HPO_MR);
+			AUD->AUD_HPO_CTL |= AUD_HPO_ML(2) | AUD_HPO_MR(2);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_SEL | AUD_BIT_HPO_SER);
+			AUD->AUD_HPO_CTL |= (AUD_BIT_HPO_ENAL | AUD_BIT_HPO_ENAR);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_L_POW | AUD_BIT_HPO_R_POW;
+		} else {
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_L_POW | AUD_BIT_HPO_R_POW);
+		}
 	}
 }
 
@@ -2744,8 +2904,9 @@ void AUDIO_CODEC_SetLineOutPowerMode(u32 channel, u32 powermode)
   * @brief  Set HPO power mode.
   * @param  channel: the value of dac path.
   *          This parameter can be one of the following values:
-  *            @arg 0: DAC_L
-  *            @arg 1: DAC_R
+  *            @arg 0: CHN_L
+  *            @arg 1: CHN_R
+  *            @arg 2: CHN_LR
   * @param  newstate: enable or disable dac power.
   *			 This parameter can be one of the following values:
   *			   @arg POWER_ON
@@ -2764,56 +2925,105 @@ void AUDIO_CODEC_SetHPOPowerMode(u32 channel, u32 powermode)
 		audio_base = AUDIO_REG_BASE;
 	}
 
-	/*HPO Enable Single flow*/
-	Tmp = HAL_READ32(audio_base, CODEC_AUDIO_CONTROL_1);
-	Tmp &= ~AUD_MASK_SEL_BB_CK_DEPOP;
-	Tmp |= AUD_SEL_BB_CK_DEPOP(1) | AUD_BIT_BB_CK_DEPOP_EN;
-	HAL_WRITE32(audio_base, CODEC_AUDIO_CONTROL_1, Tmp);
-
-	AUD->AUD_HPO_CTL |= AUD_BIT_HPO_SEL | AUD_BIT_HPO_SER;
-
-	AUD->AUD_ADDA_CTL &= ~(AUD_MASK_DPRAMP_CSEL);
-	AUD->AUD_ADDA_CTL |= AUD_DPRAMP_CSEL(3);
-
-	AUD->AUD_HPO_BIAS_CTL &= ~(AUD_MASK_HPO_CCSELL | AUD_MASK_HPO_CCSELR);
-	AUD->AUD_HPO_BIAS_CTL |= AUD_HPO_CCSELL(3) | AUD_HPO_CCSELR(3);
-
-	AUD->AUD_MBIAS_CTL0 &= ~AUD_MASK_MBIAS_ISEL_HPO;
-	AUD->AUD_MBIAS_CTL0 |= AUD_MBIAS_ISEL_HPO(2);
-
-	AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENAL | AUD_BIT_HPO_ENAR;
-
-	AUD->AUD_HPO_CTL &= ~(AUD_MASK_HPO_ML | AUD_MASK_HPO_MR);
-	AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENDPL | AUD_BIT_HPO_ENDPR | AUD_HPO_ML(2) | AUD_HPO_MR(2) | AUD_BIT_HPO_L_POW | AUD_BIT_HPO_R_POW;
-	DelayUs(10);
-	AUD->AUD_HPO_CTL |= AUD_BIT_HPO_MDPL | AUD_BIT_HPO_MDPR	| AUD_BIT_HPO_OPPDPL | AUD_BIT_HPO_OPPDPR;
-	AUD->AUD_ADDA_CTL |= AUD_BIT_DPRAMP_POW;
-	DelayUs(100);
-	AUD->AUD_ADDA_CTL |= AUD_BIT_DPRAMP_ENRAMP;
-	DelayMs(500);
-	AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_MDPL | AUD_BIT_HPO_MDPR | AUD_BIT_HPO_OPPDPL | AUD_BIT_HPO_OPPDPR);
-	DelayUs(100);
-	AUD->AUD_ADDA_CTL &= ~(AUD_BIT_DPRAMP_POW | AUD_BIT_DPRAMP_ENRAMP);
-	AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_ENDPL | AUD_BIT_HPO_ENDPR);
-
-	if (channel == DAC_L) {
+	if (channel == CHN_L) {
 		if (powermode == POWER_DOWN) {
 			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_L_POW);
+		} else {
+			Tmp = HAL_READ32(audio_base, CODEC_AUDIO_CONTROL_1);
+			Tmp &= ~AUD_MASK_SEL_BB_CK_DEPOP;
+			Tmp |= AUD_SEL_BB_CK_DEPOP(1) | AUD_BIT_BB_CK_DEPOP_EN;
+			HAL_WRITE32(audio_base, CODEC_AUDIO_CONTROL_1, Tmp);
+
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_SEL;
+			AUD->AUD_ADDA_CTL &= ~(AUD_MASK_DPRAMP_CSEL);
+			AUD->AUD_ADDA_CTL |= AUD_DPRAMP_CSEL(3);
+			AUD->AUD_HPO_BIAS_CTL &= ~(AUD_MASK_HPO_CCSELL);
+			AUD->AUD_HPO_BIAS_CTL |= AUD_HPO_CCSELL(3);
+			AUD->AUD_MBIAS_CTL0 &= ~AUD_MASK_MBIAS_ISEL_HPO;
+			AUD->AUD_MBIAS_CTL0 |= AUD_MBIAS_ISEL_HPO(2);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENAL;
+			AUD->AUD_HPO_CTL &= ~(AUD_MASK_HPO_ML);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENDPL | AUD_HPO_ML(2) | AUD_BIT_HPO_L_POW;
+			DelayUs(10);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_MDPL | AUD_BIT_HPO_OPPDPL;
+			AUD->AUD_ADDA_CTL |= AUD_BIT_DPRAMP_POW;
+			DelayUs(100);
+			AUD->AUD_ADDA_CTL |= AUD_BIT_DPRAMP_ENRAMP;
+			DelayMs(500);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_MDPL | AUD_BIT_HPO_OPPDPL);
+			DelayUs(100);
+			AUD->AUD_ADDA_CTL &= ~(AUD_BIT_DPRAMP_POW | AUD_BIT_DPRAMP_ENRAMP);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_ENDPL);
+		}
+	} else if (channel == CHN_R) {
+		if (powermode == POWER_DOWN) {
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_R_POW);
+		} else {
+			Tmp = HAL_READ32(audio_base, CODEC_AUDIO_CONTROL_1);
+			Tmp &= ~AUD_MASK_SEL_BB_CK_DEPOP;
+			Tmp |= AUD_SEL_BB_CK_DEPOP(1) | AUD_BIT_BB_CK_DEPOP_EN;
+			HAL_WRITE32(audio_base, CODEC_AUDIO_CONTROL_1, Tmp);
+
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_SER;
+			AUD->AUD_ADDA_CTL &= ~(AUD_MASK_DPRAMP_CSEL);
+			AUD->AUD_ADDA_CTL |= AUD_DPRAMP_CSEL(3);
+			AUD->AUD_HPO_BIAS_CTL &= ~(AUD_MASK_HPO_CCSELR);
+			AUD->AUD_HPO_BIAS_CTL |= AUD_HPO_CCSELR(3);
+			AUD->AUD_MBIAS_CTL0 &= ~AUD_MASK_MBIAS_ISEL_HPO;
+			AUD->AUD_MBIAS_CTL0 |= AUD_MBIAS_ISEL_HPO(2);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENAR;
+			AUD->AUD_HPO_CTL &= ~(AUD_MASK_HPO_MR);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENDPR | AUD_HPO_MR(2) | AUD_BIT_HPO_R_POW;
+			DelayUs(10);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_MDPR | AUD_BIT_HPO_OPPDPR;
+			AUD->AUD_ADDA_CTL |= AUD_BIT_DPRAMP_POW;
+			DelayUs(100);
+			AUD->AUD_ADDA_CTL |= AUD_BIT_DPRAMP_ENRAMP;
+			DelayMs(500);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_MDPR | AUD_BIT_HPO_OPPDPR);
+			DelayUs(100);
+			AUD->AUD_ADDA_CTL &= ~(AUD_BIT_DPRAMP_POW | AUD_BIT_DPRAMP_ENRAMP);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_ENDPR);
 		}
 	} else {
 		if (powermode == POWER_DOWN) {
-			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_R_POW);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_L_POW | AUD_BIT_HPO_R_POW);
+		} else {
+			Tmp = HAL_READ32(audio_base, CODEC_AUDIO_CONTROL_1);
+			Tmp &= ~AUD_MASK_SEL_BB_CK_DEPOP;
+			Tmp |= AUD_SEL_BB_CK_DEPOP(1) | AUD_BIT_BB_CK_DEPOP_EN;
+			HAL_WRITE32(audio_base, CODEC_AUDIO_CONTROL_1, Tmp);
+
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_SEL | AUD_BIT_HPO_SER;
+			AUD->AUD_ADDA_CTL &= ~(AUD_MASK_DPRAMP_CSEL);
+			AUD->AUD_ADDA_CTL |= AUD_DPRAMP_CSEL(3);
+			AUD->AUD_HPO_BIAS_CTL &= ~(AUD_MASK_HPO_CCSELL | AUD_MASK_HPO_CCSELR);
+			AUD->AUD_HPO_BIAS_CTL |= AUD_HPO_CCSELL(3) | AUD_HPO_CCSELR(3);
+			AUD->AUD_MBIAS_CTL0 &= ~AUD_MASK_MBIAS_ISEL_HPO;
+			AUD->AUD_MBIAS_CTL0 |= AUD_MBIAS_ISEL_HPO(2);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENAL | AUD_BIT_HPO_ENAR;
+			AUD->AUD_HPO_CTL &= ~(AUD_MASK_HPO_ML | AUD_MASK_HPO_MR);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_ENDPL | AUD_BIT_HPO_ENDPR | AUD_HPO_ML(2) | AUD_HPO_MR(2) | AUD_BIT_HPO_L_POW | AUD_BIT_HPO_R_POW;
+			DelayUs(10);
+			AUD->AUD_HPO_CTL |= AUD_BIT_HPO_MDPL | AUD_BIT_HPO_MDPR	| AUD_BIT_HPO_OPPDPL | AUD_BIT_HPO_OPPDPR;
+			AUD->AUD_ADDA_CTL |= AUD_BIT_DPRAMP_POW;
+			DelayUs(100);
+			AUD->AUD_ADDA_CTL |= AUD_BIT_DPRAMP_ENRAMP;
+			DelayMs(500);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_MDPL | AUD_BIT_HPO_MDPR | AUD_BIT_HPO_OPPDPL | AUD_BIT_HPO_OPPDPR);
+			DelayUs(100);
+			AUD->AUD_ADDA_CTL &= ~(AUD_BIT_DPRAMP_POW | AUD_BIT_DPRAMP_ENRAMP);
+			AUD->AUD_HPO_CTL &= ~(AUD_BIT_HPO_ENDPL | AUD_BIT_HPO_ENDPR);
 		}
 	}
 }
 
-
 /**
   * @brief  Set Lineout single-end or differential mode.
   * @param  channel: the value of dac path.
   *          This parameter can be one of the following values:
-  *            @arg 0: DAC_L
-  *            @arg 1: DAC_R
+  *            @arg 0: CHN_L
+  *            @arg 1: CHN_R
   * @param  mode:
   *			 This parameter can be one of the following values:
   *			   @arg SINGLE
@@ -2827,7 +3037,7 @@ void AUDIO_CODEC_SetLineOutMode(u32 channel, u32 mode)
 		AUD = AUD_SYS_BASE;
 	}
 
-	if (channel == DAC_L) {
+	if (channel == CHN_L) {
 		if (mode == DIFF) {
 			AUD->AUD_HPO_CTL &= ~AUD_BIT_HPO_SEL;
 		} else {
@@ -2846,8 +3056,8 @@ void AUDIO_CODEC_SetLineOutMode(u32 channel, u32 mode)
   * @brief  Set HPO single-end or differential mode.
   * @param  channel: the value of dac path.
   *          This parameter can be one of the following values:
-  *            @arg 0: DAC_L
-  *            @arg 1: DAC_R
+  *            @arg 0: CHN_L
+  *            @arg 1: CHN_R
   * @param  mode:
   *			 This parameter can be one of the following values:
   *			   @arg SINGLE
@@ -2861,7 +3071,7 @@ void AUDIO_CODEC_SetHPOMode(u32 channel, u32 mode)
 		AUD = AUD_SYS_BASE;
 	}
 
-	if (channel == DAC_L) {
+	if (channel == CHN_L) {
 		if (mode == DIFF) {
 			AUD->AUD_HPO_CTL &= ~AUD_BIT_HPO_SEL;
 		} else {
@@ -2880,8 +3090,8 @@ void AUDIO_CODEC_SetHPOMode(u32 channel, u32 mode)
   * @brief  Set Line out mute control: dac in or analog in.
   * @param  channel: the value of dac path.
   *          This parameter can be one of the following values:
-  *            @arg 0: DAC_L
-  *            @arg 1: DAC_R
+  *            @arg 0: CHN_L
+  *            @arg 1: CHN_R
   * @param  type: dac in or analog in.
   *			 This parameter can be one of the following values:
   *			   @arg DACIN
@@ -2900,7 +3110,7 @@ void AUDIO_CODEC_SetLineOutMute(u32 channel, u32 type, u32 newstate)
 		AUD = AUD_SYS_BASE;
 	}
 
-	if (channel == DAC_L) {
+	if (channel == CHN_L) {
 		if (newstate == UNMUTE) {
 			AUD->AUD_HPO_CTL &= ~AUD_MASK_HPO_ML;
 			AUD->AUD_HPO_CTL |= AUD_HPO_ML(type);
@@ -2923,8 +3133,8 @@ void AUDIO_CODEC_SetLineOutMute(u32 channel, u32 type, u32 newstate)
   * @brief  Set HPO mute control: dac in or analog in.
   * @param  channel: the value of dac path.
   *          This parameter can be one of the following values:
-  *            @arg 0: DAC_L
-  *            @arg 1: DAC_R
+  *            @arg 0: CHN_L
+  *            @arg 1: CHN_R
   * @param  type: dac in or analog in.
   *			 This parameter can be one of the following values:
   *			   @arg DACIN
@@ -2943,7 +3153,7 @@ void AUDIO_CODEC_SetHPOMute(u32 channel, u32 type, u32 newstate)
 		AUD = AUD_SYS_BASE;
 	}
 
-	if (channel == DAC_L) {
+	if (channel == CHN_L) {
 		if (newstate == UNMUTE) {
 			AUD->AUD_HPO_CTL &= ~AUD_MASK_HPO_ML;
 			AUD->AUD_HPO_CTL |= AUD_HPO_ML(type);
@@ -3496,6 +3706,9 @@ void AUDIO_CODEC_Record(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct)
 
 		AUDIO_CODEC_EnableADC(ADCHN1, ENABLE);
 		AUDIO_CODEC_EnableADC(ADCHN2, ENABLE);
+
+		AUDIO_CODEC_EnableADCFifo(ADCHN1, ENABLE);
+		AUDIO_CODEC_EnableADCFifo(ADCHN2, ENABLE);
 		AUDIO_CODEC_SetADCVolume(ADC1, 0X2F);
 		AUDIO_CODEC_SetADCVolume(ADC2, 0X2F);
 		AUDIO_CODEC_SetADCHPF(ADC1, 3, ENABLE);
@@ -3508,6 +3721,8 @@ void AUDIO_CODEC_Record(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct)
 
 		AUDIO_CODEC_EnableADC(ADCHN3, ENABLE);
 		AUDIO_CODEC_EnableADC(ADCHN4, ENABLE);
+		AUDIO_CODEC_EnableADCFifo(ADCHN3, ENABLE);
+		AUDIO_CODEC_EnableADCFifo(ADCHN4, ENABLE);
 		AUDIO_CODEC_SetADCVolume(ADC3, 0X2F);
 		AUDIO_CODEC_SetADCVolume(ADC4, 0X2F);
 		AUDIO_CODEC_SetADCHPF(ADC3, 3, ENABLE);
@@ -3520,6 +3735,8 @@ void AUDIO_CODEC_Record(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct)
 
 		AUDIO_CODEC_EnableADC(ADCHN5, ENABLE);
 		AUDIO_CODEC_EnableADC(ADCHN6, ENABLE);
+		AUDIO_CODEC_EnableADCFifo(ADCHN5, ENABLE);
+		AUDIO_CODEC_EnableADCFifo(ADCHN6, ENABLE);
 		AUDIO_CODEC_SetADCVolume(ADC5, 0X2F);
 		AUDIO_CODEC_SetADCVolume(ADC6, 0X2F);
 		AUDIO_CODEC_SetADCHPF(ADC5, 3, ENABLE);
@@ -3532,6 +3749,8 @@ void AUDIO_CODEC_Record(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct)
 
 		AUDIO_CODEC_EnableADC(ADCHN7, ENABLE);
 		AUDIO_CODEC_EnableADC(ADCHN8, ENABLE);
+		AUDIO_CODEC_EnableADCFifo(ADCHN7, ENABLE);
+		AUDIO_CODEC_EnableADCFifo(ADCHN8, ENABLE);
 		AUDIO_CODEC_SetADCVolume(ADC7, 0X2F);
 		AUDIO_CODEC_SetADCVolume(ADC8, 0X2F);
 		AUDIO_CODEC_SetADCHPF(ADC7, 3, ENABLE);
@@ -3705,6 +3924,7 @@ void AUDIO_CODEC_Playback(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct
 	AUDIO_CODEC_SetANAClk(ENABLE);
 	AUDIO_CODEC_EnableDAC(DAC_L, ENABLE);
 	AUDIO_CODEC_EnableDAC(DAC_R, ENABLE);
+	AUDIO_CODEC_EnableDACFifo(ENABLE);
 	AUDIO_CODEC_SetDACMute(DAC_L, UNMUTE);
 	AUDIO_CODEC_SetDACMute(DAC_R, UNMUTE);
 	AUDIO_CODEC_SetDACVolume(DAC_L, 0XAF);
@@ -3723,12 +3943,11 @@ void AUDIO_CODEC_Playback(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct
 		AUDIO_CODEC_DisPAD(PAD_DACR);
 		AUDIO_CODEC_SetDACPowerMode(DAC_L, POWER_ON);
 		AUDIO_CODEC_SetDACPowerMode(DAC_R, POWER_ON);
-		AUDIO_CODEC_SetLineOutPowerMode(DAC_L, POWER_ON);
-		AUDIO_CODEC_SetLineOutPowerMode(DAC_R, POWER_ON);
-		AUDIO_CODEC_SetLineOutMode(DAC_L, DIFF);
-		AUDIO_CODEC_SetLineOutMode(DAC_R, DIFF);
-		AUDIO_CODEC_SetLineOutMute(DAC_L, DACIN, UNMUTE);
-		AUDIO_CODEC_SetLineOutMute(DAC_R, DACIN, UNMUTE);
+		AUDIO_CODEC_SetLineOutPowerMode(CHN_LR, POWER_ON);
+		AUDIO_CODEC_SetLineOutMode(CHN_L, DIFF);
+		AUDIO_CODEC_SetLineOutMode(CHN_R, DIFF);
+		AUDIO_CODEC_SetLineOutMute(CHN_L, DACIN, UNMUTE);
+		AUDIO_CODEC_SetLineOutMute(CHN_R, DACIN, UNMUTE);
 	}
 
 	if (type == APP_HPO_OUT) {
@@ -3738,12 +3957,11 @@ void AUDIO_CODEC_Playback(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct
 		AUDIO_CODEC_DisPAD(PAD_DACR);
 		AUDIO_CODEC_SetDACPowerMode(DAC_L, POWER_ON);
 		AUDIO_CODEC_SetDACPowerMode(DAC_R, POWER_ON);
-		AUDIO_CODEC_SetHPOPowerMode(DAC_L, POWER_ON);
-		AUDIO_CODEC_SetHPOPowerMode(DAC_R, POWER_ON);
-		AUDIO_CODEC_SetHPOMode(DAC_L, SINGLE);
-		AUDIO_CODEC_SetHPOMode(DAC_R, SINGLE);
-		AUDIO_CODEC_SetHPOMute(DAC_L, DACIN, UNMUTE);
-		AUDIO_CODEC_SetHPOMute(DAC_R, DACIN, UNMUTE);
+		AUDIO_CODEC_SetHPOPowerMode(CHN_LR, POWER_ON);
+		AUDIO_CODEC_SetHPOMode(CHN_L, SINGLE);
+		AUDIO_CODEC_SetHPOMode(CHN_R, SINGLE);
+		AUDIO_CODEC_SetHPOMute(CHN_L, DACIN, UNMUTE);
+		AUDIO_CODEC_SetHPOMute(CHN_R, DACIN, UNMUTE);
 	}
 
 	if (type == APP_PDM_OUT) {
@@ -3758,3 +3976,4 @@ void AUDIO_CODEC_Playback(u32 i2s_sel, u32 type, I2S_InitTypeDef *I2S_InitStruct
 	}
 }
 
+
diff --git a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/ameba_sport.c b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/ameba_sport.c
index a4740e8d0..0df47a3a7 100755
--- a/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/ameba_sport.c
+++ b/os/board/rtl8730e/src/component/soc/amebad2/fwlib/ram_hp/ameba_sport.c
@@ -22,6 +22,7 @@
   */
 #include "ameba_soc.h"
 
+static const char *TAG = "SPORT";
 SP_RegTypeDef SP_RegFlag[4] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
 
 const AUDIO_DevTable AUDIO_DEV_TABLE[4] = {
@@ -75,11 +76,12 @@ void AUDIO_SP_StructInit(SP_InitTypeDef *SP_InitStruct)
 */
 BOOL AUDIO_SP_Register(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct)
 {
+	assert_param(IS_SP_SET_DIR(direction));
 
 	if (direction == SP_DIR_TX) {
 
 		if (SP_RegFlag[index].SP_DIR_TX_flag) {
-			DBG_8195A("SPORT TX has been registered!\n");
+			//RTK_LOGW(TAG, "SPORT TX has been registered!\n");
 			return 0;
 		} else {
 			if (SP_RegFlag[index].SP_DIR_RX_flag) {
@@ -91,7 +93,7 @@ BOOL AUDIO_SP_Register(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct)
 					if (SP_InitStruct->SP_Fix_Bclk) {
 						return 1;
 					} else {
-						DBG_8195A("SPORT RX Bclk can't be changed!\n");
+						//RTK_LOGW(TAG, "SPORT RX Bclk can't be changed!\n");
 						return 0;
 					}
 				}
@@ -104,7 +106,7 @@ BOOL AUDIO_SP_Register(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct)
 	} else {
 
 		if (SP_RegFlag[index].SP_DIR_RX_flag) {
-			DBG_8195A("SPORT RX has been registered!\n");
+			//RTK_LOGW(TAG, "SPORT RX has been registered!\n");
 			return 0;
 		} else {
 			if (SP_RegFlag[index].SP_DIR_TX_flag) {
@@ -116,7 +118,7 @@ BOOL AUDIO_SP_Register(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct)
 					if (SP_InitStruct->SP_Fix_Bclk) {
 						return 1;
 					} else {
-						DBG_8195A("SPORT TX Bclk can't be changed!\n");
+						//RTK_LOGW(TAG, "SPORT TX Bclk can't be changed!\n");
 						return 0;
 					}
 				}
@@ -149,11 +151,12 @@ void AUDIO_SP_Unregister(u32 index, u32 direction)
 
 /**
   * @brief  Reset SPORT module.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @retval None
   */
-void AUDIO_SP_Reset(AUDIO_SPORT_TypeDef *SPORTx)
+void AUDIO_SP_Reset(u32 index)
 {
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 	SPORTx->SP_CTRL0 |= SP_BIT_RESET;
 	SPORTx->SP_CTRL0 &= ~ SP_BIT_RESET;
 }
@@ -161,12 +164,13 @@ void AUDIO_SP_Reset(AUDIO_SPORT_TypeDef *SPORTx)
 
 /**
   * @brief  Get sport tx channel length.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @retval None
 */
-u32 AUDIO_SP_GetTXChnLen(AUDIO_SPORT_TypeDef *SPORTx)
+u32 AUDIO_SP_GetTXChnLen(u32 index)
 {
 	u32 chn_len;
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 	u32 len_tx = ((SPORTx->SP_FORMAT) & SP_MASK_CH_LEN_SEL_TX) >> 24;
 
 	switch (len_tx) {
@@ -189,12 +193,13 @@ u32 AUDIO_SP_GetTXChnLen(AUDIO_SPORT_TypeDef *SPORTx)
 
 /**
   * @brief  Get sport rx channel length.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @retval None
 */
-u32 AUDIO_SP_GetRXChnLen(AUDIO_SPORT_TypeDef *SPORTx)
+u32 AUDIO_SP_GetRXChnLen(u32 index)
 {
 	u32 chn_len;
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 	u32 len_rx = ((SPORTx->SP_FORMAT) & SP_MASK_CH_LEN_SEL_RX) >> 28;
 
 	switch (len_rx) {
@@ -484,6 +489,213 @@ void AUDIO_SP_SetRXClkDiv(u32 index, u32 clock, u32 sr, u32 tdm, u32 chn_len)
 	}
 }
 
+/**
+* @brief Select AUDIO SPORT tx channel source.
+* @param  index: select SPORT.
+* @param  tx_chn: select tx channel,channel 0-7 corresponding to DOUT0-3.
+*		   This parameter can be one of the following values:
+*			 @arg TXCHN0
+*			 @arg TXCHN1
+*			 @arg TXCHN2
+*			 @arg TXCHN3
+*			 @arg TXCHN4
+*			 @arg TXCHN5
+*			 @arg TXCHN6
+*			 @arg TXCHN7
+* @param  fifo_chn: select fifo channel
+*		   This parameter can be one of the following values:
+*			 @arg TX_FIFO0_REG0_L
+*			 @arg TX_FIFO0_REG0_R
+*			 @arg TX_FIFO0_REG1_L
+*			 @arg TX_FIFO0_REG1_R
+*			 @arg TX_FIFO1_REG0_L
+*			 @arg TX_FIFO1_REG0_R
+*			 @arg TX_FIFO1_REG1_L
+*			 @arg TX_FIFO1_REG1_R
+*/
+void AUDIO_SP_TXCHNSrcSel(u32 index, u32 tx_chn, u32 fifo_chn)
+{
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+
+	switch (tx_chn) {
+	case TXCHN0:
+		SPORTx->SP_DIRECT_CTRL0 &= ~SP_MASK_TX_CH0_DATA_SEL;
+		SPORTx->SP_DIRECT_CTRL0 |= SP_TX_CH0_DATA_SEL(fifo_chn);
+		break;
+	case TXCHN1:
+		SPORTx->SP_DIRECT_CTRL0 &= ~SP_MASK_TX_CH1_DATA_SEL;
+		SPORTx->SP_DIRECT_CTRL0 |= SP_TX_CH1_DATA_SEL(fifo_chn);
+		break;
+	case TXCHN2:
+		SPORTx->SP_DIRECT_CTRL0 &= ~SP_MASK_TX_CH2_DATA_SEL;
+		SPORTx->SP_DIRECT_CTRL0 |= SP_TX_CH2_DATA_SEL(fifo_chn);
+		break;
+	case TXCHN3:
+		SPORTx->SP_DIRECT_CTRL0 &= ~SP_MASK_TX_CH3_DATA_SEL;
+		SPORTx->SP_DIRECT_CTRL0 |= SP_TX_CH3_DATA_SEL(fifo_chn);
+		break;
+	case TXCHN4:
+		SPORTx->SP_DIRECT_CTRL0 &= ~SP_MASK_TX_CH4_DATA_SEL;
+		SPORTx->SP_DIRECT_CTRL0 |= SP_TX_CH4_DATA_SEL(fifo_chn);
+		break;
+	case TXCHN5:
+		SPORTx->SP_DIRECT_CTRL0 &= ~SP_MASK_TX_CH5_DATA_SEL;
+		SPORTx->SP_DIRECT_CTRL0 |= SP_TX_CH5_DATA_SEL(fifo_chn);
+		break;
+	case TXCHN6:
+		SPORTx->SP_DIRECT_CTRL0 &= ~SP_MASK_TX_CH6_DATA_SEL;
+		SPORTx->SP_DIRECT_CTRL0 |= SP_TX_CH6_DATA_SEL(fifo_chn);
+		break;
+	case TXCHN7:
+		SPORTx->SP_DIRECT_CTRL0 &= ~SP_MASK_TX_CH7_DATA_SEL;
+		SPORTx->SP_DIRECT_CTRL0 |= SP_TX_CH7_DATA_SEL(fifo_chn);
+		break;
+	default:
+		break;
+	}
+
+}
+
+/**
+  * @brief Select AUDIO SPORT rx fifo source.
+  * @param	index: select SPORT.
+  * @param	fifo_chn: select fifo channel
+  * 		 This parameter can be one of the following values:
+  * 		   @arg RX_FIFO0_REG0_L
+  * 		   @arg RX_FIFO0_REG0_R
+  * 		   @arg RX_FIFO0_REG1_L
+  * 		   @arg RX_FIFO0_REG1_R
+  * 		   @arg RX_FIFO1_REG0_L
+  * 		   @arg RX_FIFO1_REG0_R
+  * 		   @arg RX_FIFO1_REG1_L
+  * 		   @arg RX_FIFO1_REG1_R
+  * @param	rx_chn: select rx channel,channel 0-7 corresponding to DIN0-3.
+  * 		 This parameter can be one of the following values:
+  * 		   @arg RXCHN0
+  * 		   @arg RXCHN1
+  * 		   @arg RXCHN2
+  * 		   @arg RXCHN3
+  * 		   @arg RXCHN4
+  * 		   @arg RXCHN5
+  * 		   @arg RXCHN6
+  * 		   @arg RXCHN7
+  */
+void AUDIO_SP_RXFIFOSrcSel(u32 index, u32 fifo_chn, u32 rx_chn)
+{
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+
+	switch (fifo_chn) {
+	case RX_FIFO0_REG0_L:
+		SPORTx->SP_DIRECT_CTRL3 &= ~SP_MASK_RX_FIFO_0_REG_0_L_SEL;
+		SPORTx->SP_DIRECT_CTRL3 |= SP_RX_FIFO_0_REG_0_L_SEL(rx_chn);
+		break;
+	case RX_FIFO0_REG0_R:
+		SPORTx->SP_DIRECT_CTRL3 &= ~SP_MASK_RX_FIFO_0_REG_0_R_SEL;
+		SPORTx->SP_DIRECT_CTRL3 |= SP_RX_FIFO_0_REG_0_R_SEL(rx_chn);
+		break;
+	case RX_FIFO0_REG1_L:
+		SPORTx->SP_DIRECT_CTRL3 &= ~SP_MASK_RX_FIFO_0_REG_1_L_SEL;
+		SPORTx->SP_DIRECT_CTRL3 |= SP_RX_FIFO_0_REG_1_L_SEL(rx_chn);
+		break;
+	case RX_FIFO0_REG1_R:
+		SPORTx->SP_DIRECT_CTRL3 &= ~SP_MASK_RX_FIFO_0_REG_1_R_SEL;
+		SPORTx->SP_DIRECT_CTRL3 |= SP_RX_FIFO_0_REG_1_R_SEL(rx_chn);
+		break;
+	case RX_FIFO1_REG0_L:
+		SPORTx->SP_DIRECT_CTRL4 &= ~SP_MASK_RX_FIFO_1_REG_0_L_SEL;
+		SPORTx->SP_DIRECT_CTRL4 |= SP_RX_FIFO_1_REG_0_L_SEL(rx_chn);
+		break;
+	case RX_FIFO1_REG0_R:
+		SPORTx->SP_DIRECT_CTRL4 &= ~SP_MASK_RX_FIFO_1_REG_0_R_SEL;
+		SPORTx->SP_DIRECT_CTRL4 |= SP_RX_FIFO_1_REG_0_R_SEL(rx_chn);
+		break;
+	case RX_FIFO1_REG1_L:
+		SPORTx->SP_DIRECT_CTRL4 &= ~SP_MASK_RX_FIFO_1_REG_1_L_SEL;
+		SPORTx->SP_DIRECT_CTRL4 |= SP_RX_FIFO_1_REG_1_L_SEL(rx_chn);
+		break;
+	case RX_FIFO1_REG1_R:
+		SPORTx->SP_DIRECT_CTRL4 &= ~SP_MASK_RX_FIFO_1_REG_1_R_SEL;
+		SPORTx->SP_DIRECT_CTRL4 |= SP_RX_FIFO_1_REG_1_R_SEL(rx_chn);
+		break;
+	default:
+		break;
+	}
+
+}
+
+/**
+  * @brief  Set AUDIO SPORT TX FIFO enable or disable.
+  * @param  index: sport index.
+  * @param  fifo_num: tx fifo number.
+  * @param  NewState: enable or disable.
+  * @retval None
+  */
+void AUDIO_SP_TXSetFifo(u32 index, u32 fifo_num, u32 NewState)
+{
+	assert_param(IS_SP_SEL_TX_FIFO(fifo_num));
+
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+
+	if (NewState == ENABLE) {
+		if (fifo_num == SP_TX_FIFO2) {
+			SPORTx->SP_CTRL1 |= SP_BIT_TX_FIFO_0_REG_0_EN;
+		} else if (fifo_num == SP_TX_FIFO4) {
+			SPORTx->SP_CTRL1 |= SP_BIT_TX_FIFO_0_REG_0_EN | SP_BIT_TX_FIFO_0_REG_1_EN;
+		} else if (fifo_num == SP_TX_FIFO6) {
+			SPORTx->SP_CTRL1 |= (SP_BIT_TX_FIFO_0_REG_0_EN | SP_BIT_TX_FIFO_0_REG_1_EN | SP_BIT_TX_FIFO_1_REG_0_EN);
+		} else {
+			SPORTx->SP_CTRL1 |= (SP_BIT_TX_FIFO_0_REG_0_EN | SP_BIT_TX_FIFO_0_REG_1_EN | SP_BIT_TX_FIFO_1_REG_0_EN | SP_BIT_TX_FIFO_1_REG_1_EN);
+		}
+	} else {
+		if (fifo_num == SP_TX_FIFO2) {
+			SPORTx->SP_CTRL1 &= ~(SP_BIT_TX_FIFO_0_REG_0_EN);
+		} else if (fifo_num == SP_TX_FIFO4) {
+			SPORTx->SP_CTRL1 &= ~(SP_BIT_TX_FIFO_0_REG_0_EN | SP_BIT_TX_FIFO_0_REG_1_EN);
+		} else if (fifo_num == SP_TX_FIFO6) {
+			SPORTx->SP_CTRL1 &= ~(SP_BIT_TX_FIFO_0_REG_0_EN | SP_BIT_TX_FIFO_0_REG_1_EN | SP_BIT_TX_FIFO_1_REG_0_EN);
+		} else {
+			SPORTx->SP_CTRL1 &= ~(SP_BIT_TX_FIFO_0_REG_0_EN | SP_BIT_TX_FIFO_0_REG_1_EN | SP_BIT_TX_FIFO_1_REG_0_EN | SP_BIT_TX_FIFO_1_REG_1_EN);
+		}
+	}
+}
+
+/**
+  * @brief  Set AUDIO SPORT RX FIFO enable or disable.
+  * @param  index: sport index.
+  * @param  fifo_num: rx fifo number.
+  * @param  NewState: enable or disable.
+  * @retval None
+  */
+void AUDIO_SP_RXSetFifo(u32 index, u32 fifo_num, u32 NewState)
+{
+	assert_param(IS_SP_SEL_RX_FIFO(fifo_num));
+
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+
+	if (NewState == ENABLE) {
+		if (fifo_num == SP_RX_FIFO2) {
+			SPORTx->SP_CTRL1 |= SP_BIT_RX_FIFO_0_REG_0_EN;
+		} else if (fifo_num == SP_RX_FIFO4) {
+			SPORTx->SP_CTRL1 |= SP_BIT_RX_FIFO_0_REG_0_EN | SP_BIT_RX_FIFO_0_REG_1_EN;
+		} else if (fifo_num == SP_RX_FIFO6) {
+			SPORTx->SP_CTRL1 |= (SP_BIT_RX_FIFO_0_REG_0_EN | SP_BIT_RX_FIFO_0_REG_1_EN | SP_BIT_RX_FIFO_1_REG_0_EN);
+		} else {
+			SPORTx->SP_CTRL1 |= (SP_BIT_RX_FIFO_0_REG_0_EN | SP_BIT_RX_FIFO_0_REG_1_EN | SP_BIT_RX_FIFO_1_REG_0_EN | SP_BIT_RX_FIFO_1_REG_1_EN);
+		}
+
+	} else {
+		if (fifo_num == SP_RX_FIFO2) {
+			SPORTx->SP_CTRL1 &= ~(SP_BIT_RX_FIFO_0_REG_0_EN);
+		} else if (fifo_num == SP_RX_FIFO4) {
+			SPORTx->SP_CTRL1 &= ~(SP_BIT_RX_FIFO_0_REG_0_EN | SP_BIT_RX_FIFO_0_REG_1_EN);
+		} else if (fifo_num == SP_RX_FIFO6) {
+			SPORTx->SP_CTRL1 &= ~(SP_BIT_RX_FIFO_0_REG_0_EN | SP_BIT_RX_FIFO_0_REG_1_EN | SP_BIT_RX_FIFO_1_REG_0_EN);
+		} else {
+			SPORTx->SP_CTRL1 &= ~(SP_BIT_RX_FIFO_0_REG_0_EN | SP_BIT_RX_FIFO_0_REG_1_EN | SP_BIT_RX_FIFO_1_REG_0_EN | SP_BIT_RX_FIFO_1_REG_1_EN);
+		}
+	}
+}
+
 /**
   * @brief  Initializes the AUDIO SPORT registers according to the specified parameters in SP_InitStruct.
   * @param  index: 0 ~ 3.
@@ -535,7 +747,7 @@ void AUDIO_SP_Init(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct)
 		assert_param(AUDIO_SP_Register(index, direction, SP_InitStruct));
 
 		/* Configure parameters: disable TX, AUDIO SPORT mode */
-		AUDIO_SP_TXStart(SPORTx, DISABLE);
+		AUDIO_SP_TXStart(index, DISABLE);
 
 		/* Configure FIFO0 parameters: data format, word length, channel number, etc */
 		SPORTx->SP_FORMAT &= ~(SP_BIT_TRX_SAME_LENGTH);
@@ -567,15 +779,7 @@ void AUDIO_SP_Init(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct)
 		AUDIO_SP_SetTXClkDiv(index, SP_InitStruct->SP_SelClk, SP_InitStruct->SP_SR, SP_InitStruct->SP_SelTDM, chn_len);
 
 		/* Configure TX FIFO Channel */
-		if (SP_InitStruct->SP_SelFIFO == SP_TX_FIFO2) {
-			SPORTx->SP_CTRL1 |= SP_BIT_TX_FIFO_0_REG_0_EN;
-		} else if (SP_InitStruct->SP_SelFIFO == SP_TX_FIFO4) {
-			SPORTx->SP_CTRL1 |= SP_BIT_TX_FIFO_0_REG_0_EN | SP_BIT_TX_FIFO_0_REG_1_EN;
-		} else if (SP_InitStruct->SP_SelFIFO == SP_TX_FIFO6) {
-			SPORTx->SP_CTRL1 |= (SP_BIT_TX_FIFO_0_REG_0_EN | SP_BIT_TX_FIFO_0_REG_1_EN | SP_BIT_TX_FIFO_1_REG_0_EN);
-		} else if (SP_InitStruct->SP_SelFIFO == SP_TX_FIFO8) {
-			SPORTx->SP_CTRL1 |= (SP_BIT_TX_FIFO_0_REG_0_EN | SP_BIT_TX_FIFO_0_REG_1_EN | SP_BIT_TX_FIFO_1_REG_0_EN | SP_BIT_TX_FIFO_1_REG_1_EN);
-		}
+		AUDIO_SP_TXSetFifo(index, SP_InitStruct->SP_SelFIFO, ENABLE);
 
 		/* Configure SPORT parameters: TX MULTI_IO Mode*/
 		if (SP_InitStruct->SP_SetMultiIO == SP_TX_MULTIIO_EN) {
@@ -620,7 +824,7 @@ void AUDIO_SP_Init(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct)
 		assert_param(AUDIO_SP_Register(index, direction, SP_InitStruct));
 
 		/* Configure parameters: disable RX, AUDIO SPORT mode */
-		AUDIO_SP_RXStart(SPORTx, DISABLE);
+		AUDIO_SP_RXStart(index, DISABLE);
 
 		/* Configure FIFO0 parameters: data format, word length, channel number, etc */
 		SPORTx->SP_CTRL0 &= ~(SP_MASK_SEL_I2S_RX_CH | SP_MASK_TDM_MODE_SEL_RX);
@@ -651,15 +855,7 @@ void AUDIO_SP_Init(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct)
 		AUDIO_SP_SetRXClkDiv(index, SP_InitStruct->SP_SelClk, SP_InitStruct->SP_SR, SP_InitStruct->SP_SelTDM, chn_len);
 
 		/* Configure RX FIFO Channel */
-		if (SP_InitStruct->SP_SelFIFO == SP_RX_FIFO2) {
-			SPORTx->SP_CTRL1 |= SP_BIT_RX_FIFO_0_REG_0_EN;
-		} else if (SP_InitStruct->SP_SelFIFO == SP_RX_FIFO4) {
-			SPORTx->SP_CTRL1 |= SP_BIT_RX_FIFO_0_REG_0_EN | SP_BIT_RX_FIFO_0_REG_1_EN;
-		} else if (SP_InitStruct->SP_SelFIFO == SP_RX_FIFO6) {
-			SPORTx->SP_CTRL1 |= (SP_BIT_RX_FIFO_0_REG_0_EN | SP_BIT_RX_FIFO_0_REG_1_EN | SP_BIT_RX_FIFO_1_REG_0_EN);
-		} else if (SP_InitStruct->SP_SelFIFO == SP_RX_FIFO8) {
-			SPORTx->SP_CTRL1 |= (SP_BIT_RX_FIFO_0_REG_0_EN | SP_BIT_RX_FIFO_0_REG_1_EN | SP_BIT_RX_FIFO_1_REG_0_EN | SP_BIT_RX_FIFO_1_REG_1_EN);
-		}
+		AUDIO_SP_RXSetFifo(index, SP_InitStruct->SP_SelFIFO, ENABLE);
 
 		/* Configure SPORT parameters:RX MULTI_IO Mode*/
 		if (SP_InitStruct->SP_SetMultiIO == SP_RX_MULTIIO_EN) {
@@ -680,13 +876,15 @@ void AUDIO_SP_Init(u32 index, u32 direction, SP_InitTypeDef *SP_InitStruct)
 
 /**
   * @brief  Start or stop SPORT TX.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @param  NewState: new state of the SPORT TX.
   *         This parameter can be: ENABLE or DISABLE.
   * @retval None
   */
-void AUDIO_SP_TXStart(AUDIO_SPORT_TypeDef *SPORTx, u32 NewState)
+void AUDIO_SP_TXStart(u32 index, u32 NewState)
 {
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+
 	if (NewState == ENABLE) {
 		SPORTx->SP_CTRL0 &= ~ SP_BIT_TX_DISABLE;
 		SPORTx->SP_CTRL0 |= SP_BIT_START_TX;
@@ -698,13 +896,15 @@ void AUDIO_SP_TXStart(AUDIO_SPORT_TypeDef *SPORTx, u32 NewState)
 
 /**
   * @brief  Start or stop SPORT RX.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @param  NewState: new state of the SPORT RX.
   *         This parameter can be: ENABLE or DISABLE.
   * @retval None
   */
-void AUDIO_SP_RXStart(AUDIO_SPORT_TypeDef *SPORTx, u32 NewState)
+void AUDIO_SP_RXStart(u32 index, u32 NewState)
 {
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+
 	if (NewState == ENABLE) {
 		SPORTx->SP_CTRL0 &= ~ SP_BIT_RX_DISABLE;
 		SPORTx->SP_CTRL0 |= SP_BIT_START_RX;
@@ -716,13 +916,15 @@ void AUDIO_SP_RXStart(AUDIO_SPORT_TypeDef *SPORTx, u32 NewState)
 
 /**
   * @brief  SPORT and GDMA handshake on or off.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @param  NewState: new state of the handshake of GDMA-SPORT.
   *         This parameter can be: ENABLE or DISABLE.
   * @retval None
   */
-void AUDIO_SP_DmaCmd(AUDIO_SPORT_TypeDef *SPORTx, u32 NewState)
+void AUDIO_SP_DmaCmd(u32 index, u32 NewState)
 {
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+
 	if (NewState == ENABLE) {
 		SPORTx->SP_CTRL0 &= ~ SP_BIT_DSP_CTL_MODE;
 	} else {
@@ -732,17 +934,18 @@ void AUDIO_SP_DmaCmd(AUDIO_SPORT_TypeDef *SPORTx, u32 NewState)
 
 /**
   * @brief  Set SPORT self loopback mode.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @retval None
   */
-void AUDIO_SP_SetSelfLPBK(AUDIO_SPORT_TypeDef *SPORTx)
+void AUDIO_SP_SetSelfLPBK(u32 index)
 {
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 	SPORTx->SP_CTRL0 |= SP_BIT_LOOPBACK;
 }
 
 /**
   * @brief  Set the AUDIO SPORT word length.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @param  SP_TX_WordLen: the value of word length.
   *          This parameter can be one of the following values:
   *            @arg SP_TXWL_16: sample bit is 16 bit
@@ -752,9 +955,10 @@ void AUDIO_SP_SetSelfLPBK(AUDIO_SPORT_TypeDef *SPORTx)
   * @retval None
   */
 
-void AUDIO_SP_SetTXWordLen(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_TX_WordLen)
+void AUDIO_SP_SetTXWordLen(u32 index, u32 SP_TX_WordLen)
 {
 	assert_param(IS_SP_TX_WL(SP_TX_WordLen));
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 
 	SPORTx->SP_CTRL0 &= ~(SP_MASK_DATA_LEN_SEL_TX_0);
 	SPORTx->SP_CTRL0 |= SP_DATA_LEN_SEL_TX_0(SP_TX_WordLen);
@@ -765,7 +969,7 @@ void AUDIO_SP_SetTXWordLen(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_TX_WordLen)
 
 /**
   * @brief  Set the AUDIO SPORT word length.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @param  SP_RX_WordLen: the value of word length.
   *          This parameter can be one of the following values:
   *            @arg SP_RXWL_16: sample bit is 16 bit
@@ -775,9 +979,10 @@ void AUDIO_SP_SetTXWordLen(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_TX_WordLen)
   * @retval None
   */
 
-void AUDIO_SP_SetRXWordLen(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_RX_WordLen)
+void AUDIO_SP_SetRXWordLen(u32 index, u32 SP_RX_WordLen)
 {
 	assert_param(IS_SP_RX_WL(SP_RX_WordLen));
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 
 	SPORTx->SP_FORMAT &= ~(SP_MASK_DATA_LEN_SEL_RX_0);
 	SPORTx->SP_FORMAT |= SP_DATA_LEN_SEL_RX_0(SP_RX_WordLen);
@@ -788,30 +993,33 @@ void AUDIO_SP_SetRXWordLen(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_RX_WordLen)
 
 /**
   * @brief Get AUDIO SPORT word length.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @retval the value of word length.
   *            @arg 0: sample bit is 16 bit
   *            @arg 1: sample bit is 20 bit
   *            @arg 2: sample bit is 24 bit
   *            @arg 3: sample bit is 32 bit
   */
-u32 AUDIO_SP_GetTXWordLen(AUDIO_SPORT_TypeDef *SPORTx)
+u32 AUDIO_SP_GetTXWordLen(u32 index)
 {
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 	u32 len_TX = ((SPORTx->SP_CTRL0) & SP_MASK_DATA_LEN_SEL_TX_0) >> 12;
 	return len_TX;
 }
 
 /**
   * @brief Get AUDIO SPORT word length.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @retval the value of word length.
   *            @arg 0: sample bit is 16 bit
   *            @arg 1: sample bit is 20 bit
   *            @arg 2: sample bit is 24 bit
   *            @arg 3: sample bit is 32 bit
   */
-u32 AUDIO_SP_GetRXWordLen(AUDIO_SPORT_TypeDef *SPORTx)
+u32 AUDIO_SP_GetRXWordLen(u32 index)
 {
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+
 	u32 len_RX = ((SPORTx->SP_FORMAT) & SP_MASK_DATA_LEN_SEL_RX_0) >> 12;
 	return len_RX;
 }
@@ -819,16 +1027,17 @@ u32 AUDIO_SP_GetRXWordLen(AUDIO_SPORT_TypeDef *SPORTx)
 
 /**
   * @brief  Set the AUDIO SPORT channel number.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @param  SP_MonoStereo: mono or stereo.
   *          This parameter can be one of the following values:
   *            @arg SP_CH_STEREO: stereo channel, channel number is 0
   *            @arg SP_CH_MONO: mono channel, channel number is 1
   * @retval None
   */
-void AUDIO_SP_SetMonoStereo(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_MonoStereo)
+void AUDIO_SP_SetMonoStereo(u32 index, u32 SP_MonoStereo)
 {
 	assert_param(IS_SP_CHN_NUM(SP_MonoStereo));
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 
 	if (SP_MonoStereo == SP_CH_STEREO) {
 		SPORTx->SP_CTRL0 &= ~(SP_BIT_EN_I2S_MONO_TX_0);
@@ -840,16 +1049,17 @@ void AUDIO_SP_SetMonoStereo(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_MonoStereo)
 
 /**
   * @brief  SPORT2 and SPORT3 can be set to master or slave mode.
-  * @param  SPORTx: pointer to the base addr of AUDIO SPORT peripheral.
+  * @param  index: select SPORT.
   * @param  SP_MasterSlave: master or slave.
   *          This parameter can be one of the following values:
   *            @arg MASTER: SPORT master mode
   *            @arg SLAVE: SPORT slave mode
   * @retval None
   */
-void AUDIO_SP_SetMasterSlave(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_MasterSlave)
+void AUDIO_SP_SetMasterSlave(u32 index, u32 SP_MasterSlave)
 {
 	assert_param(IS_SP_SEL_MODE(SP_MasterSlave));
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 
 	if (SPORTx == AUDIO_SPORT2_DEV || SPORTx == AUDIO_SPORT3_DEV) {
 		if (SP_MasterSlave == MASTER) {
@@ -858,7 +1068,7 @@ void AUDIO_SP_SetMasterSlave(AUDIO_SPORT_TypeDef *SPORTx, u32 SP_MasterSlave)
 			SPORTx->SP_CTRL0 |= SP_BIT_SLAVE_CLK_SEL | SP_BIT_SLAVE_DATA_SEL;
 		}
 	} else {
-		DBG_8195A("Not support: Only SPORT2&3 supprot!\n");
+		//RTK_LOGE(TAG, "Not support: Only SPORT2&3 supprot!\n");
 		return;
 	}
 }
@@ -931,7 +1141,7 @@ BOOL AUDIO_SP_TXGDMA_Init(
 		GDMA_InitStruct->GDMA_SrcDataWidth = TrWidthTwoBytes;
 		GDMA_InitStruct->GDMA_BlockSize = Length >> 1;
 	} else {
-		DBG_8195A("AUDIO_SP_TXGDMA_Init: Aligment Err: pTXData=%p,  Length=%d\n", pTXData, Length);
+		//RTK_LOGE(TAG, "AUDIO_SP_TXGDMA_Init: Aligment Err: pTXData=%p,  Length=%lu\n", pTXData, Length);
 		return _FALSE;
 	}
 	GDMA_InitStruct->GDMA_DstMsize = MsizeFour;
@@ -944,7 +1154,7 @@ BOOL AUDIO_SP_TXGDMA_Init(
 	/*	Enable GDMA for TX */
 	GDMA_Init(GDMA_InitStruct->GDMA_Index, GDMA_InitStruct->GDMA_ChNum, GDMA_InitStruct);
 	GDMA_Cmd(GDMA_InitStruct->GDMA_Index, GDMA_InitStruct->GDMA_ChNum, ENABLE);
-	//DBG_8195A("TXGDMA_End\n");
+	//RTK_LOGD(TAG, "TXGDMA_End\n");
 	return _TRUE;
 }
 
@@ -1017,7 +1227,7 @@ BOOL AUDIO_SP_RXGDMA_Init(
 	GDMA_Init(GDMA_InitStruct->GDMA_Index, GDMA_InitStruct->GDMA_ChNum, GDMA_InitStruct);
 
 	GDMA_Cmd(GDMA_InitStruct->GDMA_Index, GDMA_InitStruct->GDMA_ChNum, ENABLE);
-	//DBG_8195A("RXGDMA_End\n");
+	//RTK_LOGD(TAG, "RXGDMA_End\n");
 
 	return _TRUE;
 }
@@ -1150,7 +1360,7 @@ BOOL AUDIO_SP_LLPTXGDMA_Init(
 		GDMA_InitStruct->GDMA_SrcDataWidth = TrWidthTwoBytes;
 		GDMA_InitStruct->GDMA_BlockSize = Length >> 1;
 	} else {
-		DBG_8195A("AUDIO_SP_TXGDMA_Init: Aligment Err: pTxData=%p,  Length=%d\n", pTxData, Length);
+		//RTK_LOGE(TAG, "AUDIO_SP_TXGDMA_Init: Aligment Err: pTxData=0x%lX,  Length=%lu\n", pTxData, Length);
 		return _FALSE;
 	}
 
@@ -1289,19 +1499,37 @@ void AUDIO_SP_ClearTXCounterIrq(u32 index)
 	SPORTx->SP_RX_LRCLK |= SP_BIT_CLR_TX_SPORT_RDY;
 }
 
+/**
+  * @brief  Set SPORT phase latch.
+  * @param  index: select SPORT.
+  */
+void AUDIO_SP_SetPhaseLatch(u32 index)
+{
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+	SPORTx->SP_RX_LRCLK |= SP_BIT_EN_FS_PHASE_LATCH;
+}
 
 /**
-  * @brief  Get SPORT TX counter.
+  * @brief  Set SPORT tx counter value.
   * @param  index: select SPORT.
   */
 u32 AUDIO_SP_GetTXCounterVal(u32 index)
 {
 	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
-	SPORTx->SP_RX_LRCLK |= SP_BIT_EN_FS_PHASE_LATCH;
 	u32 tx_counter = ((SPORTx->SP_DSP_COUNTER) & SP_MASK_TX_SPORT_COUNTER) >> 5;
 	return tx_counter;
 }
 
+/**
+  * @brief  Get SPORT tx phase value.
+  * @param  index: select SPORT.
+  */
+u32 AUDIO_SP_GetTXPhaseVal(u32 index)
+{
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+	u32 tx_phase = (SPORTx->SP_DSP_COUNTER) & SP_MASK_TX_FS_PHASE_RPT;
+	return tx_phase;
+}
 
 /**
   * @brief  Enable or disable SPORT RX counter interrupt.
@@ -1350,11 +1578,34 @@ void AUDIO_SP_ClearRXCounterIrq(u32 index)
 u32 AUDIO_SP_GetRXCounterVal(u32 index)
 {
 	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
-	SPORTx->SP_RX_LRCLK |= SP_BIT_EN_FS_PHASE_LATCH;
 	u32 rx_counter = ((SPORTx->SP_RX_COUNTER2) & SP_MASK_RX_SPORT_COUNTER) >> 5;
 	return rx_counter;
 }
 
+/**
+  * @brief  Get SPORT RX phase.
+  * @param  index: select SPORT.
+  */
+u32 AUDIO_SP_GetRXPhaseVal(u32 index)
+{
+	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
+	u32 rx_phase = (SPORTx->SP_RX_COUNTER2) & SP_MASK_RX_FS_PHASE_RPT;
+	return rx_phase;
+}
+
+/**
+  * @brief  Set SPORT directout mode.
+  * @param  index_src: select directout source SPORT.
+  * @param  index_dir: select directout SPORT.
+  */
+void AUDIO_SP_SetDirectOutMode(u32 index_src, u32 index_dir)
+{
+	AUDIO_SPORT_TypeDef *SPORTx_DIR = AUDIO_DEV_TABLE[index_dir].SPORTx;
+	SPORTx_DIR->SP_CTRL1 |= SP_BIT_DIRECT_MODE_EN;
+	SPORTx_DIR->SP_CTRL1 &= ~SP_MASK_DIRECT_SRC_SEL;
+	SPORTx_DIR->SP_CTRL1 |= SP_DIRECT_SRC_SEL(index_src);
+}
+
 /**
   * @brief  Deinit SPORT.
   * @param  index: select SPORT.
@@ -1364,13 +1615,12 @@ void AUDIO_SP_Deinit(u32 index, u32 direction)
 {
 	assert_param(IS_SP_SET_DIR(direction));
 
-	AUDIO_SPORT_TypeDef *SPORTx = AUDIO_DEV_TABLE[index].SPORTx;
 	if (direction == SP_DIR_TX) {
 		AUDIO_SP_Unregister(index, direction);
-		AUDIO_SP_TXStart(SPORTx, DISABLE);
+		AUDIO_SP_TXStart(index, DISABLE);
 	} else {
 		AUDIO_SP_Unregister(index, direction);
-		AUDIO_SP_RXStart(SPORTx, DISABLE);
+		AUDIO_SP_RXStart(index, DISABLE);
 	}
 
 }
diff --git a/os/board/rtl8730e/src/rtl8730e_i2schar.c b/os/board/rtl8730e/src/rtl8730e_i2schar.c
index a55db2995..5a7039476 100644
--- a/os/board/rtl8730e/src/rtl8730e_i2schar.c
+++ b/os/board/rtl8730e/src/rtl8730e_i2schar.c
@@ -59,20 +59,17 @@ static void err_cb(FAR struct i2s_dev_s *dev, FAR void *arg, int flags)
  *   work with apps/examples/i2schar.
  *
  ****************************************************************************/
-
 int i2schar_devinit(void)
 {
-	static bool initialized;
+	static bool initialized = 0;
 	struct i2s_dev_s *i2s;
 	int ret;
 
-	/* Have we already initialized? */
-
 	if (!initialized) {
+#ifdef CONFIG_AMEBASMART_I2S2
 		/* Call amebasmart_i2s_initialize() to get an instance of the I2S interface */
-
-		//Initialise I2S2
-		i2s = amebasmart_i2s_initialize(0);
+		/* Initialise I2S2 */
+		i2s = amebasmart_i2s_initialize(I2S_NUM_2);
 
 		if (!i2s) {
 			lldbg("ERROR: Failed to get the amebasmart I2S driver\n");
@@ -80,7 +77,6 @@ int i2schar_devinit(void)
 		}
 
 		/* Register the I2S character driver at "/dev/i2schar0" */
-
 		ret = i2schar_register(i2s, CONFIG_AMEBASMART_I2SCHAR_MINOR);
 		if (ret < 0) {
 			lldbg("ERROR: i2schar_register failed: %d\n", ret);
@@ -88,13 +84,28 @@ int i2schar_devinit(void)
 		}
 
 		I2S_ERR_CB_REG(i2s, err_cb, "Error_Test_String");
+#endif
+#ifdef CONFIG_AMEBASMART_I2S3
+		i2s = amebasmart_i2s_initialize(I2S_NUM_3);
 
+		if (!i2s) {
+			lldbg("ERROR: Failed to get the amebasmart I2S driver\n");
+			return -ENODEV;
+		}
 
-		/* Now we are initialized */
+		/* Register the I2S character driver at "/dev/i2schar0" */
+		ret = i2schar_register(i2s, CONFIG_AMEBASMART_I2SCHAR_MINOR);
+		if (ret < 0) {
+			lldbg("ERROR: i2schar_register failed: %d\n", ret);
+			return ret;
+		}
 
+		I2S_ERR_CB_REG(i2s, err_cb, "Error_Test_String");
+#endif
+
+		/* Now we are initialized */
 		initialized = true;
 	}
-
 	return OK;
 }
 
